import { createClient } from '@supabase/supabase-js';
import * as fs from 'fs';
import * as path from 'path';
import * as dotenv from 'dotenv';

// .env íŒŒì¼ ë¡œë“œ
dotenv.config({ path: path.join(__dirname, '../../.env') });

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
  console.error('âŒ SUPABASE_URL ë˜ëŠ” SUPABASE_SERVICE_ROLE_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

// SQLì—ì„œ ì±Œë¦°ì§€ ë°ì´í„° ì¶”ì¶œ
function extractChallengesFromSql(sqlContent: string): any[] {
  const challenges: any[] = [];
  const insertRegex = /INSERT INTO challenges[^V]+VALUES\s*\(([\s\S]+?)\)(?:,\s*\(|;)/g;
  let match;

  while ((match = insertRegex.exec(sqlContent)) !== null) {
    try {
      const valuesStr = match[1];
      const challenge = parseChallenge(valuesStr);
      if (challenge) {
        challenges.push(challenge);
      }
    } catch (err: any) {
      console.error('âš ï¸  ì±Œë¦°ì§€ íŒŒì‹± ì˜¤ë¥˜:', err.message);
    }
  }

  return challenges;
}

function parseChallenge(valuesStr: string): any | null {
  const parts: string[] = [];
  let current = '';
  let inString = false;
  let depth = 0;

  for (let i = 0; i < valuesStr.length; i++) {
    const char = valuesStr[i];

    if (char === "'" && (i === 0 || valuesStr[i - 1] !== '\\')) {
      inString = !inString;
      current += char;
      continue;
    }

    if (!inString) {
      if (char === '[' || char === '{') depth++;
      if (char === ']' || char === '}') depth--;

      if (char === ',' && depth === 0) {
        parts.push(current.trim());
        current = '';
        continue;
      }
    }

    current += char;
  }

  if (current.trim()) {
    parts.push(current.trim());
  }

  if (parts.length < 17) {
    return null;
  }

  const cleanValue = (str: string) => {
    str = str.trim();
    if (str.startsWith("'") && str.endsWith("'")) {
      return str.slice(1, -1).replace(/\'/g, "'");
    }
    return str;
  };

  const parseArray = (str: string): string[] => {
    if (!str.startsWith('ARRAY[')) return [];
    const inner = str.slice(6, -1);
    return inner.split(',').map(s => cleanValue(s.trim()));
  };

  return {
    slug: cleanValue(parts[0]),
    language: cleanValue(parts[1]),
    kind: cleanValue(parts[2]),
    level: parseInt(cleanValue(parts[3])) || 1,
    title: cleanValue(parts[4]),
    description: cleanValue(parts[5]),
    category: cleanValue(parts[6]),
    difficulty: parseInt(cleanValue(parts[7])) || 1,
    problem_description: cleanValue(parts[8]),
    constraints: cleanValue(parts[9]),
    examples: cleanValue(parts[10]),
    initial_code: cleanValue(parts[11]),
    solution_code: cleanValue(parts[12]),
    test_cases: cleanValue(parts[13]),
    hints: cleanValue(parts[14]),
    tags: parseArray(parts[15]),
    estimated_time: parseInt(cleanValue(parts[16])) || 5,
  };
}

async function main() {
  console.log('\nğŸš€ C ì–¸ì–´ ì±Œë¦°ì§€ ì—…ë¡œë“œ ì‹œì‘\n');

  // 1. ê¸°ì¡´ C ì–¸ì–´ ë°ì´í„° ì‚­ì œ
  console.log('ğŸ—‘ï¸  ê¸°ì¡´ C ì–¸ì–´ ì±Œë¦°ì§€ ì‚­ì œ ì¤‘...');
  const { error: deleteError } = await supabase
    .from('challenges')
    .delete()
    .eq('language', 'c');

  if (deleteError && deleteError.code !== 'PGRST116') {
    console.error('âŒ ì‚­ì œ ì‹¤íŒ¨:', deleteError.message);
  } else {
    console.log('âœ… ê¸°ì¡´ ë°ì´í„° ì‚­ì œ ì™„ë£Œ\n');
  }

  // 2. Part1 ì—…ë¡œë“œ
  console.log('ğŸ“¤ c-part1.sql ì½ëŠ” ì¤‘...');
  const part1Path = path.join(__dirname, 'c-part1.sql');
  const part1Content = fs.readFileSync(part1Path, 'utf-8');
  const part1Challenges = extractChallengesFromSql(part1Content);
  console.log(`   ğŸ“Š ${part1Challenges.length}ê°œ ì±Œë¦°ì§€ ë°œê²¬`);

  let successCount = 0;
  const batchSize = 10;

  for (let i = 0; i < part1Challenges.length; i += batchSize) {
    const batch = part1Challenges.slice(i, i + batchSize);
    const { error } = await supabase.from('challenges').insert(batch);

    if (error) {
      console.error(`   âŒ [${i + 1}-${i + batch.length}] ì‹¤íŒ¨:`, error.message);
    } else {
      successCount += batch.length;
      console.log(`   âœ… [${i + 1}-${i + batch.length}] ì„±ê³µ`);
    }

    await new Promise(resolve => setTimeout(resolve, 100));
  }

  console.log(`   âœ… Part1: ${successCount}/${part1Challenges.length}ê°œ ì—…ë¡œë“œ ì„±ê³µ\n`);

  // 3. Part2 ì—…ë¡œë“œ
  console.log('ğŸ“¤ c-part2.sql ì½ëŠ” ì¤‘...');
  const part2Path = path.join(__dirname, 'c-part2.sql');
  const part2Content = fs.readFileSync(part2Path, 'utf-8');
  const part2Challenges = extractChallengesFromSql(part2Content);
  console.log(`   ğŸ“Š ${part2Challenges.length}ê°œ ì±Œë¦°ì§€ ë°œê²¬`);

  successCount = 0;

  for (let i = 0; i < part2Challenges.length; i += batchSize) {
    const batch = part2Challenges.slice(i, i + batchSize);
    const { error } = await supabase.from('challenges').insert(batch);

    if (error) {
      console.error(`   âŒ [${i + 1}-${i + batch.length}] ì‹¤íŒ¨:`, error.message);
    } else {
      successCount += batch.length;
      console.log(`   âœ… [${i + 1}-${i + batch.length}] ì„±ê³µ`);
    }

    await new Promise(resolve => setTimeout(resolve, 100));
  }

  console.log(`   âœ… Part2: ${successCount}/${part2Challenges.length}ê°œ ì—…ë¡œë“œ ì„±ê³µ\n`);

  // 4. ìµœì¢… í™•ì¸
  const { data, error } = await supabase
    .from('challenges')
    .select('unit_number, id')
    .eq('language', 'c')
    .order('unit_number');

  if (error) {
    console.error('âŒ í™•ì¸ ì‹¤íŒ¨:', error);
    return;
  }

  const unitCounts: Record<number, number> = {};
  data?.forEach(challenge => {
    unitCounts[challenge.unit_number] = (unitCounts[challenge.unit_number] || 0) + 1;
  });

  console.log('=== C ì–¸ì–´ ì±Œë¦°ì§€ ì—…ë¡œë“œ ê²°ê³¼ ===\n');
  for (let unit = 1; unit <= 10; unit++) {
    const count = unitCounts[unit] || 0;
    const status = count > 0 ? 'âœ…' : 'âŒ';
    console.log(`${status} Unit ${unit}: ${count} challenges`);
  }
  console.log(`\nì´ ${data?.length || 0}ê°œ ì±Œë¦°ì§€ ì—…ë¡œë“œë¨\n`);
}

main().catch(console.error);
