{
  "language": "c",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 C 프로그램을 작성합니다. main 함수의 올바른 선언은?",
      "options": [
        "int main(void)",
        "void main()",
        "main()",
        "public static void main()"
      ],
      "correctAnswer": 0,
      "explanation": "C 표준에서 main 함수는 int main(void) 또는 int main(int argc, char *argv[]) 형태입니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 콘솔에 출력하려고 합니다. 사용할 함수는?",
      "options": [
        "printf()",
        "print()",
        "cout",
        "System.out.println()"
      ],
      "correctAnswer": 0,
      "explanation": "C에서는 stdio.h의 printf() 함수를 사용하여 출력합니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 헤더 파일을 포함합니다. #include <stdio.h> 여기서 #include의 역할은?",
      "options": [
        "전처리기 지시문으로 파일을 포함",
        "주석",
        "함수 호출",
        "변수 선언"
      ],
      "correctAnswer": 0,
      "explanation": "#include는 전처리기 지시문으로 다른 파일의 내용을 포함시킵니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 C 파일을 컴파일합니다. gcc의 -o 옵션의 역할은?",
      "options": [
        "출력 파일 이름 지정",
        "최적화",
        "오류 표시",
        "디버깅"
      ],
      "correctAnswer": 0,
      "explanation": "-o 옵션은 컴파일된 실행 파일의 이름을 지정합니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 주석을 작성합니다. C99 이후 추가된 주석 방식은?",
      "options": [
        "// 한 줄 주석",
        "# 주석",
        "' 주석",
        "-- 주석"
      ],
      "correctAnswer": 0,
      "explanation": "C99부터 C++의 // 한 줄 주석을 지원합니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 변수를 선언합니다. int x = 10; 여기서 int는?",
      "options": [
        "데이터 타입",
        "변수 이름",
        "값",
        "함수"
      ],
      "correctAnswer": 0,
      "explanation": "int는 정수형 데이터 타입입니다."
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 상수를 정의합니다. #define PI 3.14 이것은?",
      "options": [
        "매크로 상수 정의",
        "변수 선언",
        "함수 정의",
        "주석"
      ],
      "correctAnswer": 0,
      "explanation": "#define은 전처리기 매크로로 상수를 정의합니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 부호 없는 정수를 사용합니다. unsigned int의 특징은?",
      "options": [
        "0과 양수만 표현 가능",
        "음수만 표현",
        "int와 같음",
        "실수 표현"
      ],
      "correctAnswer": 0,
      "explanation": "unsigned는 부호 없는 타입으로 0과 양수만 표현할 수 있습니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 sizeof 연산자를 사용합니다. sizeof(int)는?",
      "options": [
        "int 타입의 바이트 크기 반환",
        "int의 값",
        "항상 4",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "sizeof는 타입이나 변수의 바이트 크기를 반환합니다 (플랫폼에 따라 다를 수 있음)."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 문자를 저장합니다. char c = 'A'; 여기서 'A'의 타입은?",
      "options": [
        "char (문자 상수)",
        "string",
        "int",
        "문자열"
      ],
      "correctAnswer": 0,
      "explanation": "작은따옴표로 감싼 것은 문자 상수입니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 나눗셈을 합니다. 7 / 2의 결과는? (int형)",
      "options": [
        "3",
        "3.5",
        "4",
        "3.0"
      ],
      "correctAnswer": 0,
      "explanation": "정수 나눗셈은 소수점을 버리고 몫만 반환합니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 증감 연산자를 사용합니다. int x = 5; int y = x++; 실행 후 y의 값은?",
      "options": [
        "5",
        "6",
        "4",
        "0"
      ],
      "correctAnswer": 0,
      "explanation": "x++는 후위 증가로, y에 할당한 후 x가 증가합니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 비트 연산을 합니다. 5 & 3의 결과는? (이진: 101 & 011)",
      "options": [
        "1 (이진: 001)",
        "7",
        "5",
        "3"
      ],
      "correctAnswer": 0,
      "explanation": "비트 AND 연산: 101 & 011 = 001 (십진수 1)"
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 시프트 연산을 합니다. 4 << 1의 결과는?",
      "options": [
        "8",
        "2",
        "4",
        "1"
      ],
      "correctAnswer": 0,
      "explanation": "왼쪽 시프트(<<)는 비트를 왼쪽으로 이동시킵니다. 4(100) << 1 = 8(1000)"
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 조건 연산자를 사용합니다. (x > 0) ? 1 : -1; x가 5일 때 결과는?",
      "options": [
        "1",
        "-1",
        "5",
        "0"
      ],
      "correctAnswer": 0,
      "explanation": "조건이 true이므로 ? 다음의 값 1이 반환됩니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 if문을 작성합니다. if (x = 5) {} 이 코드는?",
      "options": [
        "x에 5를 할당하고 항상 true로 평가",
        "x가 5인지 확인",
        "오류 발생",
        "false"
      ],
      "correctAnswer": 0,
      "explanation": "C에서 =는 할당 연산자이고, 할당 결과(5)가 true로 평가됩니다. ==를 사용해야 합니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 switch문을 작성합니다. break를 생략하면?",
      "options": [
        "다음 case로 계속 실행됨 (fall-through)",
        "오류 발생",
        "자동 종료",
        "default로 이동"
      ],
      "correctAnswer": 0,
      "explanation": "break가 없으면 다음 case가 계속 실행됩니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 조건을 확인합니다. C에서 0이 아닌 값은?",
      "options": [
        "true로 평가됨",
        "false로 평가됨",
        "오류",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "C에서는 0이 false, 0이 아닌 모든 값이 true로 평가됩니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 goto를 사용합니다. goto의 권장 사항은?",
      "options": [
        "가급적 사용하지 않는 것이 좋음",
        "항상 사용",
        "필수",
        "반복문 대신 사용"
      ],
      "correctAnswer": 0,
      "explanation": "goto는 코드 가독성을 해칠 수 있어 일반적으로 사용을 권장하지 않습니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 NULL을 확인합니다. if (ptr == NULL) {} NULL의 의미는?",
      "options": [
        "널 포인터 (주소 0)",
        "1",
        "-1",
        "무한대"
      ],
      "correctAnswer": 0,
      "explanation": "NULL은 아무것도 가리키지 않는 널 포인터를 나타냅니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 for문을 작성합니다. for (int i = 0; i < 10; i++) {} 이 반복문은 몇 번 실행되나요?",
      "options": [
        "10번",
        "9번",
        "11번",
        "무한 반복"
      ],
      "correctAnswer": 0,
      "explanation": "i는 0부터 9까지 10번 반복됩니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 while문을 작성합니다. while (1) {} 이 코드는?",
      "options": [
        "무한 반복",
        "한 번 실행",
        "실행 안 됨",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "1은 항상 true이므로 무한 반복됩니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 do-while을 사용합니다. 최소 실행 횟수는?",
      "options": [
        "1번",
        "0번",
        "2번",
        "조건에 따라 다름"
      ],
      "correctAnswer": 0,
      "explanation": "do-while은 조건을 나중에 검사하므로 최소 1번은 실행됩니다."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 break를 사용합니다. switch와 반복문에서 break의 차이는?",
      "options": [
        "둘 다 해당 블록을 빠져나감",
        "switch에서만 사용 가능",
        "반복문에서만 사용 가능",
        "완전히 다른 동작"
      ],
      "correctAnswer": 0,
      "explanation": "break는 switch문이나 반복문에서 현재 블록을 즉시 빠져나갑니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 중첩 반복문에서 빠져나오려고 합니다. break는?",
      "options": [
        "가장 가까운 반복문만 종료",
        "모든 반복문 종료",
        "프로그램 종료",
        "사용 불가"
      ],
      "correctAnswer": 0,
      "explanation": "break는 가장 가까운 반복문 하나만 종료합니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 함수를 정의합니다. int add(int a, int b) { return a + b; } 반환 타입은?",
      "options": [
        "int",
        "void",
        "double",
        "char"
      ],
      "correctAnswer": 0,
      "explanation": "함수 이름 앞의 int는 함수가 int 타입을 반환함을 나타냅니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 함수 프로토타입을 선언합니다. 프로토타입의 역할은?",
      "options": [
        "함수를 사용 전에 미리 선언",
        "함수 구현",
        "변수 선언",
        "매크로 정의"
      ],
      "correctAnswer": 0,
      "explanation": "함수 프로토타입은 함수를 정의하기 전에 사용할 수 있게 미리 선언합니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 void 함수를 만듭니다. void print() {} 반환값은?",
      "options": [
        "없음",
        "0",
        "NULL",
        "빈 문자열"
      ],
      "correctAnswer": 0,
      "explanation": "void는 함수가 값을 반환하지 않음을 나타냅니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 재귀 함수를 만듭니다. 팩토리얼 재귀 함수에서 base case는?",
      "options": [
        "n == 0 또는 n == 1일 때 1 반환",
        "n == 10",
        "무한 재귀",
        "없음"
      ],
      "correctAnswer": 0,
      "explanation": "재귀 함수는 종료 조건(base case)이 필요합니다. 팩토리얼은 0! = 1, 1! = 1입니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 static 지역 변수를 사용합니다. static int count = 0; 특징은?",
      "options": [
        "함수 호출 간 값이 유지됨",
        "함수 종료 시 소멸",
        "전역 변수와 같음",
        "읽기 전용"
      ],
      "correctAnswer": 0,
      "explanation": "static 지역 변수는 함수 호출이 끝나도 값이 유지됩니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 배열을 선언합니다. int arr[5]; 배열의 첫 번째 요소는?",
      "options": [
        "arr[0]",
        "arr[1]",
        "arr.first",
        "arr(0)"
      ],
      "correctAnswer": 0,
      "explanation": "배열의 인덱스는 0부터 시작합니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 배열을 초기화합니다. int arr[] = {1, 2, 3}; 배열의 크기는?",
      "options": [
        "3 (자동 계산)",
        "명시 필요",
        "오류",
        "무한"
      ],
      "correctAnswer": 0,
      "explanation": "초기화 리스트가 있으면 배열 크기가 자동으로 계산됩니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 문자열을 다룹니다. char str[] = \"Hello\"; 실제 배열 크기는?",
      "options": [
        "6 (널 문자 포함)",
        "5",
        "4",
        "7"
      ],
      "correctAnswer": 0,
      "explanation": "문자열은 마지막에 널 문자('\\0')가 자동으로 추가됩니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 2차원 배열을 만듭니다. int matrix[3][4]; 총 요소 개수는?",
      "options": [
        "12",
        "7",
        "3",
        "4"
      ],
      "correctAnswer": 0,
      "explanation": "3행 4열이므로 3 × 4 = 12개의 요소가 있습니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 배열을 함수에 전달합니다. void func(int arr[]) {} 실제 전달되는 것은?",
      "options": [
        "배열의 시작 주소 (포인터)",
        "배열 전체 복사",
        "배열 크기",
        "첫 번째 요소"
      ],
      "correctAnswer": 0,
      "explanation": "C에서 배열을 함수에 전달하면 포인터(주소)가 전달됩니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 포인터를 선언합니다. int *ptr; *의 의미는?",
      "options": [
        "포인터 선언",
        "곱셈",
        "주석",
        "역참조"
      ],
      "correctAnswer": 0,
      "explanation": "타입 옆의 *는 포인터 변수를 선언합니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 주소 연산자를 사용합니다. &x의 의미는?",
      "options": [
        "x의 메모리 주소",
        "x의 값",
        "x의 타입",
        "x의 크기"
      ],
      "correctAnswer": 0,
      "explanation": "&는 주소 연산자로 변수의 메모리 주소를 반환합니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 역참조를 합니다. *ptr = 10; 이것은?",
      "options": [
        "ptr이 가리키는 위치에 10 저장",
        "ptr에 10 저장",
        "오류",
        "ptr의 주소에 10 저장"
      ],
      "correctAnswer": 0,
      "explanation": "*ptr은 포인터가 가리키는 주소의 값에 접근합니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 널 포인터를 확인합니다. if (ptr == NULL) {} 확인하는 이유는?",
      "options": [
        "유효하지 않은 포인터 접근 방지",
        "성능 향상",
        "필수 문법",
        "메모리 절약"
      ],
      "correctAnswer": 0,
      "explanation": "NULL 포인터를 역참조하면 런타임 오류가 발생하므로 확인이 필요합니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 동적 메모리를 할당합니다. malloc()의 반환 타입은?",
      "options": [
        "void* (형변환 필요)",
        "int*",
        "char*",
        "NULL"
      ],
      "correctAnswer": 0,
      "explanation": "malloc()은 void* 타입을 반환하므로 적절한 포인터 타입으로 형변환해야 합니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 구조체를 정의합니다. struct Person { char name[50]; int age; }; 구조체의 역할은?",
      "options": [
        "여러 타입의 데이터를 하나로 묶음",
        "배열",
        "포인터",
        "함수"
      ],
      "correctAnswer": 0,
      "explanation": "구조체는 서로 다른 타입의 변수들을 하나의 단위로 묶습니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 구조체 변수를 선언합니다. struct Person p; p의 멤버에 접근하려면?",
      "options": [
        "p.name, p.age",
        "p->name, p->age",
        "p[name], p[age]",
        "p::name, p::age"
      ],
      "correctAnswer": 0,
      "explanation": "구조체 변수의 멤버는 점(.) 연산자로 접근합니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 구조체 포인터를 사용합니다. struct Person *ptr; ptr->age의 의미는?",
      "options": [
        "포인터가 가리키는 구조체의 age 멤버",
        "오류",
        "ptr의 age 필드",
        "age 포인터"
      ],
      "correctAnswer": 0,
      "explanation": "-> 연산자는 구조체 포인터의 멤버에 접근합니다 (*ptr).age와 같음."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 typedef를 사용합니다. typedef struct Person Person; 효과는?",
      "options": [
        "struct 키워드 없이 Person으로 사용 가능",
        "구조체 복사",
        "구조체 삭제",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "typedef는 타입에 별칭을 붙여서 사용을 간편하게 합니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 공용체를 사용합니다. union Data {} 구조체와의 차이는?",
      "options": [
        "모든 멤버가 같은 메모리 공유",
        "더 큰 메모리 사용",
        "차이 없음",
        "배열만 가능"
      ],
      "correctAnswer": 0,
      "explanation": "공용체는 모든 멤버가 같은 메모리 공간을 공유하여 한 번에 하나의 멤버만 사용할 수 있습니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 파일을 엽니다. FILE *fp = fopen(\"file.txt\", \"r\"); \"r\"의 의미는?",
      "options": [
        "읽기 모드로 열기",
        "쓰기 모드",
        "추가 모드",
        "실행 모드"
      ],
      "correctAnswer": 0,
      "explanation": "\"r\"은 읽기(read) 모드로 파일을 엽니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 파일에 씁니다. fprintf(fp, \"%d\", num); fprintf의 역할은?",
      "options": [
        "파일에 형식화된 출력",
        "파일 읽기",
        "파일 닫기",
        "파일 삭제"
      ],
      "correctAnswer": 0,
      "explanation": "fprintf()는 printf()와 유사하지만 파일에 출력합니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 파일을 닫습니다. fclose(fp); 파일을 닫는 이유는?",
      "options": [
        "리소스 해제와 버퍼 플러시",
        "필수 아님",
        "파일 삭제",
        "성능 저하"
      ],
      "correctAnswer": 0,
      "explanation": "파일을 닫으면 버퍼의 내용이 저장되고 시스템 리소스가 해제됩니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 동적 메모리를 해제합니다. free(ptr); free를 사용하는 이유는?",
      "options": [
        "메모리 누수 방지",
        "속도 향상",
        "필수 아님",
        "변수 삭제"
      ],
      "correctAnswer": 0,
      "explanation": "malloc/calloc으로 할당한 메모리는 반드시 free()로 해제해야 메모리 누수를 방지할 수 있습니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 메모리를 재할당합니다. realloc(ptr, new_size); realloc의 역할은?",
      "options": [
        "할당된 메모리 크기 변경",
        "메모리 해제",
        "메모리 초기화",
        "메모리 복사"
      ],
      "correctAnswer": 0,
      "explanation": "realloc()은 이미 할당된 메모리의 크기를 변경합니다."
    }
  ]
}
