{
  "language": "go",
  "questions": [
    {"id": 1, "chapter": 1, "question": "바데부가 Go 프로그램을 작성합니다. main 함수가 속한 패키지는?", "options": ["package main", "package go", "package start", "package app"], "correctAnswer": 0, "explanation": "실행 가능한 프로그램은 package main을 사용합니다."},
    {"id": 2, "chapter": 1, "question": "바데부가 콘솔에 출력합니다. 사용할 함수는?", "options": ["fmt.Println()", "print()", "console.log()", "System.out.println()"], "correctAnswer": 0, "explanation": "fmt 패키지의 Println을 사용합니다."},
    {"id": 3, "chapter": 1, "question": "바데부가 패키지를 임포트합니다. import \"fmt\" 임포트 경로는?", "options": ["큰따옴표로 감쌈", "작은따옴표", "괄호", "중괄호"], "correctAnswer": 0, "explanation": "Go에서 import 경로는 큰따옴표로 감쌉니다."},
    {"id": 4, "chapter": 1, "question": "바데부가 main 함수를 작성합니다. func main() {} 반환 타입이 없는 이유는?", "options": ["main은 항상 void", "생략 가능", "오류", "int 반환"], "correctAnswer": 0, "explanation": "main 함수는 반환 타입이 없습니다."},
    {"id": 5, "chapter": 1, "question": "바데부가 주석을 작성합니다. Go의 한 줄 주석은?", "options": ["// 주석", "# 주석", "/* 주석 */", "' 주석"], "correctAnswer": 0, "explanation": "//는 한 줄 주석입니다."},
    {"id": 6, "chapter": 2, "question": "바데부가 변수를 선언합니다. var x int = 10; 짧은 선언은?", "options": ["x := 10", "x = 10", "let x = 10", "int x = 10"], "correctAnswer": 0, "explanation": ":=는 타입 추론과 함께 변수를 선언하고 초기화합니다."},
    {"id": 7, "chapter": 2, "question": "바데부가 상수를 선언합니다. const PI = 3.14; const의 특징은?", "options": ["컴파일 타임에 결정", "런타임에 결정", "변경 가능", "함수 내부만"], "correctAnswer": 0, "explanation": "const는 컴파일 타임 상수입니다."},
    {"id": 8, "chapter": 2, "question": "바데부가 여러 변수를 선언합니다. var (x int; y string) 이것은?", "options": ["그룹 선언", "오류", "배열", "구조체"], "correctAnswer": 0, "explanation": "괄호로 여러 변수를 그룹으로 선언할 수 있습니다."},
    {"id": 9, "chapter": 2, "question": "바데부가 제로 값을 확인합니다. var x int의 초기값은?", "options": ["0", "nil", "undefined", "오류"], "correctAnswer": 0, "explanation": "int의 제로 값은 0입니다."},
    {"id": 10, "chapter": 2, "question": "바데부가 타입 추론을 사용합니다. x := \"Hello\" x의 타입은?", "options": ["string", "var", "auto", "text"], "correctAnswer": 0, "explanation": ":=는 우변의 값으로 타입을 추론합니다."},
    {"id": 11, "chapter": 3, "question": "바데부가 포인터를 사용합니다. var p *int; *의 의미는?", "options": ["포인터 타입", "곱셈", "역참조", "주석"], "correctAnswer": 0, "explanation": "*는 포인터 타입을 선언합니다."},
    {"id": 12, "chapter": 3, "question": "바데부가 주소를 얻습니다. &x의 의미는?", "options": ["x의 메모리 주소", "x의 값", "x의 타입", "x 삭제"], "correctAnswer": 0, "explanation": "&는 주소 연산자입니다."},
    {"id": 13, "chapter": 3, "question": "바데부가 증감 연산을 합니다. x++ 이것은?", "options": ["문(statement)", "식(expression)", "함수", "타입"], "correctAnswer": 0, "explanation": "Go에서 ++는 문이므로 y = x++처럼 사용할 수 없습니다."},
    {"id": 14, "chapter": 3, "question": "바데부가 비교합니다. Go에서 ==의 역할은?", "options": ["같은지 비교", "할당", "타입 변환", "삭제"], "correctAnswer": 0, "explanation": "==는 동등성을 비교합니다."},
    {"id": 15, "chapter": 3, "question": "바데부가 문자열을 더합니다. \"Hello\" + \" World\" 결과는?", "options": ["\"Hello World\"", "오류", "\"HelloWorld\"", "\"Hello+World\""], "correctAnswer": 0, "explanation": "+ 연산자로 문자열을 연결할 수 있습니다."},
    {"id": 16, "chapter": 4, "question": "바데부가 if문을 작성합니다. if x := getValue(); x > 0 {} 세미콜론의 역할은?", "options": ["초기화 문과 조건 분리", "문장 종료", "주석", "오류"], "correctAnswer": 0, "explanation": "if문에서 초기화 문을 사용할 수 있습니다."},
    {"id": 17, "chapter": 4, "question": "바데부가 switch를 작성합니다. Go의 switch는 break가 필요한가요?", "options": ["불필요, 자동으로 break", "필수", "선택적", "오류"], "correctAnswer": 0, "explanation": "Go의 switch는 자동으로 break되며, 계속하려면 fallthrough를 사용합니다."},
    {"id": 18, "chapter": 4, "question": "바데부가 조건 없는 switch를 사용합니다. switch {} 의 역할은?", "options": ["if-else 체인의 깔끔한 대안", "오류", "무한 반복", "삭제"], "correctAnswer": 0, "explanation": "조건 없는 switch는 여러 조건을 깔끔하게 표현합니다."},
    {"id": 19, "chapter": 4, "question": "바데부가 타입 switch를 사용합니다. switch v := x.(type) {} 의 역할은?", "options": ["인터페이스의 실제 타입 확인", "값 비교", "오류", "타입 변환"], "correctAnswer": 0, "explanation": "타입 switch는 인터페이스 값의 타입을 확인합니다."},
    {"id": 20, "chapter": 4, "question": "바데부가 조건을 확인합니다. Go에는 삼항 연산자가 있나요?", "options": ["없음, if-else 사용", "있음, ? :", "있음, ? |", "있음, ?"], "correctAnswer": 0, "explanation": "Go에는 삼항 연산자가 없습니다."},
    {"id": 21, "chapter": 5, "question": "바데부가 for 반복문을 작성합니다. for i := 0; i < 10; i++ {} 실행 횟수는?", "options": ["10번", "9번", "11번", "무한"], "correctAnswer": 0, "explanation": "i는 0부터 9까지 10번 반복됩니다."},
    {"id": 22, "chapter": 5, "question": "바데부가 무한 반복을 만듭니다. for {} 의 의미는?", "options": ["무한 반복", "오류", "한 번 실행", "실행 안 됨"], "correctAnswer": 0, "explanation": "조건 없는 for는 무한 반복입니다."},
    {"id": 23, "chapter": 5, "question": "바데부가 range를 사용합니다. for i, v := range slice {} i와 v는?", "options": ["i는 인덱스, v는 값", "둘 다 값", "둘 다 인덱스", "오류"], "correctAnswer": 0, "explanation": "range는 인덱스와 값을 반환합니다."},
    {"id": 24, "chapter": 5, "question": "바데부가 값을 무시합니다. for _, v := range slice {} _의 의미는?", "options": ["빈 식별자로 값을 무시", "변수 이름", "오류", "모든 값"], "correctAnswer": 0, "explanation": "_는 사용하지 않을 값을 나타냅니다."},
    {"id": 25, "chapter": 5, "question": "바데부가 while처럼 사용합니다. for x < 10 {} 이것은?", "options": ["조건만 있는 for (while처럼 동작)", "오류", "무한 반복", "한 번 실행"], "correctAnswer": 0, "explanation": "Go에는 while이 없고 for를 사용합니다."},
    {"id": 26, "chapter": 6, "question": "바데부가 함수를 정의합니다. func add(a, b int) int {} 반환 타입 위치는?", "options": ["매개변수 뒤", "함수 이름 앞", "중괄호 안", "없음"], "correctAnswer": 0, "explanation": "반환 타입은 매개변수 목록 뒤에 옵니다."},
    {"id": 27, "chapter": 6, "question": "바데부가 여러 값을 반환합니다. func swap(x, y int) (int, int) {} Go의 특징은?", "options": ["다중 반환값 지원", "불가능", "배열로만", "오류"], "correctAnswer": 0, "explanation": "Go는 여러 값을 반환할 수 있습니다."},
    {"id": 28, "chapter": 6, "question": "바데부가 명명된 반환값을 사용합니다. func div(x, y int) (result int) {} 의 장점은?", "options": ["자동 초기화, naked return 가능", "더 빠름", "필수", "오류"], "correctAnswer": 0, "explanation": "명명된 반환값은 자동으로 초기화되고 return만 써도 됩니다."},
    {"id": 29, "chapter": 6, "question": "바데부가 가변 인자를 사용합니다. func sum(nums ...int) {} ...의 의미는?", "options": ["가변 개수의 인자", "배열", "포인터", "오류"], "correctAnswer": 0, "explanation": "...는 가변 인자를 나타냅니다."},
    {"id": 30, "chapter": 6, "question": "바데부가 익명 함수를 만듭니다. f := func() {} 클로저의 특징은?", "options": ["외부 변수를 캡처", "독립적", "정적", "오류"], "correctAnswer": 0, "explanation": "클로저는 외부 변수를 캡처하고 접근할 수 있습니다."},
    {"id": 31, "chapter": 7, "question": "바데부가 배열을 선언합니다. var arr [5]int; 배열의 크기는?", "options": ["고정, 타입의 일부", "가변", "동적", "무한"], "correctAnswer": 0, "explanation": "배열의 크기는 타입의 일부로 고정됩니다."},
    {"id": 32, "chapter": 7, "question": "바데부가 슬라이스를 만듭니다. slice := []int{1, 2, 3}; 슬라이스의 특징은?", "options": ["동적 크기, 배열의 뷰", "고정 크기", "배열과 같음", "사용 불가"], "correctAnswer": 0, "explanation": "슬라이스는 동적 크기를 가진 배열의 참조입니다."},
    {"id": 33, "chapter": 7, "question": "바데부가 슬라이스에 추가합니다. append(slice, 4) append의 특징은?", "options": ["새 슬라이스 반환", "원본 수정", "오류", "삭제"], "correctAnswer": 0, "explanation": "append는 새로운 슬라이스를 반환합니다."},
    {"id": 34, "chapter": 7, "question": "바데부가 슬라이싱을 합니다. slice[1:3]의 의미는?", "options": ["인덱스 1부터 2까지", "1부터 3까지", "1만", "오류"], "correctAnswer": 0, "explanation": "슬라이싱은 시작 포함, 끝 불포함입니다."},
    {"id": 35, "chapter": 7, "question": "바데부가 make를 사용합니다. make([]int, 5, 10) 5와 10은?", "options": ["5는 길이, 10은 용량", "5는 용량, 10은 길이", "둘 다 길이", "오류"], "correctAnswer": 0, "explanation": "make의 두 번째 인자는 길이, 세 번째는 용량입니다."},
    {"id": 36, "chapter": 8, "question": "바데부가 구조체를 정의합니다. type Person struct {} struct의 역할은?", "options": ["여러 필드를 묶음", "배열", "인터페이스", "함수"], "correctAnswer": 0, "explanation": "struct는 필드들을 하나로 묶습니다."},
    {"id": 37, "chapter": 8, "question": "바데부가 구조체 리터럴을 사용합니다. Person{Name: \"Badebu\"} 의 방식은?", "options": ["필드 이름 지정", "순서대로", "오류", "인덱스"], "correctAnswer": 0, "explanation": "필드 이름을 명시하여 초기화할 수 있습니다."},
    {"id": 38, "chapter": 8, "question": "바데부가 메서드를 정의합니다. func (p Person) Speak() {} (p Person)의 의미는?", "options": ["리시버, 메서드가 속한 타입", "매개변수", "반환 타입", "오류"], "correctAnswer": 0, "explanation": "리시버는 메서드가 어느 타입에 속하는지 나타냅니다."},
    {"id": 39, "chapter": 8, "question": "바데부가 포인터 리시버를 사용합니다. func (p *Person) SetName(n string) {} *의 역할은?", "options": ["원본 수정 가능", "복사본 수정", "읽기 전용", "오류"], "correctAnswer": 0, "explanation": "포인터 리시버는 원본 구조체를 수정할 수 있습니다."},
    {"id": 40, "chapter": 8, "question": "바데부가 익명 필드를 사용합니다. type Employee struct { Person } 이것은?", "options": ["임베딩으로 상속처럼 동작", "배열", "오류", "삭제"], "correctAnswer": 0, "explanation": "익명 필드로 타입을 임베딩하여 필드와 메서드를 상속받을 수 있습니다."},
    {"id": 41, "chapter": 9, "question": "바데부가 인터페이스를 정의합니다. type Speaker interface { Speak() } 인터페이스의 특징은?", "options": ["메서드 집합 정의", "구현 제공", "상속", "클래스"], "correctAnswer": 0, "explanation": "인터페이스는 메서드 시그니처의 집합입니다."},
    {"id": 42, "chapter": 9, "question": "바데부가 인터페이스를 구현합니다. Go에서 implements 키워드는?", "options": ["없음, 암시적 구현", "필수", "명시적", "오류"], "correctAnswer": 0, "explanation": "Go는 인터페이스를 암시적으로 구현합니다."},
    {"id": 43, "chapter": 9, "question": "바데부가 빈 인터페이스를 사용합니다. interface{} 의 의미는?", "options": ["모든 타입을 받을 수 있음", "아무것도 못 받음", "오류", "삭제"], "correctAnswer": 0, "explanation": "빈 인터페이스는 모든 타입이 구현하므로 any 타입처럼 동작합니다."},
    {"id": 44, "chapter": 9, "question": "바데부가 타입 단언을 사용합니다. str := val.(string) 의 역할은?", "options": ["인터페이스 값을 구체 타입으로", "타입 변환", "비교", "삭제"], "correctAnswer": 0, "explanation": "타입 단언은 인터페이스 값의 실제 타입을 추출합니다."},
    {"id": 45, "chapter": 9, "question": "바데부가 안전한 타입 단언을 합니다. str, ok := val.(string) ok의 의미는?", "options": ["타입 단언 성공 여부", "값", "타입", "오류"], "correctAnswer": 0, "explanation": "두 번째 반환값으로 타입 단언 성공 여부를 확인할 수 있습니다."},
    {"id": 46, "chapter": 10, "question": "바데부가 고루틴을 시작합니다. go func() {} go의 역할은?", "options": ["함수를 동시에 실행", "순차 실행", "삭제", "오류"], "correctAnswer": 0, "explanation": "go 키워드는 고루틴을 시작하여 동시 실행합니다."},
    {"id": 47, "chapter": 10, "question": "바데부가 채널을 만듭니다. ch := make(chan int) 채널의 역할은?", "options": ["고루틴 간 통신", "배열", "포인터", "함수"], "correctAnswer": 0, "explanation": "채널은 고루틴 간 안전하게 데이터를 주고받습니다."},
    {"id": 48, "chapter": 10, "question": "바데부가 채널에 보냅니다. ch <- 10; <-의 의미는?", "options": ["채널로 값 전송", "채널에서 수신", "비교", "삭제"], "correctAnswer": 0, "explanation": "<-는 채널 방향을 나타내며 ch <-는 전송입니다."},
    {"id": 49, "chapter": 10, "question": "바데부가 버퍼드 채널을 만듭니다. make(chan int, 10) 10의 의미는?", "options": ["버퍼 크기", "채널 개수", "타입", "오류"], "correctAnswer": 0, "explanation": "두 번째 인자는 채널의 버퍼 크기입니다."},
    {"id": 50, "chapter": 10, "question": "바데부가 select를 사용합니다. select {} 의 역할은?", "options": ["여러 채널 중 준비된 것 선택", "모든 채널 읽기", "채널 생성", "오류"], "correctAnswer": 0, "explanation": "select는 여러 채널 연산 중 하나를 선택합니다."}
  ]
}
