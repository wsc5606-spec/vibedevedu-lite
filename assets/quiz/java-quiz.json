{
  "language": "java",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 Java 프로그램을 작성합니다. main 메서드의 올바른 선언은?",
      "options": [
        "public static void main(String[] args)",
        "public void main(String[] args)",
        "static void main(String args)",
        "void main()"
      ],
      "correctAnswer": 0,
      "explanation": "Java의 main 메서드는 public static void main(String[] args) 형태여야 합니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 콘솔에 출력하려고 합니다. 올바른 코드는?",
      "options": [
        "System.out.println(\"Hello\");",
        "console.log(\"Hello\");",
        "print(\"Hello\");",
        "Console.WriteLine(\"Hello\");"
      ],
      "correctAnswer": 0,
      "explanation": "Java에서는 System.out.println()을 사용하여 콘솔에 출력합니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 Java 파일을 컴파일하려고 합니다. 사용할 명령어는?",
      "options": [
        "javac FileName.java",
        "java FileName.java",
        "compile FileName.java",
        "build FileName.java"
      ],
      "correctAnswer": 0,
      "explanation": "javac는 Java 컴파일러로 .java 파일을 .class 파일로 컴파일합니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 주석을 작성합니다. 한 줄 주석의 올바른 형태는?",
      "options": [
        "// 이것은 주석입니다",
        "# 이것은 주석입니다",
        "<!-- 이것은 주석입니다 -->",
        "' 이것은 주석입니다"
      ],
      "correctAnswer": 0,
      "explanation": "Java에서 한 줄 주석은 //로 시작합니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 클래스 이름을 정합니다. Java의 명명 규칙은?",
      "options": [
        "대문자로 시작하는 PascalCase",
        "소문자로 시작하는 camelCase",
        "snake_case",
        "kebab-case"
      ],
      "correctAnswer": 0,
      "explanation": "Java 클래스 이름은 대문자로 시작하는 PascalCase를 사용합니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 변수를 선언합니다. int age; 여기서 int는?",
      "options": [
        "데이터 타입",
        "변수 이름",
        "값",
        "키워드"
      ],
      "correctAnswer": 0,
      "explanation": "int는 정수형 데이터 타입입니다."
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 상수를 선언합니다. 사용할 키워드는?",
      "options": [
        "final",
        "const",
        "static",
        "readonly"
      ],
      "correctAnswer": 0,
      "explanation": "Java에서는 final 키워드로 상수를 선언합니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 확인한 byte 타입의 크기는?",
      "options": [
        "8비트 (-128 ~ 127)",
        "16비트",
        "32비트",
        "64비트"
      ],
      "correctAnswer": 0,
      "explanation": "byte는 8비트 정수형으로 -128부터 127까지의 값을 저장합니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 실수를 저장하려고 합니다. 더 정밀한 타입은?",
      "options": [
        "double",
        "float",
        "int",
        "long"
      ],
      "correctAnswer": 0,
      "explanation": "double은 64비트로 float(32비트)보다 더 정밀합니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 문자 하나를 저장합니다. 사용할 타입은?",
      "options": [
        "char",
        "string",
        "String",
        "character"
      ],
      "correctAnswer": 0,
      "explanation": "char는 단일 문자를 저장하는 기본 타입입니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 나눗셈을 합니다. 10 / 3의 결과는? (int형)",
      "options": [
        "3",
        "3.333",
        "3.0",
        "4"
      ],
      "correctAnswer": 0,
      "explanation": "정수 나눗셈은 소수점을 버리고 몫만 반환합니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 증감 연산자를 사용합니다. int x = 5; int y = ++x; 실행 후 y의 값은?",
      "options": [
        "6",
        "5",
        "7",
        "4"
      ],
      "correctAnswer": 0,
      "explanation": "++x는 전위 증가로, x를 먼저 증가시킨 후 y에 할당합니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 비교합니다. String 비교에 올바른 방법은?",
      "options": [
        "str1.equals(str2)",
        "str1 == str2",
        "str1 = str2",
        "compare(str1, str2)"
      ],
      "correctAnswer": 0,
      "explanation": "String 비교는 equals() 메서드를 사용해야 합니다. ==는 참조를 비교합니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 논리 연산을 합니다. true && false의 결과는?",
      "options": [
        "false",
        "true",
        "0",
        "1"
      ],
      "correctAnswer": 0,
      "explanation": "AND 연산(&&)은 둘 다 true일 때만 true입니다."
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 삼항 연산자를 사용합니다. int result = (age >= 18) ? 1 : 0; age가 20일 때 result는?",
      "options": [
        "1",
        "0",
        "20",
        "18"
      ],
      "correctAnswer": 0,
      "explanation": "조건이 true이므로 ? 다음의 값 1이 반환됩니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 if문을 작성합니다. if (x = 5) {} 이 코드는?",
      "options": [
        "컴파일 오류 발생",
        "정상 작동",
        "x가 5인지 확인",
        "x에 5 할당 후 true"
      ],
      "correctAnswer": 0,
      "explanation": "Java에서는 조건식에 boolean이 아닌 값을 사용할 수 없습니다. ==를 사용해야 합니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 switch문을 작성합니다. Java 12 이후 새로운 switch 표현식의 특징은?",
      "options": [
        "break 없이 -> 화살표 사용 가능",
        "더 느림",
        "case를 사용할 수 없음",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "Java 12부터 화살표 구문(-&gt;)을 사용하여 break 없이 switch를 작성할 수 있습니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 조건을 확인합니다. if (str != null && str.length() > 0) {} 이 순서가 중요한 이유는?",
      "options": [
        "단락 평가로 NullPointerException 방지",
        "더 빠름",
        "순서는 중요하지 않음",
        "문법 규칙"
      ],
      "correctAnswer": 0,
      "explanation": "&&는 첫 번째 조건이 false면 두 번째를 평가하지 않아 null 체크가 먼저 이루어집니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 여러 조건을 확인합니다. else if는 몇 개까지 사용할 수 있나요?",
      "options": [
        "제한 없음",
        "최대 10개",
        "최대 5개",
        "1개만"
      ],
      "correctAnswer": 0,
      "explanation": "else if는 필요한 만큼 여러 개 사용할 수 있습니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 switch에서 default의 역할을 확인합니다. default는?",
      "options": [
        "모든 case에 해당하지 않을 때 실행",
        "첫 번째로 실행",
        "필수로 작성해야 함",
        "오류 처리"
      ],
      "correctAnswer": 0,
      "explanation": "default는 모든 case에 해당하지 않을 때 실행되는 선택적 블록입니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 for문을 작성합니다. for (int i = 0; i < 10; i++) {} 이 반복문은 몇 번 실행되나요?",
      "options": [
        "10번",
        "9번",
        "11번",
        "무한 반복"
      ],
      "correctAnswer": 0,
      "explanation": "i는 0부터 9까지 10번 반복됩니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 향상된 for문을 사용합니다. for (int num : numbers) {} 이것의 용도는?",
      "options": [
        "배열이나 컬렉션의 모든 요소를 순회",
        "인덱스로 접근",
        "역순으로 순회",
        "오류 코드"
      ],
      "correctAnswer": 0,
      "explanation": "향상된 for문(for-each)은 배열이나 컬렉션의 모든 요소를 간편하게 순회합니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 while문을 작성합니다. while (true) {} 이 코드는?",
      "options": [
        "무한 반복",
        "한 번 실행",
        "실행 안 됨",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "조건이 항상 true이므로 무한 반복됩니다 (break로 탈출 필요)."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 continue를 사용합니다. continue의 역할은?",
      "options": [
        "현재 반복을 건너뛰고 다음 반복으로",
        "반복문 종료",
        "함수 종료",
        "프로그램 종료"
      ],
      "correctAnswer": 0,
      "explanation": "continue는 현재 반복을 즉시 종료하고 다음 반복으로 넘어갑니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 do-while을 사용합니다. 조건이 처음부터 false여도 몇 번 실행되나요?",
      "options": [
        "1번",
        "0번",
        "2번",
        "무한 반복"
      ],
      "correctAnswer": 0,
      "explanation": "do-while은 조건을 나중에 검사하므로 최소 1번은 실행됩니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 메서드를 정의합니다. public int add(int a, int b) { return a + b; } 여기서 int (첫 번째)는?",
      "options": [
        "반환 타입",
        "매개변수 타입",
        "메서드 이름",
        "접근 제어자"
      ],
      "correctAnswer": 0,
      "explanation": "메서드 이름 앞의 타입은 반환 타입을 나타냅니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 void 메서드를 만듭니다. void의 의미는?",
      "options": [
        "반환값이 없음",
        "null 반환",
        "0 반환",
        "빈 문자열 반환"
      ],
      "correctAnswer": 0,
      "explanation": "void는 메서드가 값을 반환하지 않음을 나타냅니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 메서드 오버로딩을 합니다. 같은 이름의 메서드를 여러 개 만들 때 달라야 하는 것은?",
      "options": [
        "매개변수의 타입이나 개수",
        "반환 타입만",
        "메서드 이름",
        "접근 제어자"
      ],
      "correctAnswer": 0,
      "explanation": "메서드 오버로딩은 매개변수의 타입, 개수, 순서가 달라야 합니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 가변 인자를 사용합니다. public void print(String... messages) {} ...의 의미는?",
      "options": [
        "0개 이상의 String을 받을 수 있음",
        "정확히 3개의 String",
        "오류",
        "무한대"
      ],
      "correctAnswer": 0,
      "explanation": "...는 가변 인자로, 0개 이상의 인자를 배열처럼 받습니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 재귀 함수를 만듭니다. 재귀 함수에서 반드시 필요한 것은?",
      "options": [
        "종료 조건 (base case)",
        "반복문",
        "배열",
        "전역 변수"
      ],
      "correctAnswer": 0,
      "explanation": "재귀 함수는 무한 호출을 방지하기 위해 종료 조건이 필요합니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 배열을 생성합니다. int[] arr = new int[5]; 배열의 크기는?",
      "options": [
        "5",
        "4",
        "0",
        "가변"
      ],
      "correctAnswer": 0,
      "explanation": "new int[5]는 크기가 5인 정수 배열을 생성합니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 배열의 길이를 확인합니다. arr.length의 타입은?",
      "options": [
        "필드 (괄호 없음)",
        "메서드 (arr.length())",
        "변수",
        "상수"
      ],
      "correctAnswer": 0,
      "explanation": "배열의 length는 메서드가 아닌 public final 필드입니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 배열을 초기화합니다. int[] arr = {1, 2, 3}; arr[0]의 값은?",
      "options": [
        "1",
        "0",
        "2",
        "3"
      ],
      "correctAnswer": 0,
      "explanation": "배열의 인덱스는 0부터 시작하므로 arr[0]은 첫 번째 요소 1입니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 2차원 배열을 만듭니다. int[][] matrix = new int[3][4]; 총 요소 개수는?",
      "options": [
        "12",
        "7",
        "3",
        "4"
      ],
      "correctAnswer": 0,
      "explanation": "3행 4열의 2차원 배열이므로 3 × 4 = 12개의 요소가 있습니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 배열을 복사합니다. System.arraycopy()의 장점은?",
      "options": [
        "빠른 네이티브 메서드",
        "깊은 복사",
        "자동 정렬",
        "타입 변환"
      ],
      "correctAnswer": 0,
      "explanation": "System.arraycopy()는 네이티브 메서드로 빠르게 배열을 복사합니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 클래스를 정의합니다. class Person {} 클래스의 역할은?",
      "options": [
        "객체를 만들기 위한 설계도",
        "변수",
        "함수",
        "배열"
      ],
      "correctAnswer": 0,
      "explanation": "클래스는 객체를 생성하기 위한 설계도(템플릿)입니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 생성자를 만듭니다. 생성자의 특징은?",
      "options": [
        "클래스 이름과 같고 반환 타입이 없음",
        "반환 타입이 void",
        "static이어야 함",
        "private이어야 함"
      ],
      "correctAnswer": 0,
      "explanation": "생성자는 클래스 이름과 동일하고 반환 타입을 명시하지 않습니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 this 키워드를 사용합니다. this의 의미는?",
      "options": [
        "현재 객체 자신을 가리킴",
        "부모 클래스",
        "정적 메서드",
        "지역 변수"
      ],
      "correctAnswer": 0,
      "explanation": "this는 현재 객체(인스턴스) 자신을 참조합니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 static 필드를 만듭니다. static의 특징은?",
      "options": [
        "모든 인스턴스가 공유",
        "각 인스턴스마다 별도 생성",
        "final과 같음",
        "private만 가능"
      ],
      "correctAnswer": 0,
      "explanation": "static 멤버는 클래스 레벨로, 모든 인스턴스가 공유합니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 접근 제어자를 확인합니다. private 멤버에 접근 가능한 곳은?",
      "options": [
        "같은 클래스 내부만",
        "같은 패키지",
        "자식 클래스",
        "모든 곳"
      ],
      "correctAnswer": 0,
      "explanation": "private 멤버는 해당 클래스 내부에서만 접근 가능합니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 상속을 구현합니다. class Dog extends Animal {} Dog는?",
      "options": [
        "Animal의 자식 클래스",
        "Animal의 부모 클래스",
        "Animal과 무관",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "extends 키워드로 상속을 구현하며, Dog는 Animal의 자식(서브) 클래스입니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 메서드를 오버라이딩합니다. @Override 어노테이션의 역할은?",
      "options": [
        "오버라이딩이 올바른지 컴파일러가 확인",
        "필수 요구사항",
        "성능 향상",
        "접근 제어"
      ],
      "correctAnswer": 0,
      "explanation": "@Override는 선택 사항이지만, 오버라이딩이 올바른지 컴파일 시 확인해줍니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 super 키워드를 사용합니다. super()의 역할은?",
      "options": [
        "부모 클래스의 생성자 호출",
        "현재 객체 참조",
        "정적 메서드 호출",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "super()는 부모 클래스의 생성자를 명시적으로 호출합니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 final 클래스를 만듭니다. final class Utility {} 의미는?",
      "options": [
        "상속할 수 없음",
        "인스턴스화할 수 없음",
        "수정할 수 없음",
        "static만 가능"
      ],
      "correctAnswer": 0,
      "explanation": "final 클래스는 다른 클래스가 상속받을 수 없습니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 protected 멤버를 사용합니다. 접근 가능한 곳은?",
      "options": [
        "같은 패키지와 자식 클래스",
        "같은 클래스만",
        "모든 곳",
        "같은 패키지만"
      ],
      "correctAnswer": 0,
      "explanation": "protected는 같은 패키지와 다른 패키지의 자식 클래스에서 접근 가능합니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 인터페이스를 정의합니다. interface Drawable {} 인터페이스의 특징은?",
      "options": [
        "추상 메서드와 상수만 가질 수 있음 (Java 8 이전)",
        "생성자를 가질 수 있음",
        "인스턴스 변수를 가질 수 있음",
        "private 메서드만 가능"
      ],
      "correctAnswer": 0,
      "explanation": "인터페이스는 기본적으로 추상 메서드와 상수를 정의합니다 (Java 8 이후 default/static 메서드 추가)."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 인터페이스를 구현합니다. class Circle implements Drawable {} implements의 의미는?",
      "options": [
        "인터페이스의 메서드를 구현하겠다",
        "상속받는다",
        "확장한다",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "implements는 인터페이스를 구현함을 나타내며, 모든 추상 메서드를 구현해야 합니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 여러 인터페이스를 구현합니다. Java에서 가능한가요?",
      "options": [
        "가능 (다중 인터페이스 구현)",
        "불가능",
        "최대 2개만",
        "추상 클래스만 가능"
      ],
      "correctAnswer": 0,
      "explanation": "Java는 클래스의 다중 상속은 불가능하지만, 여러 인터페이스를 구현할 수 있습니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 default 메서드를 봅니다. interface에서 default 메서드의 특징은?",
      "options": [
        "구현부를 가질 수 있음 (Java 8+)",
        "추상 메서드",
        "static과 같음",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "Java 8부터 인터페이스에 default 키워드로 구현부를 가진 메서드를 추가할 수 있습니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 추상 클래스와 인터페이스를 비교합니다. 주요 차이점은?",
      "options": [
        "추상 클래스는 생성자와 인스턴스 변수를 가질 수 있음",
        "인터페이스가 생성자를 가짐",
        "차이가 없음",
        "추상 클래스는 메서드를 가질 수 없음"
      ],
      "correctAnswer": 0,
      "explanation": "추상 클래스는 생성자, 인스턴스 변수, 일반 메서드를 가질 수 있지만 인터페이스는 불가능합니다."
    }
  ]
}
