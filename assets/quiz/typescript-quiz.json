{
  "language": "typescript",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 TypeScript를 설치하려고 합니다. npm으로 전역 설치하는 명령어는?",
      "options": [
        "npm install -g typescript",
        "npm install typescript",
        "npm add typescript",
        "npm get typescript"
      ],
      "correctAnswer": 0,
      "explanation": "-g 플래그를 사용하면 TypeScript를 전역으로 설치할 수 있습니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 TypeScript 파일을 컴파일하려고 합니다. 사용할 명령어는?",
      "options": [
        "tsc filename.ts",
        "compile filename.ts",
        "ts filename.ts",
        "node filename.ts"
      ],
      "correctAnswer": 0,
      "explanation": "tsc(TypeScript Compiler)를 사용하여 .ts 파일을 .js 파일로 컴파일합니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 TypeScript 설정 파일을 생성하려고 합니다. 사용할 명령어는?",
      "options": [
        "tsc --init",
        "npm init",
        "ts init",
        "typescript init"
      ],
      "correctAnswer": 0,
      "explanation": "tsc --init 명령어는 tsconfig.json 설정 파일을 생성합니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 TypeScript와 JavaScript의 차이를 설명합니다. 가장 큰 차이점은?",
      "options": [
        "TypeScript는 정적 타입을 지원한다",
        "TypeScript가 더 빠르다",
        "JavaScript는 브라우저에서 실행할 수 없다",
        "TypeScript는 함수를 지원하지 않는다"
      ],
      "correctAnswer": 0,
      "explanation": "TypeScript의 가장 큰 특징은 정적 타입 시스템입니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 TypeScript 파일 확장자를 확인합니다. 올바른 확장자는?",
      "options": [
        ".ts",
        ".typescript",
        ".tsc",
        ".type"
      ],
      "correctAnswer": 0,
      "explanation": "TypeScript 파일의 확장자는 .ts입니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 문자열 타입을 지정합니다. let name: string = 'Badebu'; 여기서 string의 역할은?",
      "options": [
        "타입 어노테이션으로 변수의 타입을 지정",
        "변수 이름",
        "값",
        "함수"
      ],
      "correctAnswer": 0,
      "explanation": ": string은 타입 어노테이션으로 변수가 문자열 타입임을 명시합니다."
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 타입을 지정하지 않고 변수를 선언합니다. let x = 10; x의 타입은?",
      "options": [
        "number (타입 추론)",
        "any",
        "unknown",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "TypeScript는 초기값을 보고 자동으로 타입을 추론합니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 배열 타입을 선언합니다. number[]와 Array<number>의 차이는?",
      "options": [
        "차이 없음, 둘 다 숫자 배열",
        "number[]가 더 빠름",
        "Array<number>는 오류",
        "number[]는 읽기 전용"
      ],
      "correctAnswer": 0,
      "explanation": "number[]와 Array<number>는 같은 의미로 숫자 배열을 나타냅니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 튜플을 사용합니다. let tuple: [string, number] = ['age', 25]; 튜플의 특징은?",
      "options": [
        "고정된 길이와 각 위치의 타입이 정해진 배열",
        "무한 길이의 배열",
        "객체",
        "문자열"
      ],
      "correctAnswer": 0,
      "explanation": "튜플은 길이와 각 요소의 타입이 고정된 배열입니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 어떤 타입이든 허용하려고 합니다. 사용할 타입은?",
      "options": [
        "any",
        "all",
        "everything",
        "dynamic"
      ],
      "correctAnswer": 0,
      "explanation": "any 타입은 모든 타입의 값을 허용합니다 (타입 검사 비활성화)."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 인터페이스를 정의합니다. interface User { name: string; } 인터페이스의 역할은?",
      "options": [
        "객체의 구조(타입)를 정의",
        "클래스를 생성",
        "함수를 정의",
        "변수를 선언"
      ],
      "correctAnswer": 0,
      "explanation": "인터페이스는 객체가 가져야 할 프로퍼티와 타입을 정의합니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 선택적 프로퍼티를 만듭니다. age?: number; 물음표(?)의 의미는?",
      "options": [
        "이 프로퍼티는 있어도 되고 없어도 됨",
        "타입을 모름",
        "오류 표시",
        "주석"
      ],
      "correctAnswer": 0,
      "explanation": "?는 선택적 프로퍼티를 나타내며, 해당 프로퍼티가 없어도 됩니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 읽기 전용 프로퍼티를 만듭니다. readonly id: number; 의미는?",
      "options": [
        "id는 초기화 후 변경할 수 없음",
        "id를 읽을 수만 있음",
        "id는 선택적임",
        "id는 숫자가 아님"
      ],
      "correctAnswer": 0,
      "explanation": "readonly 키워드는 프로퍼티를 읽기 전용으로 만들어 재할당을 방지합니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 인터페이스를 확장합니다. interface Admin extends User {} extends의 의미는?",
      "options": [
        "Admin이 User의 모든 프로퍼티를 상속받음",
        "User가 Admin을 상속받음",
        "둘이 같아짐",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "extends를 사용하면 기존 인터페이스를 확장하여 새 인터페이스를 만들 수 있습니다."
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 인덱스 시그니처를 사용합니다. [key: string]: any; 의미는?",
      "options": [
        "문자열 키로 어떤 프로퍼티든 추가 가능",
        "key라는 프로퍼티만 가능",
        "오류 코드",
        "배열을 의미"
      ],
      "correctAnswer": 0,
      "explanation": "인덱스 시그니처는 동적으로 프로퍼티를 추가할 수 있게 합니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 함수의 매개변수 타입을 지정합니다. function greet(name: string) {} name의 타입은?",
      "options": [
        "string",
        "any",
        "number",
        "void"
      ],
      "correctAnswer": 0,
      "explanation": "매개변수 뒤에 : 타입을 붙여서 매개변수의 타입을 지정합니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 함수의 반환 타입을 지정합니다. function add(a: number, b: number): number {} 반환 타입은?",
      "options": [
        "number",
        "string",
        "void",
        "any"
      ],
      "correctAnswer": 0,
      "explanation": "괄호 뒤의 : number는 함수가 숫자를 반환함을 나타냅니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 반환값이 없는 함수를 만듭니다. 반환 타입으로 사용할 것은?",
      "options": [
        "void",
        "null",
        "undefined",
        "none"
      ],
      "correctAnswer": 0,
      "explanation": "void는 함수가 값을 반환하지 않음을 나타냅니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 선택적 매개변수를 만듭니다. function log(message: string, userId?: number) {} userId의 특징은?",
      "options": [
        "전달하지 않아도 됨",
        "반드시 전달해야 함",
        "항상 undefined",
        "항상 null"
      ],
      "correctAnswer": 0,
      "explanation": "?가 붙은 매개변수는 선택적이므로 전달하지 않아도 됩니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 화살표 함수의 타입을 정의합니다. const add: (a: number, b: number) => number; 이것은?",
      "options": [
        "함수 타입 정의",
        "함수 실행",
        "오류 코드",
        "변수 선언"
      ],
      "correctAnswer": 0,
      "explanation": "이것은 두 숫자를 받아 숫자를 반환하는 함수의 타입을 정의합니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 클래스를 정의합니다. class Person { name: string; } 클래스의 프로퍼티 접근 제어자 기본값은?",
      "options": [
        "public",
        "private",
        "protected",
        "readonly"
      ],
      "correctAnswer": 0,
      "explanation": "명시하지 않으면 클래스 멤버는 기본적으로 public입니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 private 프로퍼티를 만듭니다. private password: string; 접근 가능한 곳은?",
      "options": [
        "클래스 내부에서만",
        "어디서든",
        "자식 클래스에서만",
        "같은 파일에서만"
      ],
      "correctAnswer": 0,
      "explanation": "private 멤버는 해당 클래스 내부에서만 접근 가능합니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 protected 프로퍼티를 사용합니다. 접근 가능한 곳은?",
      "options": [
        "클래스 내부와 자식 클래스",
        "클래스 내부만",
        "어디서든",
        "같은 파일만"
      ],
      "correctAnswer": 0,
      "explanation": "protected 멤버는 클래스 내부와 상속받은 자식 클래스에서 접근 가능합니다."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 생성자를 간단히 작성합니다. constructor(public name: string) {} 이것의 효과는?",
      "options": [
        "name 프로퍼티를 자동으로 선언하고 초기화",
        "오류 발생",
        "name을 매개변수로만 사용",
        "name을 private으로 만듦"
      ],
      "correctAnswer": 0,
      "explanation": "생성자 매개변수에 접근 제어자를 붙이면 자동으로 프로퍼티가 선언되고 초기화됩니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 추상 클래스를 만듭니다. abstract class Animal {} 추상 클래스의 특징은?",
      "options": [
        "직접 인스턴스화할 수 없음",
        "메서드를 가질 수 없음",
        "상속할 수 없음",
        "프로퍼티를 가질 수 없음"
      ],
      "correctAnswer": 0,
      "explanation": "추상 클래스는 직접 new로 생성할 수 없고, 상속받아서 사용해야 합니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 제네릭 함수를 만듭니다. function identity<T>(arg: T): T {} <T>의 의미는?",
      "options": [
        "타입 매개변수로, 호출 시 타입을 지정",
        "T라는 변수",
        "템플릿",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "<T>는 제네릭 타입 매개변수로, 함수 호출 시 구체적인 타입을 지정할 수 있습니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 제네릭 인터페이스를 만듭니다. interface Box<T> { value: T; } Box<number>의 의미는?",
      "options": [
        "value가 number 타입인 Box",
        "오류",
        "Box가 number 타입",
        "T가 문자열"
      ],
      "correctAnswer": 0,
      "explanation": "제네릭 인터페이스를 사용할 때 <> 안에 구체적인 타입을 지정합니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 제네릭 제약을 추가합니다. function log<T extends { name: string }>(obj: T) {} extends의 의미는?",
      "options": [
        "T는 name 프로퍼티를 가진 타입이어야 함",
        "T가 상속받음",
        "오류",
        "T는 문자열"
      ],
      "correctAnswer": 0,
      "explanation": "extends는 제네릭 타입에 제약을 추가하여 특정 조건을 만족하는 타입만 허용합니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 제네릭 클래스를 만듭니다. class Queue<T> {} new Queue<string>()의 의미는?",
      "options": [
        "문자열을 다루는 Queue 인스턴스 생성",
        "오류",
        "Queue가 문자열",
        "T가 숫자"
      ],
      "correctAnswer": 0,
      "explanation": "제네릭 클래스를 인스턴스화할 때 <> 안에 구체적인 타입을 지정합니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 keyof를 사용합니다. keyof { name: string, age: number }의 결과 타입은?",
      "options": [
        "'name' | 'age'",
        "string",
        "number",
        "object"
      ],
      "correctAnswer": 0,
      "explanation": "keyof는 객체 타입의 모든 키를 유니온 타입으로 반환합니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 유니온 타입을 만듭니다. let value: string | number; value에 할당 가능한 값은?",
      "options": [
        "문자열 또는 숫자",
        "문자열만",
        "숫자만",
        "불리언"
      ],
      "correctAnswer": 0,
      "explanation": "| (파이프)는 여러 타입 중 하나가 될 수 있음을 나타냅니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 인터섹션 타입을 만듭니다. type AB = A & B; AB의 의미는?",
      "options": [
        "A와 B의 모든 프로퍼티를 가짐",
        "A 또는 B",
        "A만 가짐",
        "B만 가짐"
      ],
      "correctAnswer": 0,
      "explanation": "& (앰퍼샌드)는 여러 타입을 모두 만족하는 타입을 만듭니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 타입 별칭을 만듭니다. type ID = string | number; type의 역할은?",
      "options": [
        "타입에 이름을 붙임",
        "변수를 선언",
        "함수를 정의",
        "클래스를 생성"
      ],
      "correctAnswer": 0,
      "explanation": "type 키워드는 타입에 별칭을 붙여서 재사용할 수 있게 합니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 리터럴 타입을 사용합니다. let direction: 'up' | 'down'; direction의 가능한 값은?",
      "options": [
        "'up' 또는 'down'만",
        "모든 문자열",
        "'left', 'right'도 가능",
        "숫자"
      ],
      "correctAnswer": 0,
      "explanation": "리터럴 타입은 정확히 그 값만 허용합니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 타입 가드를 사용합니다. typeof x === 'string'을 확인한 후 x를 사용하면?",
      "options": [
        "x를 string으로 안전하게 사용 가능",
        "오류 발생",
        "타입이 변하지 않음",
        "x가 숫자가 됨"
      ],
      "correctAnswer": 0,
      "explanation": "타입 가드를 통해 TypeScript가 해당 블록에서 타입을 좁혀줍니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 모듈을 내보냅니다. export function greet() {} 이 함수를 다른 파일에서 사용하려면?",
      "options": [
        "import { greet } from './file';",
        "include 'file';",
        "require('./file');",
        "use './file';"
      ],
      "correctAnswer": 0,
      "explanation": "export된 항목은 import로 가져올 수 있습니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 기본 내보내기를 사용합니다. export default class User {} 가져오는 방법은?",
      "options": [
        "import User from './file';",
        "import { User } from './file';",
        "import * as User from './file';",
        "require User from './file';"
      ],
      "correctAnswer": 0,
      "explanation": "default export는 중괄호 없이 import합니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 모든 내보내기를 가져옵니다. import * as Utils from './utils'; Utils.add()로 접근하는 것은?",
      "options": [
        "utils 모듈의 add 함수",
        "오류",
        "전역 add 함수",
        "Utils 클래스의 메서드"
      ],
      "correctAnswer": 0,
      "explanation": "* as는 모든 export를 하나의 객체로 가져옵니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 네임스페이스를 만듭니다. namespace Math {} namespace의 용도는?",
      "options": [
        "코드를 논리적으로 그룹화",
        "함수를 정의",
        "변수를 선언",
        "타입을 만듦"
      ],
      "correctAnswer": 0,
      "explanation": "namespace는 관련된 코드를 그룹화하는 TypeScript의 기능입니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 타입만 가져옵니다. import type { User } from './types'; type 키워드의 의미는?",
      "options": [
        "타입 정보만 가져오고 런타임 코드는 제거됨",
        "일반 import와 같음",
        "오류",
        "User를 타입으로 변환"
      ],
      "correctAnswer": 0,
      "explanation": "import type은 타입 정보만 가져오며, 컴파일 후 제거됩니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 Partial을 사용합니다. Partial<User>의 의미는?",
      "options": [
        "User의 모든 프로퍼티를 선택적으로 만듦",
        "User의 일부만 선택",
        "오류",
        "User를 삭제"
      ],
      "correctAnswer": 0,
      "explanation": "Partial<T>는 모든 프로퍼티를 선택적(optional)으로 만듭니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 Required를 사용합니다. Required<User>의 의미는?",
      "options": [
        "User의 모든 프로퍼티를 필수로 만듦",
        "User를 생성",
        "오류",
        "User를 삭제"
      ],
      "correctAnswer": 0,
      "explanation": "Required<T>는 모든 선택적 프로퍼티를 필수로 만듭니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 Readonly를 사용합니다. Readonly<User>의 의미는?",
      "options": [
        "User의 모든 프로퍼티를 읽기 전용으로 만듦",
        "User를 읽을 수만 있음",
        "오류",
        "User가 상수가 됨"
      ],
      "correctAnswer": 0,
      "explanation": "Readonly<T>는 모든 프로퍼티를 읽기 전용으로 만듭니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 Pick을 사용합니다. Pick<User, 'name' | 'age'>의 의미는?",
      "options": [
        "User에서 name과 age만 선택한 타입",
        "User 전체",
        "오류",
        "name과 age를 제외한 타입"
      ],
      "correctAnswer": 0,
      "explanation": "Pick<T, K>는 T에서 K에 해당하는 프로퍼티만 선택합니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 Omit을 사용합니다. Omit<User, 'password'>의 의미는?",
      "options": [
        "User에서 password를 제외한 타입",
        "password만 있는 타입",
        "오류",
        "User 전체"
      ],
      "correctAnswer": 0,
      "explanation": "Omit<T, K>는 T에서 K를 제외한 타입을 만듭니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 데코레이터를 사용합니다. @Component class MyClass {} @의 의미는?",
      "options": [
        "데코레이터로 클래스에 메타데이터 추가",
        "주석",
        "어노테이션",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "데코레이터는 @ 기호로 시작하며 클래스, 메서드 등에 메타데이터를 추가합니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 타입 단언을 사용합니다. let value = someValue as string; as의 역할은?",
      "options": [
        "TypeScript에게 타입을 알려줌",
        "타입을 변환",
        "오류",
        "타입 검사"
      ],
      "correctAnswer": 0,
      "explanation": "as는 타입 단언으로, 개발자가 타입을 더 잘 알 때 TypeScript에게 알려줍니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 non-null 단언을 사용합니다. value!.toString(); 느낌표의 의미는?",
      "options": [
        "value가 null이나 undefined가 아님을 보장",
        "부정",
        "오류",
        "중요 표시"
      ],
      "correctAnswer": 0,
      "explanation": "! 연산자는 null이나 undefined가 아님을 TypeScript에게 알립니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 never 타입을 봅니다. never 타입은 언제 사용되나요?",
      "options": [
        "절대 발생하지 않는 값의 타입",
        "모든 값",
        "null만",
        "undefined만"
      ],
      "correctAnswer": 0,
      "explanation": "never는 절대 발생할 수 없는 타입으로, 항상 오류를 던지는 함수 등에 사용됩니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 tsconfig.json에서 strict: true를 설정합니다. 효과는?",
      "options": [
        "모든 엄격한 타입 검사 옵션을 활성화",
        "컴파일 속도 향상",
        "타입 검사 비활성화",
        "오류 무시"
      ],
      "correctAnswer": 0,
      "explanation": "strict 모드는 모든 엄격한 타입 검사 옵션을 한 번에 활성화합니다."
    }
  ]
}
