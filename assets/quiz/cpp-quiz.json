{
  "language": "cpp",
  "questions": [
    {"id": 1, "chapter": 1, "question": "바데부가 C++ 프로그램을 작성합니다. 올바른 main 함수는?", "options": ["int main()", "void main()", "main()", "public static void main()"], "correctAnswer": 0, "explanation": "C++에서 main 함수는 int main() 형태입니다."},
    {"id": 2, "chapter": 1, "question": "바데부가 콘솔에 출력하려고 합니다. 사용할 객체는?", "options": ["std::cout", "printf()", "print()", "console.log()"], "correctAnswer": 0, "explanation": "C++에서는 iostream의 std::cout을 사용합니다."},
    {"id": 3, "chapter": 1, "question": "바데부가 네임스페이스를 사용합니다. using namespace std; 의 효과는?", "options": ["std:: 접두사 생략 가능", "성능 향상", "필수", "오류"], "correctAnswer": 0, "explanation": "using namespace std를 사용하면 std:: 접두사를 생략할 수 있습니다."},
    {"id": 4, "chapter": 1, "question": "바데부가 입력을 받습니다. cin >> x; 의 역할은?", "options": ["표준 입력에서 값을 읽어 x에 저장", "x 출력", "x 선언", "x 삭제"], "correctAnswer": 0, "explanation": "cin은 표준 입력 스트림으로 사용자 입력을 받습니다."},
    {"id": 5, "chapter": 1, "question": "바데부가 주석을 작성합니다. C++의 한 줄 주석은?", "options": ["// 주석", "# 주석", "/* 주석 */", "' 주석"], "correctAnswer": 0, "explanation": "//는 한 줄 주석입니다."},
    {"id": 6, "chapter": 2, "question": "바데부가 참조자를 선언합니다. int& ref = x; ref의 특징은?", "options": ["x의 별칭으로 같은 메모리 공유", "x의 복사본", "x의 포인터", "새 변수"], "correctAnswer": 0, "explanation": "참조자는 기존 변수의 별칭입니다."},
    {"id": 7, "chapter": 2, "question": "바데부가 auto를 사용합니다. auto x = 10; x의 타입은?", "options": ["int (타입 추론)", "auto", "var", "any"], "correctAnswer": 0, "explanation": "auto는 초기값을 보고 자동으로 타입을 추론합니다."},
    {"id": 8, "chapter": 2, "question": "바데부가 const를 사용합니다. const int x = 10; 의 의미는?", "options": ["x는 상수로 변경 불가", "x는 변수", "x는 포인터", "x는 참조자"], "correctAnswer": 0, "explanation": "const는 값을 변경할 수 없는 상수를 선언합니다."},
    {"id": 9, "chapter": 2, "question": "바데부가 bool 타입을 사용합니다. bool의 값은?", "options": ["true 또는 false", "0 또는 1만", "문자열", "숫자"], "correctAnswer": 0, "explanation": "bool 타입은 true 또는 false 값을 가집니다."},
    {"id": 10, "chapter": 2, "question": "바데부가 문자열을 다룹니다. std::string과 char[]의 차이는?", "options": ["string은 클래스로 더 편리한 기능 제공", "char[]가 더 좋음", "차이 없음", "string은 사용 불가"], "correctAnswer": 0, "explanation": "std::string은 C++ 표준 라이브러리의 문자열 클래스입니다."},
    {"id": 11, "chapter": 3, "question": "바데부가 범위 기반 for문을 사용합니다. for (auto x : vec) {} 의 역할은?", "options": ["컨테이너의 모든 요소 순회", "인덱스 접근", "역순 순회", "오류"], "correctAnswer": 0, "explanation": "범위 기반 for문은 컨테이너의 모든 요소를 순회합니다."},
    {"id": 12, "chapter": 3, "question": "바데부가 람다를 사용합니다. auto f = [] (int x) { return x * 2; }; []의 의미는?", "options": ["캡처 목록 (외부 변수 접근)", "배열", "템플릿", "주석"], "correctAnswer": 0, "explanation": "람다 표현식의 []는 외부 변수를 캡처하는 목록입니다."},
    {"id": 13, "chapter": 3, "question": "바데부가 삼항 연산자를 사용합니다. int max = (a > b) ? a : b; 의 의미는?", "options": ["a가 b보다 크면 a, 아니면 b", "a와 b를 더함", "a가 b와 같은지 확인", "오류"], "correctAnswer": 0, "explanation": "삼항 연산자는 조건 ? 참 : 거짓 형태입니다."},
    {"id": 14, "chapter": 3, "question": "바데부가 nullptr을 사용합니다. NULL과의 차이는?", "options": ["nullptr은 타입 안전한 널 포인터", "NULL이 더 좋음", "차이 없음", "nullptr은 오류"], "correctAnswer": 0, "explanation": "nullptr은 C++11부터 추가된 타입 안전한 널 포인터 상수입니다."},
    {"id": 15, "chapter": 3, "question": "바데부가 비트 시프트를 합니다. 8 >> 1의 결과는?", "options": ["4", "16", "8", "2"], "correctAnswer": 0, "explanation": "오른쪽 시프트(>>)는 비트를 오른쪽으로 이동. 8(1000) >> 1 = 4(100)"},
    {"id": 16, "chapter": 4, "question": "바데부가 switch문을 작성합니다. C++17의 초기화 구문은?", "options": ["switch (int x = getValue(); x) {}", "switch (x) {}", "switch x {}", "switch: x"], "correctAnswer": 0, "explanation": "C++17부터 switch문에서 초기화 구문을 사용할 수 있습니다."},
    {"id": 17, "chapter": 4, "question": "바데부가 if constexpr을 사용합니다. 일반 if와의 차이는?", "options": ["컴파일 타임에 평가", "런타임에 평가", "차이 없음", "오류"], "correctAnswer": 0, "explanation": "if constexpr은 컴파일 타임에 조건을 평가합니다."},
    {"id": 18, "chapter": 4, "question": "바데부가 조건부 연산자를 체인합니다. a > b ? a : b > c ? b : c; 이것은?", "options": ["a, b, c 중 최댓값", "a와 b 비교만", "오류", "c 반환"], "correctAnswer": 0, "explanation": "중첩된 삼항 연산자로 세 값 중 최댓값을 구합니다."},
    {"id": 19, "chapter": 4, "question": "바데부가 short-circuit을 확인합니다. false && expensive() 에서 expensive()는?", "options": ["호출되지 않음", "항상 호출", "조건부 호출", "오류"], "correctAnswer": 0, "explanation": "&&는 첫 번째가 false면 두 번째를 평가하지 않습니다."},
    {"id": 20, "chapter": 4, "question": "바데부가 조건을 확인합니다. if (ptr) {} 의 의미는?", "options": ["ptr이 nullptr이 아닌지 확인", "ptr이 1인지 확인", "오류", "ptr 출력"], "correctAnswer": 0, "explanation": "포인터를 조건문에 사용하면 nullptr 여부를 확인합니다."},
    {"id": 21, "chapter": 5, "question": "바데부가 반복문을 작성합니다. for (;;) {} 의 의미는?", "options": ["무한 반복", "오류", "한 번 실행", "실행 안 됨"], "correctAnswer": 0, "explanation": "for (;;)는 조건이 없어 무한 반복됩니다."},
    {"id": 22, "chapter": 5, "question": "바데부가 벡터를 순회합니다. for (auto& x : vec) {} &의 역할은?", "options": ["참조로 받아 원본 수정 가능", "포인터", "복사", "주소 출력"], "correctAnswer": 0, "explanation": "&는 참조로 받아서 원본을 직접 수정할 수 있습니다."},
    {"id": 23, "chapter": 5, "question": "바데부가 반복자를 사용합니다. vec.begin()의 역할은?", "options": ["첫 번째 요소를 가리키는 반복자", "마지막 요소", "크기", "삭제"], "correctAnswer": 0, "explanation": "begin()은 컨테이너의 첫 번째 요소를 가리키는 반복자를 반환합니다."},
    {"id": 24, "chapter": 5, "question": "바데부가 continue를 사용합니다. 중첩 반복문에서 continue는?", "options": ["가장 가까운 반복문의 다음 반복으로", "모든 반복문 종료", "프로그램 종료", "외부 반복문으로"], "correctAnswer": 0, "explanation": "continue는 가장 가까운 반복문의 현재 반복만 건너뜁니다."},
    {"id": 25, "chapter": 5, "question": "바데부가 역순 순회를 합니다. rbegin()과 rend()의 역할은?", "options": ["역방향 반복자 제공", "정방향 반복자", "크기", "삭제"], "correctAnswer": 0, "explanation": "rbegin()과 rend()는 역방향 순회를 위한 반복자를 제공합니다."},
    {"id": 26, "chapter": 6, "question": "바데부가 함수 오버로딩을 합니다. void func(int)와 void func(double)은?", "options": ["매개변수 타입이 다른 오버로딩", "오류", "같은 함수", "재정의"], "correctAnswer": 0, "explanation": "매개변수 타입이 다르면 같은 이름으로 여러 함수를 정의할 수 있습니다."},
    {"id": 27, "chapter": 6, "question": "바데부가 인라인 함수를 만듭니다. inline의 효과는?", "options": ["함수 호출 오버헤드 감소 (힌트)", "필수 인라인", "더 느림", "오류"], "correctAnswer": 0, "explanation": "inline은 컴파일러에게 함수를 호출 위치에 삽입하라는 힌트입니다."},
    {"id": 28, "chapter": 6, "question": "바데부가 기본 인자를 사용합니다. void func(int x = 10) {} func()를 호출하면?", "options": ["x는 10", "오류", "x는 0", "x는 null"], "correctAnswer": 0, "explanation": "인자를 전달하지 않으면 기본값 10이 사용됩니다."},
    {"id": 29, "chapter": 6, "question": "바데부가 constexpr 함수를 만듭니다. constexpr의 의미는?", "options": ["컴파일 타임에 평가 가능", "런타임만", "상수만 반환", "오류"], "correctAnswer": 0, "explanation": "constexpr 함수는 컴파일 타임에 평가될 수 있습니다."},
    {"id": 30, "chapter": 6, "question": "바데부가 함수 포인터를 사용합니다. void (*ptr)(int); 의 의미는?", "options": ["int를 받고 void를 반환하는 함수 포인터", "배열", "변수", "오류"], "correctAnswer": 0, "explanation": "함수 포인터는 함수의 주소를 저장합니다."},
    {"id": 31, "chapter": 7, "question": "바데부가 배열을 선언합니다. std::array<int, 5> arr; 장점은?", "options": ["크기를 알고 있고 STL 알고리즘 사용 가능", "C 배열과 같음", "느림", "크기 변경 가능"], "correctAnswer": 0, "explanation": "std::array는 고정 크기 배열이지만 STL 컨테이너의 기능을 제공합니다."},
    {"id": 32, "chapter": 7, "question": "바데부가 벡터를 사용합니다. vector<int> vec; 특징은?", "options": ["동적 크기 조정 가능", "고정 크기", "느림", "사용 불가"], "correctAnswer": 0, "explanation": "vector는 크기가 자동으로 조정되는 동적 배열입니다."},
    {"id": 33, "chapter": 7, "question": "바데부가 벡터에 추가합니다. vec.push_back(10); 의 역할은?", "options": ["벡터 끝에 10 추가", "벡터 앞에 추가", "10번째에 추가", "삭제"], "correctAnswer": 0, "explanation": "push_back()은 벡터의 끝에 요소를 추가합니다."},
    {"id": 34, "chapter": 7, "question": "바데부가 벡터 크기를 확인합니다. vec.size()와 vec.capacity()의 차이는?", "options": ["size는 요소 개수, capacity는 할당된 공간", "같음", "size가 더 큼", "오류"], "correctAnswer": 0, "explanation": "size는 실제 요소 개수, capacity는 재할당 없이 저장 가능한 요소 개수입니다."},
    {"id": 35, "chapter": 7, "question": "바데부가 2차원 벡터를 만듭니다. vector<vector<int>> matrix; 접근 방법은?", "options": ["matrix[i][j]", "matrix(i, j)", "matrix.at(i, j)", "matrix[i, j]"], "correctAnswer": 0, "explanation": "2차원 벡터는 이중 인덱스로 접근합니다."},
    {"id": 36, "chapter": 8, "question": "바데부가 클래스를 정의합니다. class Person {}; struct와의 차이는?", "options": ["class는 기본 private, struct는 public", "완전히 다름", "차이 없음", "class만 메서드 가능"], "correctAnswer": 0, "explanation": "class는 기본 접근 제어자가 private, struct는 public입니다."},
    {"id": 37, "chapter": 8, "question": "바데부가 생성자를 만듭니다. Person() : name(\"\"), age(0) {} 콜론(:)의 의미는?", "options": ["초기화 리스트", "상속", "주석", "오류"], "correctAnswer": 0, "explanation": "초기화 리스트는 멤버 변수를 효율적으로 초기화합니다."},
    {"id": 38, "chapter": 8, "question": "바데부가 소멸자를 정의합니다. ~Person() {} 소멸자의 역할은?", "options": ["객체 소멸 시 자동 호출되어 리소스 정리", "객체 생성", "복사", "이동"], "correctAnswer": 0, "explanation": "소멸자는 객체가 소멸될 때 자동으로 호출됩니다."},
    {"id": 39, "chapter": 8, "question": "바데부가 this 포인터를 사용합니다. this의 타입은?", "options": ["현재 객체의 포인터", "정수", "참조", "배열"], "correctAnswer": 0, "explanation": "this는 현재 객체 자신을 가리키는 포인터입니다."},
    {"id": 40, "chapter": 8, "question": "바데부가 정적 멤버를 만듭니다. static int count; 특징은?", "options": ["모든 객체가 공유", "각 객체마다 별도", "상수", "사용 불가"], "correctAnswer": 0, "explanation": "static 멤버는 클래스의 모든 객체가 공유합니다."},
    {"id": 41, "chapter": 9, "question": "바데부가 상속을 구현합니다. class Dog : public Animal {} public의 의미는?", "options": ["public 상속으로 부모의 접근 제어 유지", "private 상속", "protected 상속", "오류"], "correctAnswer": 0, "explanation": "public 상속은 부모 클래스의 접근 제어자를 그대로 유지합니다."},
    {"id": 42, "chapter": 9, "question": "바데부가 가상 함수를 만듭니다. virtual void func() {} virtual의 역할은?", "options": ["동적 바인딩 가능 (다형성)", "정적 바인딩", "인라인", "오류"], "correctAnswer": 0, "explanation": "virtual 키워드는 런타임에 올바른 함수가 호출되도록 합니다."},
    {"id": 43, "chapter": 9, "question": "바데부가 순수 가상 함수를 만듭니다. virtual void func() = 0; 의미는?", "options": ["추상 클래스로 만듦, 자식이 구현 필수", "일반 함수", "삭제", "오류"], "correctAnswer": 0, "explanation": "순수 가상 함수는 자식 클래스에서 반드시 구현해야 합니다."},
    {"id": 44, "chapter": 9, "question": "바데부가 override를 사용합니다. void func() override {} 의 역할은?", "options": ["오버라이딩 여부를 컴파일러가 확인", "새 함수 정의", "삭제", "인라인"], "correctAnswer": 0, "explanation": "override 키워드는 올바르게 오버라이딩했는지 컴파일러가 확인합니다."},
    {"id": 45, "chapter": 9, "question": "바데부가 final을 사용합니다. class Base final {} 의 의미는?", "options": ["상속 불가", "수정 불가", "삭제", "인스턴스화 불가"], "correctAnswer": 0, "explanation": "final 클래스는 다른 클래스가 상속받을 수 없습니다."},
    {"id": 46, "chapter": 10, "question": "바데부가 템플릿을 만듭니다. template<typename T> T max(T a, T b) {} 의 역할은?", "options": ["여러 타입에 대해 같은 로직 사용", "T 타입만 가능", "오류", "매크로"], "correctAnswer": 0, "explanation": "템플릿은 타입에 독립적인 코드를 작성할 수 있게 합니다."},
    {"id": 47, "chapter": 10, "question": "바데부가 클래스 템플릿을 만듭니다. template<class T> class Stack {} class와 typename의 차이는?", "options": ["차이 없음, 둘 다 사용 가능", "class만 가능", "typename만 가능", "완전히 다름"], "correctAnswer": 0, "explanation": "템플릿에서 class와 typename은 같은 의미로 사용됩니다."},
    {"id": 48, "chapter": 10, "question": "바데부가 템플릿 특수화를 합니다. template<> class Stack<char> {} 의 의미는?", "options": ["char 타입에 대한 특별한 구현", "오류", "일반 템플릿", "삭제"], "correctAnswer": 0, "explanation": "템플릿 특수화는 특정 타입에 대한 별도 구현을 제공합니다."},
    {"id": 49, "chapter": 10, "question": "바데부가 스마트 포인터를 사용합니다. unique_ptr의 특징은?", "options": ["단독 소유권, 복사 불가", "공유 소유권", "복사 가능", "일반 포인터와 같음"], "correctAnswer": 0, "explanation": "unique_ptr은 한 번에 하나의 소유자만 가질 수 있습니다."},
    {"id": 50, "chapter": 10, "question": "바데부가 이동 시맨틱을 사용합니다. std::move()의 역할은?", "options": ["lvalue를 rvalue로 캐스팅", "복사", "삭제", "교환"], "correctAnswer": 0, "explanation": "std::move()는 이동 연산을 수행하기 위해 lvalue를 rvalue 참조로 변환합니다."}
  ]
}
