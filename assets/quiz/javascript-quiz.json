{
  "language": "javascript",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 JavaScript로 콘솔에 메시지를 출력하려고 합니다. 올바른 코드는?",
      "options": [
        "console.log('Hello');",
        "print('Hello');",
        "System.out.println('Hello');",
        "echo 'Hello';"
      ],
      "correctAnswer": 0,
      "explanation": "JavaScript에서는 console.log()를 사용하여 콘솔에 출력합니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 JavaScript에서 한 줄 주석을 작성하려고 합니다. 올바른 방법은?",
      "options": [
        "// 이것은 주석입니다",
        "# 이것은 주석입니다",
        "<!-- 이것은 주석입니다 -->",
        "/* 이것은 주석입니다 */"
      ],
      "correctAnswer": 0,
      "explanation": "JavaScript에서 한 줄 주석은 //로 시작합니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 여러 줄 주석을 작성하려고 합니다. 올바른 방법은?",
      "options": [
        "/* 여러 줄\n주석 */",
        "// 여러 줄\n// 주석",
        "<!-- 여러 줄\n주석 -->",
        "''' 여러 줄\n주석 '''"
      ],
      "correctAnswer": 0,
      "explanation": "JavaScript에서 여러 줄 주석은 /* */로 감쌉니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 console.log()로 여러 값을 출력하려고 합니다. 올바른 방법은?",
      "options": [
        "console.log('이름:', name, '나이:', age);",
        "console.log('이름:' + name + '나이:' + age);",
        "console.log(`이름: ${name} 나이: ${age}`);",
        "위 모두 가능"
      ],
      "correctAnswer": 3,
      "explanation": "JavaScript에서는 쉼표, +연산자, 템플릿 리터럴 모두 사용 가능합니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 브라우저에서 경고창을 띄우려고 합니다. 사용할 함수는?",
      "options": [
        "alert('메시지');",
        "console.log('메시지');",
        "print('메시지');",
        "show('메시지');"
      ],
      "correctAnswer": 0,
      "explanation": "브라우저에서 경고창을 띄우려면 alert() 함수를 사용합니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 변수를 선언하려고 합니다. 재할당이 가능한 변수를 선언하는 키워드는?",
      "options": [
        "let",
        "const",
        "var",
        "let과 var 모두"
      ],
      "correctAnswer": 3,
      "explanation": "let과 var 모두 재할당이 가능하지만, let이 권장됩니다."
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 상수를 선언하려고 합니다. 올바른 키워드는?",
      "options": [
        "const",
        "let",
        "var",
        "final"
      ],
      "correctAnswer": 0,
      "explanation": "const는 재할당이 불가능한 상수를 선언합니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 작성한 코드에서 오류가 발생합니다. 이유는? const x = 10; x = 20;",
      "options": [
        "const로 선언된 변수는 재할당할 수 없다",
        "x가 선언되지 않았다",
        "숫자를 할당할 수 없다",
        "세미콜론이 없다"
      ],
      "correctAnswer": 0,
      "explanation": "const로 선언된 변수는 재할당이 불가능합니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 여러 변수를 한 번에 선언하려고 합니다. 올바른 방법은?",
      "options": [
        "let a = 1, b = 2, c = 3;",
        "let a, b, c = 1, 2, 3;",
        "let a = 1; b = 2; c = 3;",
        "let (a, b, c) = (1, 2, 3);"
      ],
      "correctAnswer": 0,
      "explanation": "쉼표로 구분하여 여러 변수를 선언할 수 있습니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 변수 이름을 정하려고 합니다. 올바르지 않은 변수명은?",
      "options": [
        "2name",
        "_name",
        "$name",
        "name2"
      ],
      "correctAnswer": 0,
      "explanation": "변수명은 숫자로 시작할 수 없습니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 typeof 연산자를 사용했습니다. typeof 'hello'의 결과는?",
      "options": [
        "'string'",
        "'text'",
        "'str'",
        "'String'"
      ],
      "correctAnswer": 0,
      "explanation": "문자열의 타입은 'string'입니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 확인한 typeof null의 결과는?",
      "options": [
        "'object'",
        "'null'",
        "'undefined'",
        "'empty'"
      ],
      "correctAnswer": 0,
      "explanation": "JavaScript의 오래된 버그로 typeof null은 'object'를 반환합니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 큰 정수를 다루려고 합니다. 사용할 타입은?",
      "options": [
        "BigInt",
        "LongInt",
        "Integer",
        "Long"
      ],
      "correctAnswer": 0,
      "explanation": "JavaScript에서 매우 큰 정수는 BigInt 타입을 사용합니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 심볼을 생성하려고 합니다. 올바른 방법은?",
      "options": [
        "Symbol('description')",
        "new Symbol('description')",
        "symbol('description')",
        "createSymbol('description')"
      ],
      "correctAnswer": 0,
      "explanation": "Symbol은 함수로 호출하여 생성합니다 (new 키워드 사용 안 함)."
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 확인한 typeof undefined의 결과는?",
      "options": [
        "'undefined'",
        "'null'",
        "'object'",
        "'empty'"
      ],
      "correctAnswer": 0,
      "explanation": "undefined의 타입은 'undefined'입니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 문자열을 더하려고 합니다. 'Hello' + ' ' + 'World'의 결과는?",
      "options": [
        "'Hello World'",
        "'HelloWorld'",
        "'Hello + World'",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "+ 연산자로 문자열을 연결할 수 있습니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 나머지를 구하려고 합니다. 10 % 3의 결과는?",
      "options": [
        "1",
        "3",
        "0",
        "3.333"
      ],
      "correctAnswer": 0,
      "explanation": "% 연산자는 나머지를 반환합니다. 10을 3으로 나눈 나머지는 1입니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 거듭제곱을 계산하려고 합니다. 2의 3승을 구하는 연산은?",
      "options": [
        "2 ** 3",
        "2 ^ 3",
        "Math.pow(2, 3)",
        "2 ** 3과 Math.pow(2, 3) 모두"
      ],
      "correctAnswer": 3,
      "explanation": "** 연산자와 Math.pow() 모두 거듭제곱을 계산합니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 증감 연산자를 사용합니다. let x = 5; x++; 후 x의 값은?",
      "options": [
        "6",
        "5",
        "4",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "++ 연산자는 변수의 값을 1 증가시킵니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 비교합니다. '5' == 5의 결과는?",
      "options": [
        "true",
        "false",
        "undefined",
        "오류"
      ],
      "correctAnswer": 0,
      "explanation": "== 연산자는 타입 변환 후 비교하므로 true입니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 조건문을 작성합니다. if문의 조건으로 사용될 때 false로 평가되지 않는 것은?",
      "options": [
        "'0'",
        "0",
        "null",
        "undefined"
      ],
      "correctAnswer": 0,
      "explanation": "'0'은 빈 문자열이 아니므로 true로 평가됩니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 삼항 연산자를 사용합니다. let result = age >= 18 ? 'adult' : 'minor'; 이 코드의 의미는?",
      "options": [
        "age가 18 이상이면 'adult', 아니면 'minor'",
        "age가 18이면 'adult', 아니면 'minor'",
        "age가 18보다 크면 'adult', 아니면 'minor'",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "삼항 연산자는 조건 ? 참일 때 : 거짓일 때 형태입니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 switch문을 작성합니다. break를 생략하면 어떻게 되나요?",
      "options": [
        "다음 case로 계속 실행된다 (fall-through)",
        "오류가 발생한다",
        "자동으로 종료된다",
        "default로 이동한다"
      ],
      "correctAnswer": 0,
      "explanation": "break를 생략하면 다음 case가 계속 실행됩니다 (fall-through)."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 else if를 사용합니다. 몇 개까지 사용할 수 있나요?",
      "options": [
        "제한 없음",
        "최대 10개",
        "최대 5개",
        "최대 3개"
      ],
      "correctAnswer": 0,
      "explanation": "else if는 필요한 만큼 여러 개 사용할 수 있습니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 조건을 확인합니다. null과 undefined를 구분하려면 어떤 연산자를 사용해야 하나요?",
      "options": [
        "===",
        "==",
        "=",
        "!="
      ],
      "correctAnswer": 0,
      "explanation": "=== 연산자는 타입까지 비교하므로 null과 undefined를 구분합니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 while 반복문을 작성합니다. 조건이 처음부터 false면 몇 번 실행되나요?",
      "options": [
        "0번",
        "1번",
        "무한 반복",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "while문은 조건이 false면 한 번도 실행되지 않습니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 do-while을 사용합니다. while과의 차이점은?",
      "options": [
        "조건이 false여도 최소 1번은 실행된다",
        "더 빠르다",
        "조건 검사를 하지 않는다",
        "차이가 없다"
      ],
      "correctAnswer": 0,
      "explanation": "do-while은 조건을 나중에 검사하므로 최소 1번은 실행됩니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 for문을 작성합니다. for (let i = 0; i < 5; i++)의 실행 순서는?",
      "options": [
        "초기화 → 조건 검사 → 본문 실행 → 증감",
        "초기화 → 본문 실행 → 조건 검사 → 증감",
        "조건 검사 → 초기화 → 본문 실행 → 증감",
        "초기화 → 증감 → 조건 검사 → 본문 실행"
      ],
      "correctAnswer": 0,
      "explanation": "for문은 초기화 → 조건 검사 → 본문 실행 → 증감 순으로 실행됩니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 배열을 순회합니다. for...of의 용도는?",
      "options": [
        "배열의 값을 순회",
        "객체의 키를 순회",
        "숫자 범위를 순회",
        "문자열의 인덱스를 순회"
      ],
      "correctAnswer": 0,
      "explanation": "for...of는 배열이나 이터러블 객체의 값을 순회합니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 break를 사용합니다. break의 역할은?",
      "options": [
        "반복문을 즉시 종료",
        "현재 반복만 건너뛰기",
        "함수 종료",
        "프로그램 종료"
      ],
      "correctAnswer": 0,
      "explanation": "break는 반복문을 즉시 종료합니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 함수를 선언합니다. function greet() {}와 const greet = function() {}의 차이는?",
      "options": [
        "함수 선언문은 호이스팅된다",
        "함수 표현식이 더 빠르다",
        "차이가 없다",
        "함수 표현식은 호이스팅된다"
      ],
      "correctAnswer": 0,
      "explanation": "함수 선언문은 호이스팅되어 선언 전에 호출 가능하지만, 함수 표현식은 그렇지 않습니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 화살표 함수를 작성합니다. const add = (a, b) => a + b; 이 함수의 반환값은?",
      "options": [
        "a + b의 결과",
        "undefined",
        "a",
        "b"
      ],
      "correctAnswer": 0,
      "explanation": "화살표 함수에서 중괄호 없이 표현식을 쓰면 자동으로 반환됩니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 기본 매개변수를 사용합니다. function greet(name = 'Guest') {} greet()을 호출하면 name은?",
      "options": [
        "'Guest'",
        "undefined",
        "null",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "인자를 전달하지 않으면 기본값 'Guest'가 사용됩니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 나머지 매개변수를 사용합니다. function sum(...numbers) {} ...numbers의 타입은?",
      "options": [
        "배열",
        "객체",
        "문자열",
        "숫자"
      ],
      "correctAnswer": 0,
      "explanation": "나머지 매개변수(...)는 전달된 인자들을 배열로 수집합니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 return을 사용하지 않은 함수를 호출합니다. 반환값은?",
      "options": [
        "undefined",
        "null",
        "0",
        "빈 문자열"
      ],
      "correctAnswer": 0,
      "explanation": "return문이 없는 함수는 undefined를 반환합니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 배열을 생성합니다. let arr = [1, 2, 3]; arr의 첫 번째 요소는?",
      "options": [
        "arr[0]",
        "arr[1]",
        "arr.first",
        "arr.get(0)"
      ],
      "correctAnswer": 0,
      "explanation": "배열의 인덱스는 0부터 시작하므로 첫 번째 요소는 arr[0]입니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 배열 끝에 요소를 추가하려고 합니다. 사용할 메서드는?",
      "options": [
        "push()",
        "append()",
        "add()",
        "insert()"
      ],
      "correctAnswer": 0,
      "explanation": "push() 메서드는 배열 끝에 요소를 추가합니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 배열에서 특정 요소를 찾으려고 합니다. [1, 2, 3].indexOf(2)의 결과는?",
      "options": [
        "1",
        "2",
        "0",
        "-1"
      ],
      "correctAnswer": 0,
      "explanation": "indexOf()는 요소의 인덱스를 반환합니다. 2는 인덱스 1에 있습니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 배열을 필터링합니다. [1, 2, 3, 4].filter(x => x > 2)의 결과는?",
      "options": [
        "[3, 4]",
        "[1, 2]",
        "[2, 3, 4]",
        "[4]"
      ],
      "correctAnswer": 0,
      "explanation": "filter()는 조건을 만족하는 요소들로 새 배열을 만듭니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 배열을 변환합니다. [1, 2, 3].map(x => x * 2)의 결과는?",
      "options": [
        "[2, 4, 6]",
        "[1, 2, 3]",
        "[3, 6, 9]",
        "6"
      ],
      "correctAnswer": 0,
      "explanation": "map()은 각 요소에 함수를 적용하여 새 배열을 반환합니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 객체를 생성합니다. let obj = {name: 'Badebu'}; obj.name에 접근하는 다른 방법은?",
      "options": [
        "obj['name']",
        "obj->name",
        "obj::name",
        "obj.get('name')"
      ],
      "correctAnswer": 0,
      "explanation": "객체의 프로퍼티는 점 표기법과 대괄호 표기법으로 접근할 수 있습니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 객체에 메서드를 추가합니다. 메서드란 무엇인가요?",
      "options": [
        "객체의 프로퍼티로 저장된 함수",
        "객체의 속성",
        "객체의 타입",
        "객체의 생성자"
      ],
      "correctAnswer": 0,
      "explanation": "메서드는 객체의 프로퍼티로 저장된 함수를 의미합니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 객체를 복사합니다. let copy = {...original}; 이것은 무엇인가요?",
      "options": [
        "스프레드 연산자를 이용한 얕은 복사",
        "깊은 복사",
        "참조 복사",
        "오류 코드"
      ],
      "correctAnswer": 0,
      "explanation": "스프레드 연산자(...)는 객체를 얕게 복사합니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 객체의 키들을 얻으려고 합니다. 사용할 메서드는?",
      "options": [
        "Object.keys(obj)",
        "obj.keys()",
        "obj.getKeys()",
        "keys(obj)"
      ],
      "correctAnswer": 0,
      "explanation": "Object.keys()는 객체의 모든 키를 배열로 반환합니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 프로퍼티의 존재를 확인합니다. 'name' in obj의 결과는 언제 true인가요?",
      "options": [
        "obj에 'name' 프로퍼티가 있을 때",
        "obj.name이 true일 때",
        "obj가 배열일 때",
        "항상 false"
      ],
      "correctAnswer": 0,
      "explanation": "in 연산자는 객체에 해당 프로퍼티가 있는지 확인합니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 클래스를 정의합니다. constructor의 역할은?",
      "options": [
        "객체를 초기화하는 특수 메서드",
        "객체를 삭제하는 메서드",
        "객체를 복사하는 메서드",
        "클래스 이름"
      ],
      "correctAnswer": 0,
      "explanation": "constructor는 new로 객체를 생성할 때 자동으로 호출되는 초기화 메서드입니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 상속을 구현합니다. class Dog extends Animal {} 여기서 extends의 의미는?",
      "options": [
        "Dog가 Animal을 상속받는다",
        "Animal이 Dog를 상속받는다",
        "Dog와 Animal이 같다",
        "오류 발생"
      ],
      "correctAnswer": 0,
      "explanation": "extends 키워드는 클래스 상속을 나타냅니다. Dog는 Animal의 자식 클래스입니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 정적 메서드를 만듭니다. static method() {} 정적 메서드는 어떻게 호출하나요?",
      "options": [
        "클래스명.method()",
        "인스턴스.method()",
        "new method()",
        "method()"
      ],
      "correctAnswer": 0,
      "explanation": "정적 메서드는 인스턴스가 아닌 클래스 자체에서 호출합니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 private 필드를 선언합니다. #name의 #의 의미는?",
      "options": [
        "private 필드임을 나타낸다",
        "주석이다",
        "ID를 나타낸다",
        "상수를 나타낸다"
      ],
      "correctAnswer": 0,
      "explanation": "#으로 시작하는 필드는 클래스 외부에서 접근할 수 없는 private 필드입니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 getter를 만듭니다. get fullName() { return this.firstName + ' ' + this.lastName; } 호출 방법은?",
      "options": [
        "obj.fullName",
        "obj.fullName()",
        "obj.get('fullName')",
        "obj->fullName"
      ],
      "correctAnswer": 0,
      "explanation": "getter는 메서드처럼 정의하지만 프로퍼티처럼 접근합니다 (괄호 없이)."
    }
  ]
}
