{
  "language": "nestjs",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 NestJS로 백엔드를 개발하려고 합니다. NestJS는 어떤 언어를 기반으로 만들어졌나요?",
      "options": ["JavaScript", "TypeScript", "Java", "Python"],
      "correctAnswer": 1,
      "explanation": "NestJS는 TypeScript를 기반으로 만들어진 Node.js 프레임워크입니다. TypeScript의 강력한 타입 시스템과 최신 기능을 활용할 수 있습니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 새로운 NestJS 프로젝트를 생성하고 싶습니다. 올바른 명령어는?",
      "options": ["nest create my-app", "nest new my-app", "nest init my-app", "nest start my-app"],
      "correctAnswer": 1,
      "explanation": "nest new 명령어는 새로운 NestJS 프로젝트를 생성합니다. Nest CLI를 먼저 설치해야 합니다: npm i -g @nestjs/cli"
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 NestJS 프로젝트를 개발 모드로 실행하려고 합니다. 올바른 명령어는?",
      "options": ["npm start", "npm run start", "npm run start:dev", "npm run dev"],
      "correctAnswer": 2,
      "explanation": "npm run start:dev는 개발 모드로 실행하며, 코드 변경 시 자동으로 재시작됩니다. 핫 리로드 기능을 사용하려면 start:dev를 사용하세요."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 NestJS의 기본 포트를 확인하려고 합니다. 기본적으로 어떤 포트에서 실행되나요?",
      "options": ["8080", "3000", "5000", "4200"],
      "correctAnswer": 1,
      "explanation": "NestJS 애플리케이션은 기본적으로 3000번 포트에서 실행됩니다. main.ts 파일에서 포트를 변경할 수 있습니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 NestJS의 아키텍처 패턴을 공부하고 있습니다. NestJS는 어떤 아키텍처 패턴을 사용하나요?",
      "options": ["MVC 패턴", "MVVM 패턴", "모듈 기반 아키텍처", "레이어드 아키텍처"],
      "correctAnswer": 2,
      "explanation": "NestJS는 모듈 기반 아키텍처를 사용합니다. 각 기능을 독립적인 모듈로 구성하여 코드의 재사용성과 유지보수성을 높입니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 HTTP 요청을 처리하는 컨트롤러를 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Controller()", "@Route()", "@Handler()", "@Endpoint()"],
      "correctAnswer": 0,
      "explanation": "@Controller() 데코레이터는 클래스를 컨트롤러로 정의합니다. 라우트 경로를 인자로 받을 수 있습니다. 예: @Controller('users')"
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 GET 요청을 처리하는 메서드를 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Get()", "@GetMapping()", "@HttpGet()", "@Route.Get()"],
      "correctAnswer": 0,
      "explanation": "@Get() 데코레이터는 HTTP GET 요청을 처리하는 메서드를 정의합니다. 경로를 인자로 받을 수 있습니다. 예: @Get(':id')"
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 POST 요청으로 데이터를 받고 싶습니다. 요청 본문(body)을 받으려면 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@RequestBody()", "@Body()", "@PostData()", "@Payload()"],
      "correctAnswer": 1,
      "explanation": "@Body() 데코레이터는 요청 본문의 데이터를 메서드 파라미터로 받습니다. 특정 필드만 받으려면 @Body('fieldName')처럼 사용할 수 있습니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 URL 파라미터를 받고 싶습니다. /users/:id에서 id를 받으려면 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Param('id')", "@PathVariable('id')", "@UrlParam('id')", "@RouteParam('id')"],
      "correctAnswer": 0,
      "explanation": "@Param('id') 데코레이터는 URL 경로의 파라미터를 추출합니다. @Param()만 사용하면 모든 파라미터를 객체로 받을 수 있습니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 쿼리 스트링을 받고 싶습니다. /users?page=1에서 page를 받으려면 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@QueryString('page')", "@Query('page')", "@Param('page')", "@RequestParam('page')"],
      "correctAnswer": 1,
      "explanation": "@Query('page') 데코레이터는 쿼리 스트링 파라미터를 추출합니다. @Query()만 사용하면 모든 쿼리 파라미터를 객체로 받을 수 있습니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 비즈니스 로직을 처리하는 서비스를 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Service()", "@Injectable()", "@Provider()", "@Component()"],
      "correctAnswer": 1,
      "explanation": "@Injectable() 데코레이터는 클래스를 NestJS의 의존성 주입 시스템에서 사용할 수 있게 만듭니다. 서비스, 리포지토리 등에 사용됩니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 컨트롤러에서 서비스를 사용하고 싶습니다. 어떻게 주입해야 하나요?",
      "options": ["@Inject() private service: UserService", "constructor(private service: UserService)", "this.service = new UserService()", "@Autowired private service: UserService"],
      "correctAnswer": 1,
      "explanation": "생성자를 통한 의존성 주입이 NestJS의 표준 방식입니다. private 키워드를 사용하면 자동으로 클래스 속성으로 등록됩니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 프로바이더를 모듈에 등록하고 싶습니다. 모듈의 어떤 속성에 추가해야 하나요?",
      "options": ["imports", "providers", "controllers", "exports"],
      "correctAnswer": 1,
      "explanation": "providers 배열에 서비스 클래스를 등록하면 해당 모듈 내에서 의존성 주입을 통해 사용할 수 있습니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 다른 모듈에서도 서비스를 사용하고 싶습니다. 모듈의 어떤 속성에 추가해야 하나요?",
      "options": ["imports", "providers", "controllers", "exports"],
      "correctAnswer": 3,
      "explanation": "exports 배열에 프로바이더를 추가하면 다른 모듈에서 import하여 사용할 수 있습니다. 재사용 가능한 모듈을 만들 때 필수적입니다."
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 커스텀 프로바이더를 만들고 싶습니다. 토큰을 사용하여 주입하려면 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Token('TOKEN')", "@Inject('TOKEN')", "@Use('TOKEN')", "@Provide('TOKEN')"],
      "correctAnswer": 1,
      "explanation": "@Inject() 데코레이터를 사용하면 커스텀 토큰으로 프로바이더를 주입할 수 있습니다. 인터페이스나 문자열 토큰을 사용할 때 유용합니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 새로운 기능 모듈을 생성하고 싶습니다. CLI 명령어는?",
      "options": ["nest create module users", "nest generate module users", "nest new module users", "nest make module users"],
      "correctAnswer": 1,
      "explanation": "nest generate module 또는 nest g module 명령어로 새로운 모듈을 생성할 수 있습니다. 자동으로 AppModule에 import됩니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 다른 모듈의 기능을 사용하고 싶습니다. 모듈의 어떤 속성에 추가해야 하나요?",
      "options": ["imports", "providers", "controllers", "exports"],
      "correctAnswer": 0,
      "explanation": "imports 배열에 다른 모듈을 추가하면 그 모듈이 export한 프로바이더들을 사용할 수 있습니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 모든 모듈에서 사용할 수 있는 전역 모듈을 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Module({ global: true })", "@Global()", "@Shared()", "@Common()"],
      "correctAnswer": 1,
      "explanation": "@Global() 데코레이터를 모듈에 추가하면 한 번만 import해도 모든 곳에서 사용할 수 있습니다. 데이터베이스 모듈 등에 유용합니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 모듈을 동적으로 설정하고 싶습니다. 어떤 메서드를 구현해야 하나요?",
      "options": ["static config()", "static register()", "static setup()", "static initialize()"],
      "correctAnswer": 1,
      "explanation": "static register(), forRoot(), forFeature() 등의 메서드로 동적 모듈을 만들 수 있습니다. 옵션을 받아 모듈을 설정할 때 사용합니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 애플리케이션의 루트 모듈을 찾고 있습니다. 기본 루트 모듈의 이름은?",
      "options": ["RootModule", "MainModule", "AppModule", "CoreModule"],
      "correctAnswer": 2,
      "explanation": "AppModule은 NestJS 애플리케이션의 루트 모듈입니다. main.ts에서 NestFactory.create()로 부트스트랩됩니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 NestJS에서 TypeORM을 사용하고 싶습니다. 어떤 패키지를 설치해야 하나요?",
      "options": ["@nestjs/typeorm", "@nestjs/database", "@nestjs/orm", "@nestjs/sql"],
      "correctAnswer": 0,
      "explanation": "@nestjs/typeorm 패키지는 NestJS와 TypeORM을 통합합니다. typeorm과 데이터베이스 드라이버(예: pg, mysql2)도 함께 설치해야 합니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 데이터베이스 연결을 설정하고 싶습니다. AppModule에 어떤 모듈을 import해야 하나요?",
      "options": ["DatabaseModule.forRoot()", "TypeOrmModule.forRoot()", "OrmModule.forRoot()", "ConnectionModule.forRoot()"],
      "correctAnswer": 1,
      "explanation": "TypeOrmModule.forRoot()는 데이터베이스 연결을 설정합니다. 데이터베이스 타입, 호스트, 포트, 인증 정보 등을 설정할 수 있습니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 엔티티 클래스를 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Table()", "@Entity()", "@Model()", "@Schema()"],
      "correctAnswer": 1,
      "explanation": "@Entity() 데코레이터는 클래스를 데이터베이스 테이블로 매핑합니다. 테이블 이름을 인자로 지정할 수 있습니다."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 엔티티의 기본 키(Primary Key)를 정의하고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Id()", "@PrimaryKey()", "@PrimaryColumn()", "@Key()"],
      "correctAnswer": 2,
      "explanation": "@PrimaryColumn() 또는 @PrimaryGeneratedColumn() 데코레이터로 기본 키를 정의합니다. PrimaryGeneratedColumn은 자동 증가하는 값을 생성합니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 엔티티의 리포지토리를 주입받고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Repository(User)", "@InjectRepository(User)", "@Inject('UserRepository')", "@UseRepository(User)"],
      "correctAnswer": 1,
      "explanation": "@InjectRepository(Entity) 데코레이터는 해당 엔티티의 리포지토리를 주입합니다. 모듈에서 TypeOrmModule.forFeature([Entity])로 등록해야 합니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 요청 데이터의 유효성을 검증하고 싶습니다. DTO는 무엇의 약자인가요?",
      "options": ["Data Transfer Object", "Database Type Object", "Dynamic Type Object", "Data Type Operation"],
      "correctAnswer": 0,
      "explanation": "DTO(Data Transfer Object)는 계층 간 데이터 전송을 위한 객체입니다. 요청/응답 데이터의 타입과 유효성 검증을 정의합니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 DTO의 유효성 검증을 자동화하고 싶습니다. 어떤 패키지를 설치해야 하나요?",
      "options": ["@nestjs/validator", "class-validator", "nestjs-validation", "validation-pipe"],
      "correctAnswer": 1,
      "explanation": "class-validator 패키지는 데코레이터 기반의 유효성 검증을 제공합니다. class-transformer와 함께 사용하여 자동 변환도 가능합니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 DTO 필드가 비어있지 않은지 검증하고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Required()", "@NotEmpty()", "@IsNotEmpty()", "@NotNull()"],
      "correctAnswer": 2,
      "explanation": "@IsNotEmpty() 데코레이터는 값이 비어있지 않은지 검증합니다. class-validator 패키지에서 제공합니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 이메일 형식을 검증하고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Email()", "@IsEmail()", "@ValidEmail()", "@EmailFormat()"],
      "correctAnswer": 1,
      "explanation": "@IsEmail() 데코레이터는 이메일 주소 형식을 검증합니다. 잘못된 형식이면 자동으로 에러를 반환합니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 전역적으로 ValidationPipe를 적용하고 싶습니다. main.ts에서 어떻게 설정해야 하나요?",
      "options": ["app.use(new ValidationPipe())", "app.useGlobalPipes(new ValidationPipe())", "app.setValidation(new ValidationPipe())", "app.addPipe(new ValidationPipe())"],
      "correctAnswer": 1,
      "explanation": "app.useGlobalPipes(new ValidationPipe())로 전역 ValidationPipe를 설정하면 모든 요청에 대해 자동으로 DTO 유효성 검증이 수행됩니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 모든 요청에 대해 로깅을 하고 싶습니다. 어떤 개념을 사용해야 하나요?",
      "options": ["필터(Filter)", "미들웨어(Middleware)", "인터셉터(Interceptor)", "파이프(Pipe)"],
      "correctAnswer": 1,
      "explanation": "미들웨어는 라우트 핸들러 이전에 실행되는 함수입니다. 요청/응답 객체에 접근하여 로깅, 인증 등을 수행할 수 있습니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 미들웨어를 만들고 싶습니다. 어떤 인터페이스를 구현해야 하나요?",
      "options": ["MiddlewareInterface", "NestMiddleware", "HttpMiddleware", "RequestMiddleware"],
      "correctAnswer": 1,
      "explanation": "NestMiddleware 인터페이스를 구현하고 use() 메서드를 정의합니다. Express 미들웨어처럼 req, res, next를 받습니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 특정 경로에만 미들웨어를 적용하고 싶습니다. 모듈에서 어떤 메서드를 구현해야 하나요?",
      "options": ["configureRoutes()", "configure()", "setupMiddleware()", "applyMiddleware()"],
      "correctAnswer": 1,
      "explanation": "NestModule 인터페이스의 configure() 메서드를 구현하여 미들웨어를 특정 경로에 적용할 수 있습니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 인증된 사용자만 접근하도록 보호하고 싶습니다. 어떤 개념을 사용해야 하나요?",
      "options": ["필터(Filter)", "미들웨어(Middleware)", "가드(Guard)", "파이프(Pipe)"],
      "correctAnswer": 2,
      "explanation": "가드는 라우트 접근을 제어합니다. 인증, 권한 검사 등에 사용되며, true를 반환하면 요청이 진행되고 false면 차단됩니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 커스텀 가드를 만들고 싶습니다. 어떤 인터페이스를 구현해야 하나요?",
      "options": ["Guard", "CanActivate", "AuthGuard", "RouteGuard"],
      "correctAnswer": 1,
      "explanation": "CanActivate 인터페이스를 구현하고 canActivate() 메서드를 정의합니다. boolean 또는 Promise<boolean>을 반환해야 합니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 응답을 가공하거나 로깅하고 싶습니다. 어떤 개념을 사용해야 하나요?",
      "options": ["필터(Filter)", "미들웨어(Middleware)", "인터셉터(Interceptor)", "파이프(Pipe)"],
      "correctAnswer": 2,
      "explanation": "인터셉터는 메서드 실행 전후에 로직을 추가할 수 있습니다. 응답 변환, 로깅, 캐싱, 예외 매핑 등에 사용됩니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 커스텀 인터셉터를 만들고 싶습니다. 어떤 인터페이스를 구현해야 하나요?",
      "options": ["Interceptor", "NestInterceptor", "HttpInterceptor", "RequestInterceptor"],
      "correctAnswer": 1,
      "explanation": "NestInterceptor 인터페이스를 구현하고 intercept() 메서드를 정의합니다. ExecutionContext와 CallHandler를 매개변수로 받습니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 응답 데이터를 변환하고 싶습니다. 인터셉터의 intercept() 메서드에서 무엇을 사용해야 하나요?",
      "options": ["next.pipe(map(...))", "return map(...)", "handle.pipe(map(...))", "next.handle().pipe(map(...))"],
      "correctAnswer": 3,
      "explanation": "CallHandler의 handle()은 Observable을 반환하며, RxJS의 pipe와 map을 사용하여 응답 데이터를 변환할 수 있습니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 입력 데이터를 변환하고 싶습니다. 어떤 개념을 사용해야 하나요?",
      "options": ["필터(Filter)", "인터셉터(Interceptor)", "파이프(Pipe)", "가드(Guard)"],
      "correctAnswer": 2,
      "explanation": "파이프는 입력 데이터를 변환하거나 유효성을 검증합니다. 타입 변환, DTO 검증 등에 사용됩니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 문자열을 숫자로 변환하고 싶습니다. 어떤 내장 파이프를 사용해야 하나요?",
      "options": ["NumberPipe", "ParseIntPipe", "ToNumberPipe", "IntegerPipe"],
      "correctAnswer": 1,
      "explanation": "ParseIntPipe는 문자열을 정수로 변환합니다. 변환 실패 시 자동으로 400 에러를 반환합니다. ParseFloatPipe, ParseBoolPipe 등도 있습니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 발생한 예외를 처리하고 싶습니다. 어떤 개념을 사용해야 하나요?",
      "options": ["예외 필터(Exception Filter)", "에러 핸들러(Error Handler)", "예외 인터셉터(Exception Interceptor)", "에러 가드(Error Guard)"],
      "correctAnswer": 0,
      "explanation": "예외 필터는 애플리케이션에서 발생한 예외를 잡아 처리합니다. 일관된 에러 응답 형식을 제공할 수 있습니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 404 에러를 발생시키고 싶습니다. 어떤 예외를 던져야 하나요?",
      "options": ["throw new HttpException('Not Found', 404)", "throw new NotFoundException()", "throw new NotFoundError()", "throw new Error404()"],
      "correctAnswer": 1,
      "explanation": "NotFoundException은 404 상태 코드를 반환하는 NestJS 내장 예외입니다. BadRequestException, UnauthorizedException 등 다양한 HTTP 예외가 있습니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 커스텀 예외 필터를 만들고 싶습니다. 어떤 인터페이스를 구현해야 하나요?",
      "options": ["ExceptionFilter", "ExceptionHandler", "ErrorFilter", "HttpExceptionFilter"],
      "correctAnswer": 0,
      "explanation": "ExceptionFilter 인터페이스를 구현하고 catch() 메서드를 정의합니다. @Catch() 데코레이터로 처리할 예외 타입을 지정할 수 있습니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 특정 예외만 처리하는 필터를 만들고 싶습니다. 어떤 데코레이터를 사용해야 하나요?",
      "options": ["@Filter(HttpException)", "@Catch(HttpException)", "@Handle(HttpException)", "@Exception(HttpException)"],
      "correctAnswer": 1,
      "explanation": "@Catch(ExceptionType) 데코레이터는 특정 예외 타입만 처리하도록 필터를 제한합니다. 여러 예외 타입을 지정할 수도 있습니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 전역 예외 필터를 적용하고 싶습니다. main.ts에서 어떻게 설정해야 하나요?",
      "options": ["app.useGlobalFilters(new CustomExceptionFilter())", "app.setExceptionFilter(new CustomExceptionFilter())", "app.addFilter(new CustomExceptionFilter())", "app.useFilter(new CustomExceptionFilter())"],
      "correctAnswer": 0,
      "explanation": "app.useGlobalFilters()로 전역 예외 필터를 설정하면 모든 예외를 일관되게 처리할 수 있습니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 NestJS 애플리케이션의 유닛 테스트를 작성하고 싶습니다. 어떤 도구를 사용하나요?",
      "options": ["Mocha", "Jest", "Jasmine", "QUnit"],
      "correctAnswer": 1,
      "explanation": "NestJS는 기본적으로 Jest를 테스트 프레임워크로 사용합니다. spec.ts 파일에 테스트를 작성합니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 테스트에서 모듈을 설정하고 싶습니다. 어떤 클래스를 사용해야 하나요?",
      "options": ["TestModule", "Test.createTestingModule()", "TestingModuleBuilder", "ModuleTest"],
      "correctAnswer": 1,
      "explanation": "Test.createTestingModule()은 테스트용 모듈을 생성합니다. 실제 모듈처럼 providers, imports 등을 설정할 수 있습니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 E2E 테스트를 실행하고 싶습니다. 올바른 명령어는?",
      "options": ["npm test", "npm run test:e2e", "npm run e2e", "npm run test:integration"],
      "correctAnswer": 1,
      "explanation": "npm run test:e2e는 엔드투엔드 테스트를 실행합니다. 실제 HTTP 요청을 보내 애플리케이션 전체를 테스트합니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 프로덕션 빌드를 생성하고 싶습니다. 올바른 명령어는?",
      "options": ["npm run compile", "npm run build", "npm run production", "npm run deploy"],
      "correctAnswer": 1,
      "explanation": "npm run build는 TypeScript를 JavaScript로 컴파일하고 dist 폴더에 프로덕션 빌드를 생성합니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 프로덕션 환경에서 애플리케이션을 실행하고 싶습니다. 올바른 명령어는?",
      "options": ["npm start", "npm run start:prod", "npm run production", "node main.js"],
      "correctAnswer": 1,
      "explanation": "npm run start:prod는 빌드된 애플리케이션을 프로덕션 모드로 실행합니다. 먼저 npm run build로 빌드해야 합니다."
    }
  ]
}
