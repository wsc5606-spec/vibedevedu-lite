{
  "language": "angular",
  "displayName": "Angular",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "Angular CLI를 전역으로 설치하는 명령어는?",
      "options": [
        "npm install angular",
        "npm install -g @angular/cli",
        "ng install",
        "npm create angular"
      ],
      "correctAnswer": 1,
      "explanation": "Angular CLI는 'npm install -g @angular/cli' 명령어로 전역 설치합니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "새로운 Angular 프로젝트를 생성하는 명령어는?",
      "options": [
        "ng create my-app",
        "ng new my-app",
        "ng init my-app",
        "ng generate my-app"
      ],
      "correctAnswer": 1,
      "explanation": "'ng new 프로젝트명' 명령어로 새 프로젝트를 생성합니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "Angular 개발 서버를 실행하는 명령어는?",
      "options": [
        "ng start",
        "ng run",
        "ng serve",
        "ng dev"
      ],
      "correctAnswer": 2,
      "explanation": "'ng serve' 명령어로 개발 서버를 실행합니다."
    },
    {
      "id": 4,
      "chapter": 2,
      "question": "새 컴포넌트를 생성하는 명령어는?",
      "options": [
        "ng new component my-component",
        "ng create component my-component",
        "ng generate component my-component",
        "ng add component my-component"
      ],
      "correctAnswer": 2,
      "explanation": "'ng generate component' 또는 'ng g c' 명령어로 컴포넌트를 생성합니다."
    },
    {
      "id": 5,
      "chapter": 2,
      "question": "@Component 데코레이터에서 HTML 템플릿 파일 경로를 지정하는 속성은?",
      "options": [
        "template",
        "templateUrl",
        "html",
        "htmlUrl"
      ],
      "correctAnswer": 1,
      "explanation": "templateUrl 속성으로 외부 HTML 템플릿 파일 경로를 지정합니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "컴포넌트에서 HTML 태그로 사용할 이름을 정의하는 속성은?",
      "options": [
        "name",
        "tag",
        "selector",
        "component"
      ],
      "correctAnswer": 2,
      "explanation": "selector 속성으로 컴포넌트의 HTML 태그명을 정의합니다."
    },
    {
      "id": 7,
      "chapter": 3,
      "question": "컴포넌트의 데이터를 템플릿에 표시하는 문법은?",
      "options": [
        "{ data }",
        "{{ data }}",
        "[data]",
        "(data)"
      ],
      "correctAnswer": 1,
      "explanation": "이중 중괄호 {{ }}를 사용하여 보간법(Interpolation)으로 데이터를 표시합니다."
    },
    {
      "id": 8,
      "chapter": 3,
      "question": "HTML 요소의 속성에 값을 바인딩하는 문법은?",
      "options": [
        "(속성)=\"값\"",
        "{{속성}}=\"값\"",
        "[속성]=\"값\"",
        "{속성}=\"값\""
      ],
      "correctAnswer": 2,
      "explanation": "대괄호 [속성]=\"값\" 형태로 프로퍼티 바인딩을 합니다."
    },
    {
      "id": 9,
      "chapter": 3,
      "question": "클릭 이벤트를 바인딩하는 올바른 문법은?",
      "options": [
        "[click]=\"onClick()\"",
        "{{click}}=\"onClick()\"",
        "(click)=\"onClick()\"",
        "click=\"onClick()\""
      ],
      "correctAnswer": 2,
      "explanation": "소괄호 (이벤트)=\"핸들러()\" 형태로 이벤트 바인딩을 합니다."
    },
    {
      "id": 10,
      "chapter": 3,
      "question": "양방향 데이터 바인딩에 사용하는 디렉티브는?",
      "options": [
        "[model]",
        "(model)",
        "[(ngModel)]",
        "{{model}}"
      ],
      "correctAnswer": 2,
      "explanation": "[(ngModel)]을 사용하여 양방향 데이터 바인딩을 구현합니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "ngModel을 사용하기 위해 import해야 하는 모듈은?",
      "options": [
        "CommonModule",
        "BrowserModule",
        "FormsModule",
        "ReactiveFormsModule"
      ],
      "correctAnswer": 2,
      "explanation": "FormsModule을 import해야 ngModel 디렉티브를 사용할 수 있습니다."
    },
    {
      "id": 12,
      "chapter": 4,
      "question": "조건부 렌더링에 사용하는 디렉티브는?",
      "options": [
        "*ngShow",
        "*ngIf",
        "*ngVisible",
        "*ngDisplay"
      ],
      "correctAnswer": 1,
      "explanation": "*ngIf 디렉티브로 조건에 따라 요소를 렌더링합니다."
    },
    {
      "id": 13,
      "chapter": 4,
      "question": "배열을 반복하여 렌더링하는 디렉티브는?",
      "options": [
        "*ngRepeat",
        "*ngLoop",
        "*ngFor",
        "*ngEach"
      ],
      "correctAnswer": 2,
      "explanation": "*ngFor 디렉티브로 배열을 순회하며 요소를 렌더링합니다."
    },
    {
      "id": 14,
      "chapter": 4,
      "question": "*ngFor에서 현재 인덱스를 가져오는 방법은?",
      "options": [
        "let idx = index",
        "let i = index",
        "let index",
        "index as i"
      ],
      "correctAnswer": 1,
      "explanation": "'let i = index' 형태로 현재 반복의 인덱스를 변수에 할당할 수 있습니다."
    },
    {
      "id": 15,
      "chapter": 4,
      "question": "CSS 클래스를 동적으로 바인딩하는 디렉티브는?",
      "options": [
        "[class]",
        "ngClass",
        "ngStyle",
        "[style]"
      ],
      "correctAnswer": 1,
      "explanation": "ngClass 디렉티브로 조건에 따라 CSS 클래스를 동적으로 적용합니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "인라인 스타일을 동적으로 바인딩하는 디렉티브는?",
      "options": [
        "[style]",
        "ngStyle",
        "ngClass",
        "[css]"
      ],
      "correctAnswer": 1,
      "explanation": "ngStyle 디렉티브로 동적으로 인라인 스타일을 적용합니다."
    },
    {
      "id": 17,
      "chapter": 5,
      "question": "새 서비스를 생성하는 명령어는?",
      "options": [
        "ng new service data",
        "ng create service data",
        "ng generate service data",
        "ng add service data"
      ],
      "correctAnswer": 2,
      "explanation": "'ng generate service' 또는 'ng g s' 명령어로 서비스를 생성합니다."
    },
    {
      "id": 18,
      "chapter": 5,
      "question": "서비스를 앱 전체에서 사용 가능하게 하는 설정은?",
      "options": [
        "providedIn: 'app'",
        "providedIn: 'root'",
        "global: true",
        "scope: 'global'"
      ],
      "correctAnswer": 1,
      "explanation": "@Injectable({ providedIn: 'root' })로 서비스를 루트 레벨에서 제공합니다."
    },
    {
      "id": 19,
      "chapter": 5,
      "question": "컴포넌트에서 서비스를 주입받는 방법은?",
      "options": [
        "this.inject(MyService)",
        "생성자 파라미터로 선언",
        "@Inject(MyService)",
        "import MyService"
      ],
      "correctAnswer": 1,
      "explanation": "생성자의 파라미터로 서비스를 선언하여 의존성 주입을 받습니다."
    },
    {
      "id": 20,
      "chapter": 5,
      "question": "HTTP 요청을 위해 import해야 하는 모듈은?",
      "options": [
        "HttpModule",
        "HttpClientModule",
        "NetworkModule",
        "ApiModule"
      ],
      "correctAnswer": 1,
      "explanation": "HttpClientModule을 import하여 HTTP 요청 기능을 사용합니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "HttpClient의 GET 요청 메서드가 반환하는 타입은?",
      "options": [
        "Promise",
        "Observable",
        "Array",
        "Stream"
      ],
      "correctAnswer": 1,
      "explanation": "HttpClient의 메서드들은 Observable을 반환합니다."
    },
    {
      "id": 22,
      "chapter": 6,
      "question": "라우팅 설정을 위한 모듈은?",
      "options": [
        "RouteModule",
        "RouterModule",
        "NavigationModule",
        "RoutingModule"
      ],
      "correctAnswer": 1,
      "explanation": "RouterModule을 사용하여 라우팅을 설정합니다."
    },
    {
      "id": 23,
      "chapter": 6,
      "question": "라우터가 컴포넌트를 렌더링할 위치를 지정하는 디렉티브는?",
      "options": [
        "<router-view>",
        "<router-outlet>",
        "<route-container>",
        "<navigation>"
      ],
      "correctAnswer": 1,
      "explanation": "<router-outlet> 태그에 라우트된 컴포넌트가 렌더링됩니다."
    },
    {
      "id": 24,
      "chapter": 6,
      "question": "링크를 생성하는 디렉티브는?",
      "options": [
        "href",
        "link",
        "routerLink",
        "navigate"
      ],
      "correctAnswer": 2,
      "explanation": "routerLink 디렉티브로 SPA 내비게이션 링크를 생성합니다."
    },
    {
      "id": 25,
      "chapter": 6,
      "question": "URL 파라미터를 가져오기 위해 사용하는 서비스는?",
      "options": [
        "Router",
        "RouteParams",
        "ActivatedRoute",
        "NavigationService"
      ],
      "correctAnswer": 2,
      "explanation": "ActivatedRoute 서비스로 현재 라우트의 파라미터를 가져옵니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "프로그래밍 방식으로 페이지 이동을 하는 서비스는?",
      "options": [
        "Navigation",
        "Route",
        "Router",
        "NavigationService"
      ],
      "correctAnswer": 2,
      "explanation": "Router 서비스의 navigate() 메서드로 페이지를 이동합니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "라우트 접근을 제어하는 가드는?",
      "options": [
        "RouteGuard",
        "CanActivate",
        "AuthGuard",
        "AccessControl"
      ],
      "correctAnswer": 1,
      "explanation": "CanActivate 인터페이스를 구현하여 라우트 가드를 만듭니다."
    },
    {
      "id": 28,
      "chapter": 7,
      "question": "템플릿 기반 폼에 사용하는 모듈은?",
      "options": [
        "FormModule",
        "FormsModule",
        "TemplateModule",
        "NgFormModule"
      ],
      "correctAnswer": 1,
      "explanation": "FormsModule을 import하여 템플릿 기반 폼을 사용합니다."
    },
    {
      "id": 29,
      "chapter": 7,
      "question": "반응형 폼에 사용하는 모듈은?",
      "options": [
        "FormsModule",
        "ReactiveModule",
        "ReactiveFormsModule",
        "FormBuilderModule"
      ],
      "correctAnswer": 2,
      "explanation": "ReactiveFormsModule을 import하여 반응형 폼을 사용합니다."
    },
    {
      "id": 30,
      "chapter": 7,
      "question": "반응형 폼을 쉽게 생성하기 위한 서비스는?",
      "options": [
        "FormCreator",
        "FormBuilder",
        "FormGenerator",
        "FormService"
      ],
      "correctAnswer": 1,
      "explanation": "FormBuilder 서비스로 반응형 폼을 간편하게 생성합니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "필수 입력 검증을 위한 Validator는?",
      "options": [
        "Validators.mandatory",
        "Validators.require",
        "Validators.required",
        "Validators.notEmpty"
      ],
      "correctAnswer": 2,
      "explanation": "Validators.required로 필수 입력을 검증합니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "이메일 형식 검증을 위한 Validator는?",
      "options": [
        "Validators.email",
        "Validators.emailFormat",
        "Validators.isEmail",
        "Validators.validateEmail"
      ],
      "correctAnswer": 0,
      "explanation": "Validators.email로 이메일 형식을 검증합니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "최소 길이를 검증하는 Validator는?",
      "options": [
        "Validators.min(n)",
        "Validators.minLength(n)",
        "Validators.minimum(n)",
        "Validators.length.min(n)"
      ],
      "correctAnswer": 1,
      "explanation": "Validators.minLength(n)로 최소 길이를 검증합니다."
    },
    {
      "id": 34,
      "chapter": 8,
      "question": "날짜를 포맷팅하는 파이프는?",
      "options": [
        "{{ date | format }}",
        "{{ date | date }}",
        "{{ date | dateFormat }}",
        "{{ date | toDate }}"
      ],
      "correctAnswer": 1,
      "explanation": "date 파이프로 날짜를 원하는 형식으로 포맷팅합니다."
    },
    {
      "id": 35,
      "chapter": 8,
      "question": "문자열을 대문자로 변환하는 파이프는?",
      "options": [
        "uppercase",
        "toUpper",
        "upper",
        "capitalize"
      ],
      "correctAnswer": 0,
      "explanation": "uppercase 파이프로 문자열을 대문자로 변환합니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "객체를 JSON 문자열로 변환하는 파이프는?",
      "options": [
        "stringify",
        "toJSON",
        "json",
        "jsonFormat"
      ],
      "correctAnswer": 2,
      "explanation": "json 파이프로 객체를 JSON 문자열로 변환합니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "새 파이프를 생성하는 명령어는?",
      "options": [
        "ng new pipe my-pipe",
        "ng create pipe my-pipe",
        "ng generate pipe my-pipe",
        "ng add pipe my-pipe"
      ],
      "correctAnswer": 2,
      "explanation": "'ng generate pipe' 또는 'ng g p' 명령어로 파이프를 생성합니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "커스텀 파이프 클래스가 구현해야 하는 인터페이스는?",
      "options": [
        "Pipe",
        "IPipe",
        "PipeTransform",
        "CustomPipe"
      ],
      "correctAnswer": 2,
      "explanation": "PipeTransform 인터페이스의 transform 메서드를 구현해야 합니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "새 모듈을 생성하는 명령어는?",
      "options": [
        "ng new module feature",
        "ng create module feature",
        "ng generate module feature",
        "ng add module feature"
      ],
      "correctAnswer": 2,
      "explanation": "'ng generate module' 또는 'ng g m' 명령어로 모듈을 생성합니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "다른 모듈에서 사용할 컴포넌트를 지정하는 배열은?",
      "options": [
        "declarations",
        "imports",
        "exports",
        "providers"
      ],
      "correctAnswer": 2,
      "explanation": "exports 배열에 선언된 컴포넌트나 디렉티브를 다른 모듈에서 사용할 수 있습니다."
    }
  ]
}
