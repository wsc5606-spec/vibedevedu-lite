{
  "language": "react",
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "바데부가 처음으로 React 프로젝트를 시작하려고 합니다. React 앱을 생성하는 가장 일반적인 방법은 무엇일까요?",
      "options": ["npm install react", "npx create-react-app my-app", "npm start react", "react new app"],
      "correctAnswer": 1,
      "explanation": "create-react-app은 React 팀이 공식적으로 지원하는 도구로, npx를 사용하여 설치 없이 최신 버전으로 프로젝트를 생성할 수 있습니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "바데부가 React의 핵심 개념을 공부하고 있습니다. React가 사용하는 가상 DOM(Virtual DOM)의 주요 장점은 무엇일까요?",
      "options": ["메모리 사용량 감소", "실제 DOM 조작을 최소화하여 성능 향상", "코드 작성이 더 쉬워짐", "CSS 스타일링이 자동으로 적용됨"],
      "correctAnswer": 1,
      "explanation": "Virtual DOM은 실제 DOM의 가벼운 복사본으로, 변경사항을 먼저 Virtual DOM에 적용한 후 차이점만 실제 DOM에 반영하여 성능을 크게 향상시킵니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "바데부가 package.json 파일을 열어봤습니다. React 프로젝트의 의존성 중 반드시 필요한 핵심 패키지 2가지는 무엇일까요?",
      "options": ["react와 react-router", "react와 react-dom", "react와 redux", "react와 axios"],
      "correctAnswer": 1,
      "explanation": "react는 React의 핵심 라이브러리이고, react-dom은 React 컴포넌트를 실제 DOM에 렌더링하는 역할을 합니다. 두 패키지 모두 필수입니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "바데부가 개발 서버를 실행하려고 합니다. create-react-app으로 생성한 프로젝트에서 개발 서버를 시작하는 명령어는?",
      "options": ["npm run dev", "npm start", "npm serve", "npm build"],
      "correctAnswer": 1,
      "explanation": "npm start 명령어는 개발 서버를 시작하며, 기본적으로 localhost:3000에서 앱을 실행합니다. 코드 변경 시 자동으로 새로고침됩니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "바데부가 React를 배우는 이유를 친구에게 설명하려고 합니다. React의 주요 특징이 아닌 것은?",
      "options": ["컴포넌트 기반 아키텍처", "선언적 프로그래밍", "양방향 데이터 바인딩", "재사용 가능한 UI 컴포넌트"],
      "correctAnswer": 2,
      "explanation": "React는 단방향 데이터 흐름(one-way data flow)을 사용합니다. 양방향 데이터 바인딩은 Angular와 같은 프레임워크의 특징입니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "바데부가 첫 번째 컴포넌트를 작성하고 있습니다. JSX에서 JavaScript 표현식을 사용하려면 어떤 기호로 감싸야 할까요?",
      "options": ["{{ }}", "[ ]", "{ }", "( )"],
      "correctAnswer": 2,
      "explanation": "JSX에서 JavaScript 표현식을 사용할 때는 중괄호 { }로 감싸야 합니다. 예: {name}, {2 + 2}, {user.age}"
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "바데부가 JSX 코드를 작성했는데 오류가 발생했습니다. JSX에서 여러 요소를 반환할 때 반드시 지켜야 할 규칙은?",
      "options": ["모든 요소를 배열로 반환", "하나의 부모 요소로 감싸기", "각 요소에 key 속성 추가", "세미콜론으로 구분"],
      "correctAnswer": 1,
      "explanation": "JSX에서는 여러 요소를 반환할 때 반드시 하나의 부모 요소로 감싸야 합니다. <div>, <></>(Fragment) 등을 사용할 수 있습니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "바데부가 버튼에 CSS 클래스를 추가하려고 합니다. JSX에서 HTML의 'class' 속성 대신 사용해야 하는 것은?",
      "options": ["class", "className", "cssClass", "style"],
      "correctAnswer": 1,
      "explanation": "JSX에서는 'class' 대신 'className'을 사용합니다. 'class'는 JavaScript의 예약어이기 때문입니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "바데부가 함수형 컴포넌트를 작성하고 있습니다. 다음 중 올바른 함수형 컴포넌트 작성 방법은?",
      "options": ["function Welcome() { return <h1>안녕</h1> }", "function Welcome() { <h1>안녕</h1> }", "Welcome() => { return <h1>안녕</h1> }", "component Welcome() { return <h1>안녕</h1> }"],
      "correctAnswer": 0,
      "explanation": "함수형 컴포넌트는 일반 JavaScript 함수로 작성하며, JSX를 반환해야 합니다. 함수 이름은 대문자로 시작해야 합니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": "바데부가 인라인 스타일을 적용하려고 합니다. JSX에서 인라인 스타일을 작성하는 올바른 방법은?",
      "options": ["style=\"color: red\"", "style={{color: 'red'}}", "css={{color: 'red'}}", "style={color: 'red'}"],
      "correctAnswer": 1,
      "explanation": "JSX에서 인라인 스타일은 객체로 작성하며, CSS 속성은 camelCase로 작성합니다. 이중 중괄호 {{}}를 사용합니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "바데부가 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하려고 합니다. 이때 사용하는 것은?",
      "options": ["state", "props", "context", "ref"],
      "correctAnswer": 1,
      "explanation": "Props는 부모 컴포넌트가 자식 컴포넌트에게 데이터를 전달하는 방법입니다. 읽기 전용이며 자식 컴포넌트에서 수정할 수 없습니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "바데부가 자식 컴포넌트에서 props를 받았습니다. 함수형 컴포넌트에서 props를 사용하는 올바른 방법은?",
      "options": ["function Child(props) { return <div>{props.name}</div> }", "function Child() { return <div>{this.props.name}</div> }", "function Child() { return <div>{name}</div> }", "function Child({name}) { return <div>{this.name}</div> }"],
      "correctAnswer": 0,
      "explanation": "함수형 컴포넌트는 props를 매개변수로 받으며, props.속성명 형태로 접근합니다. 구조 분해 할당도 가능합니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "바데부가 props의 기본값을 설정하려고 합니다. 함수형 컴포넌트에서 props 기본값을 설정하는 방법은?",
      "options": ["컴포넌트.defaultProps = {...}", "props.default = {...}", "useState로 설정", "props.set({...})"],
      "correctAnswer": 0,
      "explanation": "defaultProps를 사용하여 props의 기본값을 설정할 수 있습니다. ES6의 기본 매개변수 문법도 사용 가능합니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "바데부가 props로 함수를 전달하려고 합니다. 부모 컴포넌트에서 자식에게 함수를 전달하는 이유는?",
      "options": ["코드를 짧게 만들기 위해", "자식 컴포넌트에서 부모의 상태를 변경하기 위해", "성능 최적화를 위해", "필수 요구사항이므로"],
      "correctAnswer": 1,
      "explanation": "Props로 함수를 전달하면 자식 컴포넌트에서 부모 컴포넌트의 상태나 동작을 제어할 수 있습니다. 이를 '상향식 데이터 흐름'이라고 합니다."
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "바데부가 children props를 공부하고 있습니다. children props는 무엇을 나타낼까요?",
      "options": ["컴포넌트의 자식 컴포넌트들", "컴포넌트 태그 사이의 내용", "하위 폴더의 파일들", "배열 형태의 데이터"],
      "correctAnswer": 1,
      "explanation": "children props는 컴포넌트 태그 사이에 있는 모든 내용을 나타냅니다. <Component>이 내용</Component>에서 '이 내용'이 children입니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "바데부가 컴포넌트에 상태를 추가하려고 합니다. 함수형 컴포넌트에서 상태를 사용하기 위해 import 해야 하는 Hook은?",
      "options": ["useEffect", "useState", "useContext", "useReducer"],
      "correctAnswer": 1,
      "explanation": "useState는 함수형 컴포넌트에 상태를 추가하는 가장 기본적인 Hook입니다. 상태값과 상태 업데이트 함수를 반환합니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "바데부가 useState를 사용하고 있습니다. const [count, setCount] = useState(0)에서 0의 역할은?",
      "options": ["최댓값", "최솟값", "초기값", "증가량"],
      "correctAnswer": 2,
      "explanation": "useState의 인자는 상태의 초기값입니다. count는 처음에 0으로 시작하며, setCount를 통해 변경할 수 있습니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "바데부가 상태를 업데이트하려고 합니다. 왜 count = count + 1 대신 setCount(count + 1)를 사용해야 할까요?",
      "options": ["코드가 더 짧아서", "React가 변경을 감지하고 리렌더링하기 위해", "에러를 방지하기 위해", "성능이 더 좋아서"],
      "correctAnswer": 1,
      "explanation": "상태를 직접 변경하면 React가 변경을 감지할 수 없습니다. set 함수를 사용해야 React가 변경을 감지하고 컴포넌트를 리렌더링합니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "바데부가 이전 상태값을 기반으로 상태를 업데이트하려고 합니다. 가장 안전한 방법은?",
      "options": ["setCount(count + 1)", "setCount(prev => prev + 1)", "count++", "setCount(1)"],
      "correctAnswer": 1,
      "explanation": "이전 상태를 기반으로 업데이트할 때는 함수형 업데이트를 사용하는 것이 안전합니다. 비동기 업데이트로 인한 문제를 방지할 수 있습니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "바데부가 객체 형태의 상태를 업데이트하려고 합니다. 올바른 방법은?",
      "options": ["user.name = '바데부'", "setUser({name: '바데부'})", "setUser({...user, name: '바데부'})", "user = {...user, name: '바데부'}"],
      "correctAnswer": 2,
      "explanation": "객체 상태를 업데이트할 때는 스프레드 연산자(...)를 사용하여 기존 속성을 유지하면서 특정 속성만 변경해야 합니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "바데부가 버튼 클릭 이벤트를 처리하려고 합니다. onClick 이벤트 핸들러를 연결하는 올바른 방법은?",
      "options": ["<button onClick={handleClick()}>", "<button onClick={handleClick}>", "<button onClick='handleClick'>", "<button click={handleClick}>"],
      "correctAnswer": 1,
      "explanation": "이벤트 핸들러는 함수 자체를 전달해야 합니다. handleClick()처럼 괄호를 붙이면 즉시 실행되어 버립니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "바데부가 이벤트 객체를 사용하려고 합니다. 이벤트 핸들러에서 이벤트 객체에 접근하는 방법은?",
      "options": ["function handleClick(e) {...}", "function handleClick(event) {...}", "function handleClick(evt) {...}", "모두 정답"],
      "correctAnswer": 3,
      "explanation": "이벤트 핸들러의 첫 번째 매개변수로 이벤트 객체가 자동으로 전달됩니다. 변수명은 e, event, evt 등 자유롭게 지정할 수 있습니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "바데부가 form 제출을 처리하고 있습니다. 페이지 새로고침을 막기 위해 사용해야 하는 메서드는?",
      "options": ["event.stop()", "event.preventDefault()", "event.stopPropagation()", "event.cancel()"],
      "correctAnswer": 1,
      "explanation": "event.preventDefault()는 이벤트의 기본 동작을 막습니다. form 제출 시 페이지 새로고침을 방지하는 데 사용됩니다."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "바데부가 input 값의 변경을 감지하려고 합니다. 사용해야 하는 이벤트는?",
      "options": ["onInput", "onChange", "onUpdate", "onType"],
      "correctAnswer": 1,
      "explanation": "React에서는 onChange 이벤트를 사용하여 input 값의 변경을 감지합니다. 타이핑할 때마다 실시간으로 발생합니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "바데부가 이벤트 핸들러에 추가 인자를 전달하려고 합니다. 올바른 방법은?",
      "options": ["onClick={handleClick(id)}", "onClick={() => handleClick(id)}", "onClick={handleClick.bind(id)}", "onClick={handleClick, id}"],
      "correctAnswer": 1,
      "explanation": "이벤트 핸들러에 인자를 전달하려면 화살표 함수로 감싸야 합니다. 이렇게 하면 클릭 시에만 함수가 실행됩니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "바데부가 조건에 따라 컴포넌트를 렌더링하려고 합니다. 조건부 렌더링에 사용할 수 있는 방법이 아닌 것은?",
      "options": ["if문", "삼항 연산자", "논리 && 연산자", "switch문"],
      "correctAnswer": 0,
      "explanation": "JSX 내부에서는 if문을 직접 사용할 수 없습니다. 삼항 연산자, 논리 연산자, 또는 즉시 실행 함수를 사용해야 합니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "바데부가 isLoggedIn이 true일 때만 환영 메시지를 표시하려고 합니다. 간단한 방법은?",
      "options": ["{isLoggedIn ? <Welcome /> : null}", "{isLoggedIn && <Welcome />}", "if (isLoggedIn) <Welcome />", "모두 정답"],
      "correctAnswer": 1,
      "explanation": "논리 && 연산자를 사용하면 조건이 true일 때만 컴포넌트를 렌더링할 수 있습니다. false일 때는 아무것도 렌더링하지 않습니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "바데부가 배열을 순회하며 리스트를 렌더링하고 있습니다. 각 항목에 반드시 추가해야 하는 속성은?",
      "options": ["id", "key", "index", "name"],
      "correctAnswer": 1,
      "explanation": "React는 리스트의 각 항목을 추적하기 위해 고유한 key prop이 필요합니다. 이를 통해 효율적으로 업데이트할 수 있습니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "바데부가 map 함수로 리스트를 렌더링하고 있습니다. key로 배열 인덱스를 사용하면 안 되는 이유는?",
      "options": ["에러가 발생함", "항목의 순서가 변경될 때 문제가 생길 수 있음", "성능이 느려짐", "key는 문자열만 가능함"],
      "correctAnswer": 1,
      "explanation": "항목의 순서가 변경되거나 추가/삭제될 때 인덱스를 key로 사용하면 React가 잘못된 항목을 업데이트할 수 있습니다. 고유한 ID를 사용하는 것이 좋습니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "바데부가 사용자 목록을 렌더링하고 있습니다. 다음 중 올바른 map 사용법은?",
      "options": ["users.map(user => <User user={user} />)", "users.map(user => <User key={user.id} user={user} />)", "users.forEach(user => <User user={user} />)", "users.map(<User />)"],
      "correctAnswer": 1,
      "explanation": "map 함수는 각 항목을 컴포넌트로 변환하며, 반드시 key prop을 포함해야 합니다. forEach는 값을 반환하지 않아 렌더링에 사용할 수 없습니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "바데부가 컴포넌트가 마운트될 때 API를 호출하려고 합니다. 사용해야 하는 Hook은?",
      "options": ["useState", "useEffect", "useCallback", "useMemo"],
      "correctAnswer": 1,
      "explanation": "useEffect는 컴포넌트의 생명주기와 부수 효과(side effects)를 처리합니다. 마운트, 업데이트, 언마운트 시점에 코드를 실행할 수 있습니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "바데부가 useEffect를 컴포넌트 마운트 시 한 번만 실행하려고 합니다. 두 번째 인자로 전달해야 하는 것은?",
      "options": ["[0]", "[]", "[1]", "null"],
      "correctAnswer": 1,
      "explanation": "빈 배열 []을 의존성 배열로 전달하면 useEffect는 컴포넌트가 마운트될 때 한 번만 실행됩니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "바데부가 count 상태가 변경될 때마다 useEffect를 실행하려고 합니다. 올바른 작성법은?",
      "options": ["useEffect(() => {...})", "useEffect(() => {...}, [])", "useEffect(() => {...}, [count])", "useEffect(() => {...}, count)"],
      "correctAnswer": 2,
      "explanation": "의존성 배열에 count를 포함하면, count가 변경될 때마다 useEffect가 실행됩니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "바데부가 컴포넌트가 언마운트될 때 타이머를 정리하려고 합니다. useEffect에서 정리 함수를 반환하는 방법은?",
      "options": ["useEffect(() => { return cleanup() })", "useEffect(() => { return () => cleanup() })", "useEffect(() => {}, cleanup)", "useEffect(cleanup)"],
      "correctAnswer": 1,
      "explanation": "useEffect에서 함수를 반환하면 컴포넌트가 언마운트되거나 다음 effect가 실행되기 전에 정리 작업이 수행됩니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "바데부가 useEffect 내에서 async/await를 사용하려고 합니다. 올바른 방법은?",
      "options": ["useEffect(async () => {...})", "useEffect(() => { async function fetchData() {...}; fetchData() })", "useEffect(() => await fetch())", "useEffect를 사용할 수 없음"],
      "correctAnswer": 1,
      "explanation": "useEffect의 콜백 함수는 async로 만들 수 없습니다. 내부에 별도의 async 함수를 선언하고 호출해야 합니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "바데부가 React 앱에 라우팅을 추가하려고 합니다. 가장 많이 사용되는 라우팅 라이브러리는?",
      "options": ["react-navigation", "react-router-dom", "next-router", "react-route"],
      "correctAnswer": 1,
      "explanation": "react-router-dom은 React 웹 애플리케이션에서 가장 널리 사용되는 라우팅 라이브러리입니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "바데부가 React Router를 설정하고 있습니다. 전체 앱을 감싸야 하는 컴포넌트는?",
      "options": ["<Router>", "<BrowserRouter>", "<Routes>", "<Route>"],
      "correctAnswer": 1,
      "explanation": "BrowserRouter는 HTML5 히스토리 API를 사용하여 라우팅을 제공하며, 앱의 최상위에서 전체를 감싸야 합니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "바데부가 '/about' 경로에 About 컴포넌트를 연결하려고 합니다. 올바른 Route 작성법은?",
      "options": ["<Route path='/about' component={About} />", "<Route path='/about' element={<About />} />", "<Route url='/about' component={About} />", "<Route to='/about'><About /></Route>"],
      "correctAnswer": 1,
      "explanation": "React Router v6에서는 element prop을 사용하여 컴포넌트를 JSX 형태로 전달합니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "바데부가 프로그래밍 방식으로 다른 페이지로 이동하려고 합니다. 사용해야 하는 Hook은?",
      "options": ["useHistory", "useNavigate", "useRouter", "useRedirect"],
      "correctAnswer": 1,
      "explanation": "React Router v6에서는 useNavigate Hook을 사용하여 프로그래밍 방식으로 페이지를 이동할 수 있습니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "바데부가 URL 파라미터를 읽으려고 합니다. '/user/:id' 경로에서 id를 가져오는 Hook은?",
      "options": ["useParams", "useQuery", "useLocation", "useMatch"],
      "correctAnswer": 0,
      "explanation": "useParams Hook은 URL 파라미터를 객체 형태로 반환합니다. const { id } = useParams()와 같이 사용합니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "바데부가 깊이 중첩된 컴포넌트에 데이터를 전달하려고 합니다. Props drilling 없이 데이터를 공유하는 방법은?",
      "options": ["Redux", "Context API", "Local Storage", "useState"],
      "correctAnswer": 1,
      "explanation": "Context API는 props를 일일이 전달하지 않고도 컴포넌트 트리 전체에 데이터를 공유할 수 있는 React의 내장 기능입니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "바데부가 새로운 Context를 생성하려고 합니다. 사용해야 하는 함수는?",
      "options": ["React.newContext()", "React.createContext()", "React.useContext()", "React.Context()"],
      "correctAnswer": 1,
      "explanation": "React.createContext()를 사용하여 새로운 Context 객체를 생성합니다. 기본값을 인자로 전달할 수 있습니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "바데부가 Context 값을 제공하려고 합니다. 사용해야 하는 컴포넌트는?",
      "options": ["<Context.Provider>", "<Context.Consumer>", "<Context.Value>", "<Context.Wrapper>"],
      "correctAnswer": 0,
      "explanation": "Context.Provider 컴포넌트는 value prop을 통해 하위 컴포넌트들에게 Context 값을 제공합니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "바데부가 함수형 컴포넌트에서 Context 값을 사용하려고 합니다. 사용해야 하는 Hook은?",
      "options": ["useState", "useEffect", "useContext", "useProvider"],
      "correctAnswer": 2,
      "explanation": "useContext Hook을 사용하여 Context 값을 읽을 수 있습니다. const value = useContext(MyContext)와 같이 사용합니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "바데부가 전역 상태 관리를 구현하고 있습니다. Context API를 사용할 때 주의할 점은?",
      "options": ["모든 상태를 하나의 Context에 넣기", "자주 변경되는 값과 그렇지 않은 값을 분리하기", "Provider를 여러 개 사용하지 않기", "useContext는 한 번만 사용하기"],
      "correctAnswer": 1,
      "explanation": "Context 값이 변경되면 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다. 성능을 위해 관련 상태끼리 분리하는 것이 좋습니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": "바데부가 프로젝트를 배포하려고 합니다. create-react-app 프로젝트를 빌드하는 명령어는?",
      "options": ["npm run build", "npm deploy", "npm compile", "npm production"],
      "correctAnswer": 0,
      "explanation": "npm run build 명령어는 최적화된 프로덕션 빌드를 생성합니다. build 폴더에 정적 파일들이 생성됩니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "바데부가 컴포넌트 리렌더링을 최적화하려고 합니다. 컴포넌트를 메모이제이션하는 Hook은?",
      "options": ["useMemo", "useCallback", "React.memo", "useEffect"],
      "correctAnswer": 2,
      "explanation": "React.memo는 고차 컴포넌트로, props가 변경되지 않으면 컴포넌트를 리렌더링하지 않습니다. 성능 최적화에 유용합니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "바데부가 무거운 계산을 최적화하려고 합니다. 계산 결과를 메모이제이션하는 Hook은?",
      "options": ["useCallback", "useMemo", "useEffect", "useState"],
      "correctAnswer": 1,
      "explanation": "useMemo는 계산 비용이 높은 함수의 결과를 메모이제이션합니다. 의존성이 변경될 때만 다시 계산합니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "바데부가 함수를 메모이제이션하려고 합니다. 함수 재생성을 방지하는 Hook은?",
      "options": ["useMemo", "useCallback", "useEffect", "React.memo"],
      "correctAnswer": 1,
      "explanation": "useCallback은 함수를 메모이제이션하여, 의존성이 변경되지 않으면 같은 함수 참조를 유지합니다. 자식 컴포넌트에 함수를 전달할 때 유용합니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 React 프로젝트의 모범 사례를 정리하고 있습니다. 다음 중 올바른 관행이 아닌 것은?",
      "options": ["컴포넌트는 작고 재사용 가능하게 만들기", "모든 상태를 전역으로 관리하기", "의미 있는 컴포넌트 이름 사용하기", "폴더 구조를 일관성 있게 유지하기"],
      "correctAnswer": 1,
      "explanation": "모든 상태를 전역으로 관리하면 불필요한 리렌더링이 발생하고 복잡도가 증가합니다. 필요한 곳에서만 지역 상태를 사용하고, 공유가 필요한 상태만 전역으로 관리해야 합니다."
    }
  ]
}
