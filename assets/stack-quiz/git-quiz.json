{
  "quizTitle": "Git 기초 마스터 퀴즈",
  "quizDescription": "바데부와 함께하는 Git 기초 완벽 정복! 10개 챕터의 핵심 내용을 확인하세요.",
  "totalQuestions": 50,
  "questions": [
    {
      "id": 1,
      "chapter": 1,
      "question": "Git은 어떤 종류의 버전 관리 시스템인가요?",
      "options": [
        "중앙 집중식 버전 관리 시스템",
        "분산 버전 관리 시스템",
        "클라우드 기반 버전 관리 시스템",
        "로컬 전용 버전 관리 시스템"
      ],
      "correctAnswer": 1,
      "explanation": "Git은 분산 버전 관리 시스템(Distributed Version Control System)입니다. 각 개발자가 전체 저장소의 복사본을 가지고 있어 인터넷 없이도 작업할 수 있습니다."
    },
    {
      "id": 2,
      "chapter": 1,
      "question": "Git을 설치한 후 가장 먼저 설정해야 하는 것은?",
      "options": [
        "원격 저장소 연결",
        "브랜치 생성",
        "사용자 이름과 이메일",
        "에디터 설정"
      ],
      "correctAnswer": 2,
      "explanation": "Git을 설치한 후에는 'git config --global user.name'과 'git config --global user.email'로 사용자 정보를 설정해야 합니다. 이 정보는 모든 커밋에 기록됩니다."
    },
    {
      "id": 3,
      "chapter": 1,
      "question": "'.git' 폴더의 역할은 무엇인가요?",
      "options": [
        "프로젝트 파일을 저장하는 폴더",
        "Git의 모든 이력과 메타데이터를 저장하는 폴더",
        "임시 파일을 저장하는 폴더",
        "무시할 파일 목록을 저장하는 폴더"
      ],
      "correctAnswer": 1,
      "explanation": ".git 폴더는 Git 저장소의 핵심으로, 모든 커밋 이력, 브랜치 정보, 설정 등을 저장합니다. 이 폴더를 삭제하면 Git 이력이 모두 사라집니다."
    },
    {
      "id": 4,
      "chapter": 1,
      "question": "Git 설정의 우선순위는 어떻게 되나요?",
      "options": [
        "system > global > local",
        "global > local > system",
        "local > global > system",
        "local > system > global"
      ],
      "correctAnswer": 2,
      "explanation": "Git 설정의 우선순위는 local(저장소별) > global(사용자별) > system(시스템 전체) 순입니다. 더 구체적인 설정이 우선됩니다."
    },
    {
      "id": 5,
      "chapter": 1,
      "question": "Git의 도움말을 보는 명령어는?",
      "options": [
        "git info",
        "git manual",
        "git help",
        "git docs"
      ],
      "correctAnswer": 2,
      "explanation": "'git help' 또는 'git help <명령어>'로 도움말을 볼 수 있습니다. 예: 'git help commit'은 commit 명령어의 상세한 설명을 보여줍니다."
    },
    {
      "id": 6,
      "chapter": 2,
      "question": "새로운 Git 저장소를 초기화하는 명령어는?",
      "options": [
        "git start",
        "git create",
        "git init",
        "git new"
      ],
      "correctAnswer": 2,
      "explanation": "'git init'은 현재 디렉토리를 Git 저장소로 초기화합니다. .git 폴더가 생성되며 Git으로 버전 관리를 시작할 수 있습니다."
    },
    {
      "id": 7,
      "chapter": 2,
      "question": "Git의 세 가지 영역을 올바른 순서로 나열한 것은?",
      "options": [
        "준비 영역 → 작업 디렉토리 → 저장소",
        "작업 디렉토리 → 저장소 → 준비 영역",
        "작업 디렉토리 → 준비 영역 → 저장소",
        "저장소 → 작업 디렉토리 → 준비 영역"
      ],
      "correctAnswer": 2,
      "explanation": "Git의 작업 흐름은 작업 디렉토리(Working Directory)에서 파일을 수정하고, git add로 준비 영역(Staging Area)에 추가한 후, git commit으로 저장소(Repository)에 기록합니다."
    },
    {
      "id": 8,
      "chapter": 2,
      "question": "현재 저장소의 상태를 확인하는 명령어는?",
      "options": [
        "git state",
        "git status",
        "git check",
        "git info"
      ],
      "correctAnswer": 1,
      "explanation": "'git status'는 현재 브랜치, 수정된 파일, 추적되지 않는 파일 등 저장소의 상태를 보여줍니다. Git을 사용할 때 가장 자주 쓰는 명령어입니다."
    },
    {
      "id": 9,
      "chapter": 2,
      "question": "좋은 커밋 메시지의 조건이 아닌 것은?",
      "options": [
        "무엇을 변경했는지 명확히 작성",
        "'수정', 'asdf' 같은 모호한 메시지",
        "동사로 시작하는 명령형 작성",
        "50자 이내로 간결하게 작성"
      ],
      "correctAnswer": 1,
      "explanation": "좋은 커밋 메시지는 명확하고 구체적이어야 합니다. '수정', 'asdf' 같은 모호한 메시지는 나중에 커밋 히스토리를 이해하기 어렵게 만듭니다."
    },
    {
      "id": 10,
      "chapter": 2,
      "question": ".gitignore 파일의 역할은?",
      "options": [
        "중요한 파일을 숨기는 파일",
        "Git이 추적하지 않을 파일을 지정하는 파일",
        "Git 설정을 저장하는 파일",
        "커밋 메시지 템플릿 파일"
      ],
      "correctAnswer": 1,
      "explanation": ".gitignore 파일은 Git이 추적하지 않을 파일이나 폴더를 지정합니다. 환경 변수, 빌드 결과물, 임시 파일 등을 무시할 때 사용합니다."
    },
    {
      "id": 11,
      "chapter": 3,
      "question": "새로운 브랜치를 생성하고 동시에 이동하는 명령어는?",
      "options": [
        "git branch -m <이름>",
        "git checkout -b <이름>",
        "git branch -c <이름>",
        "git create-branch <이름>"
      ],
      "correctAnswer": 1,
      "explanation": "'git checkout -b <브랜치명>' 또는 'git switch -c <브랜치명>'으로 브랜치를 생성하고 동시에 이동할 수 있습니다. 이는 'git branch'와 'git checkout'을 연속으로 실행하는 것과 같습니다."
    },
    {
      "id": 12,
      "chapter": 3,
      "question": "브랜치를 사용하는 주된 이유가 아닌 것은?",
      "options": [
        "독립적인 작업 공간 제공",
        "실험적 기능을 안전하게 개발",
        "저장소 크기 줄이기",
        "여러 기능을 동시에 개발"
      ],
      "correctAnswer": 2,
      "explanation": "브랜치는 저장소 크기와 무관합니다. 브랜치의 주 목적은 독립적인 작업 공간을 제공하여 안전하게 기능을 개발하고, 여러 작업을 동시에 진행할 수 있게 하는 것입니다."
    },
    {
      "id": 13,
      "chapter": 3,
      "question": "Fast-Forward 병합이 발생하는 경우는?",
      "options": [
        "두 브랜치가 서로 다른 커밋을 가질 때",
        "현재 브랜치가 병합할 브랜치의 조상일 때",
        "충돌이 발생했을 때",
        "브랜치를 삭제할 때"
      ],
      "correctAnswer": 1,
      "explanation": "Fast-Forward 병합은 현재 브랜치가 병합할 브랜치의 직접적인 조상일 때 발생합니다. 단순히 포인터를 앞으로 이동시키는 방식으로, 새로운 병합 커밋을 만들지 않습니다."
    },
    {
      "id": 14,
      "chapter": 3,
      "question": "브랜치 이름을 짓는 좋은 방법은?",
      "options": [
        "test, temp 같은 임시 이름",
        "feature/login-form 같은 명확한 이름",
        "branch1, branch2 같은 번호",
        "한글로 상세하게 작성"
      ],
      "correctAnswer": 1,
      "explanation": "브랜치 이름은 'feature/', 'bugfix/', 'hotfix/' 같은 접두사와 함께 명확한 목적을 나타내야 합니다. 예: feature/user-authentication, bugfix/login-error"
    },
    {
      "id": 15,
      "chapter": 3,
      "question": "병합이 완료된 브랜치를 삭제하는 명령어는?",
      "options": [
        "git branch -d <브랜치명>",
        "git remove <브랜치명>",
        "git delete <브랜치명>",
        "git branch --remove <브랜치명>"
      ],
      "correctAnswer": 0,
      "explanation": "'git branch -d <브랜치명>'으로 병합된 브랜치를 안전하게 삭제할 수 있습니다. 병합되지 않은 브랜치는 -D 옵션을 사용해야 강제 삭제됩니다."
    },
    {
      "id": 16,
      "chapter": 4,
      "question": "'origin'은 무엇을 의미하나요?",
      "options": [
        "원본 저장소의 브랜치",
        "원격 저장소의 기본 별명",
        "첫 번째 커밋",
        "메인 브랜치의 별명"
      ],
      "correctAnswer": 1,
      "explanation": "'origin'은 원격 저장소의 기본 별명입니다. git clone으로 저장소를 복제하면 자동으로 원격 저장소가 origin이라는 이름으로 등록됩니다."
    },
    {
      "id": 17,
      "chapter": 4,
      "question": "git push와 git pull의 차이점은?",
      "options": [
        "push는 업로드, pull은 다운로드",
        "push는 브랜치 생성, pull은 브랜치 삭제",
        "push는 병합, pull은 리베이스",
        "차이가 없음"
      ],
      "correctAnswer": 0,
      "explanation": "'git push'는 로컬의 변경사항을 원격 저장소에 업로드하고, 'git pull'은 원격 저장소의 변경사항을 다운로드하여 로컬에 병합합니다."
    },
    {
      "id": 18,
      "chapter": 4,
      "question": "git clone 명령어의 역할은?",
      "options": [
        "원격 저장소를 로컬로 복제",
        "커밋을 복제",
        "브랜치를 복제",
        "파일을 복제"
      ],
      "correctAnswer": 0,
      "explanation": "'git clone <URL>'은 원격 저장소의 전체 내용(모든 파일, 커밋 히스토리, 브랜치)을 로컬 컴퓨터로 복제합니다. 프로젝트에 처음 참여할 때 한 번만 실행합니다."
    },
    {
      "id": 19,
      "chapter": 4,
      "question": "SSH 키를 사용하는 장점은?",
      "options": [
        "더 빠른 속도",
        "매번 비밀번호를 입력하지 않아도 됨",
        "저장소 크기 감소",
        "더 많은 파일 업로드 가능"
      ],
      "correctAnswer": 1,
      "explanation": "SSH 키를 설정하면 원격 저장소에 접근할 때마다 비밀번호를 입력할 필요가 없습니다. 한 번 설정으로 자동 인증되어 편리하고 안전합니다."
    },
    {
      "id": 20,
      "chapter": 4,
      "question": "git fetch와 git pull의 차이점은?",
      "options": [
        "fetch는 다운로드만, pull은 다운로드 + 병합",
        "fetch는 업로드, pull은 다운로드",
        "차이가 없음",
        "fetch는 빠르고 pull은 느림"
      ],
      "correctAnswer": 0,
      "explanation": "'git fetch'는 원격의 변경사항을 다운로드만 하고, 'git pull'은 다운로드 후 자동으로 현재 브랜치에 병합합니다. pull = fetch + merge 입니다."
    },
    {
      "id": 21,
      "chapter": 5,
      "question": "Git에서 충돌(Conflict)이 발생하는 이유는?",
      "options": [
        "인터넷 연결이 끊겼을 때",
        "같은 파일의 같은 부분을 다르게 수정했을 때",
        "너무 많은 파일을 커밋했을 때",
        "브랜치 이름이 중복될 때"
      ],
      "correctAnswer": 1,
      "explanation": "충돌은 두 브랜치에서 같은 파일의 같은 부분을 서로 다르게 수정했을 때 발생합니다. Git이 어떤 버전을 선택해야 할지 알 수 없어 사용자에게 결정을 요청합니다."
    },
    {
      "id": 22,
      "chapter": 5,
      "question": "충돌 마커 중 '======='의 의미는?",
      "options": [
        "충돌의 시작",
        "현재 브랜치와 병합 브랜치의 구분선",
        "충돌의 끝",
        "삭제된 부분"
      ],
      "correctAnswer": 1,
      "explanation": "'======='는 충돌하는 두 버전을 구분하는 선입니다. 위쪽(<<<<<<< HEAD)은 현재 브랜치의 내용이고, 아래쪽(>>>>>>> 브랜치명)은 병합하려는 브랜치의 내용입니다."
    },
    {
      "id": 23,
      "chapter": 5,
      "question": "충돌을 해결한 후 다음 단계는?",
      "options": [
        "git push",
        "git add → git commit",
        "git merge --continue",
        "git conflict --resolve"
      ],
      "correctAnswer": 1,
      "explanation": "충돌을 해결한 후에는 'git add'로 해결된 파일을 추가하고 'git commit'으로 병합을 완료합니다. 커밋 메시지는 자동으로 생성되지만 수정할 수도 있습니다."
    },
    {
      "id": 24,
      "chapter": 5,
      "question": "충돌을 예방하는 가장 좋은 방법은?",
      "options": [
        "절대 같은 파일을 수정하지 않기",
        "자주 pull하여 최신 상태 유지",
        "브랜치를 사용하지 않기",
        "커밋을 하지 않기"
      ],
      "correctAnswer": 1,
      "explanation": "자주 pull하여 원격 저장소의 최신 변경사항을 받아오면 충돌이 작아지고 해결하기 쉬워집니다. 큰 충돌보다 작은 충돌이 여러 번 발생하는 것이 관리하기 쉽습니다."
    },
    {
      "id": 25,
      "chapter": 5,
      "question": "병합을 취소하고 싶을 때 사용하는 명령어는?",
      "options": [
        "git merge --cancel",
        "git merge --abort",
        "git cancel merge",
        "git undo merge"
      ],
      "correctAnswer": 1,
      "explanation": "'git merge --abort'는 병합을 취소하고 병합 전 상태로 돌아갑니다. 충돌 해결이 너무 복잡하거나 실수했을 때 사용할 수 있습니다."
    },
    {
      "id": 26,
      "chapter": 6,
      "question": "커밋 히스토리를 한 줄로 간단하게 보는 명령어는?",
      "options": [
        "git log --simple",
        "git log --oneline",
        "git log --short",
        "git log -1"
      ],
      "correctAnswer": 1,
      "explanation": "'git log --oneline'은 각 커밋을 짧은 해시와 메시지로 한 줄씩 표시합니다. 히스토리를 빠르게 훑어볼 때 유용합니다."
    },
    {
      "id": 27,
      "chapter": 6,
      "question": "git diff 명령어의 역할은?",
      "options": [
        "브랜치 간 차이 보기",
        "변경사항의 차이 보기",
        "둘 다",
        "둘 다 아님"
      ],
      "correctAnswer": 2,
      "explanation": "'git diff'는 다양한 버전 간의 차이를 보여줍니다. 작업 디렉토리와 준비 영역, 커밋 간, 브랜치 간의 차이를 모두 확인할 수 있습니다."
    },
    {
      "id": 28,
      "chapter": 6,
      "question": "git blame의 주된 용도는?",
      "options": [
        "잘못된 코드를 찾기",
        "각 줄을 누가 언제 수정했는지 추적",
        "버그를 자동으로 수정",
        "코드 품질 검사"
      ],
      "correctAnswer": 1,
      "explanation": "'git blame <파일명>'은 파일의 각 줄이 누구에 의해 언제 마지막으로 수정되었는지 보여줍니다. 코드의 맥락을 이해하거나 버그의 원인을 찾을 때 유용합니다."
    },
    {
      "id": 29,
      "chapter": 6,
      "question": "특정 작성자의 커밋만 보려면?",
      "options": [
        "git log --author='이름'",
        "git log --user='이름'",
        "git log --name='이름'",
        "git log --person='이름'"
      ],
      "correctAnswer": 0,
      "explanation": "'git log --author=\"이름\"'으로 특정 작성자의 커밋만 필터링할 수 있습니다. 팀에서 특정 멤버의 작업 내역을 확인할 때 유용합니다."
    },
    {
      "id": 30,
      "chapter": 6,
      "question": "커밋 메시지에서 특정 키워드를 검색하려면?",
      "options": [
        "git log --search='키워드'",
        "git log --grep='키워드'",
        "git log --find='키워드'",
        "git log --keyword='키워드'"
      ],
      "correctAnswer": 1,
      "explanation": "'git log --grep=\"키워드\"'로 커밋 메시지에서 특정 키워드를 검색할 수 있습니다. 예를 들어 --grep=\"버그\"로 버그 수정 관련 커밋을 찾을 수 있습니다."
    },
    {
      "id": 31,
      "chapter": 7,
      "question": "파일 수정을 취소하고 마지막 커밋 상태로 되돌리려면?",
      "options": [
        "git restore <파일>",
        "git undo <파일>",
        "git revert <파일>",
        "git cancel <파일>"
      ],
      "correctAnswer": 0,
      "explanation": "'git restore <파일>'은 작업 디렉토리의 변경사항을 취소하고 마지막 커밋 상태로 되돌립니다. 주의: 이 작업은 되돌릴 수 없습니다."
    },
    {
      "id": 32,
      "chapter": 7,
      "question": "git reset의 세 가지 모드 중 가장 위험한 것은?",
      "options": [
        "--soft",
        "--mixed",
        "--hard",
        "모두 안전함"
      ],
      "correctAnswer": 2,
      "explanation": "'--hard'는 커밋, add, 파일 변경사항을 모두 삭제합니다. 복구가 불가능하므로 신중하게 사용해야 합니다. --soft나 --mixed가 더 안전합니다."
    },
    {
      "id": 33,
      "chapter": 7,
      "question": "reset과 revert의 주요 차이점은?",
      "options": [
        "reset은 히스토리 수정, revert는 히스토리 유지",
        "reset은 느리고 revert는 빠름",
        "reset은 원격용, revert는 로컬용",
        "차이가 없음"
      ],
      "correctAnswer": 0,
      "explanation": "reset은 커밋 히스토리를 삭제하는 반면, revert는 새로운 커밋으로 변경사항을 되돌립니다. push한 커밋은 revert를 사용해야 팀원들에게 문제가 없습니다."
    },
    {
      "id": 34,
      "chapter": 7,
      "question": "직전 커밋 메시지를 수정하려면?",
      "options": [
        "git commit --edit",
        "git commit --amend",
        "git commit --modify",
        "git commit --change"
      ],
      "correctAnswer": 1,
      "explanation": "'git commit --amend'로 직전 커밋의 메시지를 수정하거나 파일을 추가할 수 있습니다. 주의: 이미 push한 커밋에는 사용하지 말아야 합니다."
    },
    {
      "id": 35,
      "chapter": 7,
      "question": "실수로 삭제한 커밋을 복구할 수 있는 명령어는?",
      "options": [
        "git recover",
        "git reflog",
        "git restore",
        "git backup"
      ],
      "correctAnswer": 1,
      "explanation": "'git reflog'는 HEAD의 모든 이동 기록을 보여줍니다. 실수로 reset --hard로 삭제한 커밋도 reflog에서 찾아 복구할 수 있습니다."
    },
    {
      "id": 36,
      "chapter": 8,
      "question": "git stash의 주요 용도는?",
      "options": [
        "커밋 저장",
        "현재 작업을 임시로 저장",
        "브랜치 백업",
        "원격 저장소 동기화"
      ],
      "correctAnswer": 1,
      "explanation": "'git stash'는 현재 작업 중인 변경사항을 임시로 저장하고 작업 디렉토리를 깨끗하게 만듭니다. 다른 작업을 한 후 다시 꺼내서 이어갈 수 있습니다."
    },
    {
      "id": 37,
      "chapter": 8,
      "question": "stash를 적용하면서 동시에 삭제하는 명령어는?",
      "options": [
        "git stash apply",
        "git stash pop",
        "git stash drop",
        "git stash remove"
      ],
      "correctAnswer": 1,
      "explanation": "'git stash pop'은 가장 최근의 stash를 적용하고 stash 목록에서 제거합니다. 'git stash apply'는 적용만 하고 목록에 남겨둡니다."
    },
    {
      "id": 38,
      "chapter": 8,
      "question": "새로 만든 파일(untracked)도 stash하려면?",
      "options": [
        "git stash",
        "git stash -u",
        "git stash -a",
        "git stash --new"
      ],
      "correctAnswer": 1,
      "explanation": "'git stash -u' 또는 'git stash --include-untracked'로 추적되지 않는 새 파일도 함께 stash할 수 있습니다. 기본 stash는 추적 중인 파일만 저장합니다."
    },
    {
      "id": 39,
      "chapter": 8,
      "question": "stash 목록을 확인하는 명령어는?",
      "options": [
        "git stash show",
        "git stash status",
        "git stash list",
        "git stash all"
      ],
      "correctAnswer": 2,
      "explanation": "'git stash list'는 저장된 모든 stash를 보여줍니다. 각 stash는 stash@{0}, stash@{1} 등의 이름으로 관리됩니다."
    },
    {
      "id": 40,
      "chapter": 8,
      "question": "stash를 브랜치로 만들려면?",
      "options": [
        "git stash branch <브랜치명>",
        "git branch --stash <브랜치명>",
        "git create-branch --from-stash <브랜치명>",
        "불가능함"
      ],
      "correctAnswer": 0,
      "explanation": "'git stash branch <브랜치명>'으로 stash를 새 브랜치로 만들 수 있습니다. stash를 적용할 때 충돌이 발생하면 이 방법이 유용합니다."
    },
    {
      "id": 41,
      "chapter": 9,
      "question": "Gitflow에서 일반적인 개발이 이루어지는 브랜치는?",
      "options": [
        "main",
        "develop",
        "feature",
        "release"
      ],
      "correctAnswer": 1,
      "explanation": "Gitflow에서 develop 브랜치는 개발 중인 코드가 있는 곳입니다. feature 브랜치는 develop에서 분기하고 다시 develop으로 병합됩니다."
    },
    {
      "id": 42,
      "chapter": 9,
      "question": "Pull Request(PR)의 주된 목적은?",
      "options": [
        "코드를 다운로드",
        "코드 리뷰와 병합 요청",
        "브랜치 생성",
        "커밋 취소"
      ],
      "correctAnswer": 1,
      "explanation": "Pull Request는 자신의 변경사항을 검토받고 메인 브랜치에 병합해달라고 요청하는 것입니다. 팀원들이 코드를 리뷰하고 피드백을 주고받을 수 있습니다."
    },
    {
      "id": 43,
      "chapter": 9,
      "question": "좋은 PR의 특징이 아닌 것은?",
      "options": [
        "작은 단위의 변경사항",
        "명확한 설명",
        "500줄 이상의 대규모 변경",
        "테스트 포함"
      ],
      "correctAnswer": 2,
      "explanation": "좋은 PR은 작고 집중된 변경사항을 담아야 합니다. 너무 큰 PR은 리뷰하기 어렵고 버그를 발견하기도 힘듭니다. 가능하면 100-200줄 이내로 유지하는 것이 좋습니다."
    },
    {
      "id": 44,
      "chapter": 9,
      "question": "커밋 메시지의 타입 중 새로운 기능을 나타내는 것은?",
      "options": [
        "fix",
        "feat",
        "docs",
        "chore"
      ],
      "correctAnswer": 1,
      "explanation": "'feat'는 새로운 기능 추가를 의미합니다. 예: 'feat: 사용자 로그인 기능 추가'. 다른 타입으로는 fix(버그 수정), docs(문서), chore(기타) 등이 있습니다."
    },
    {
      "id": 45,
      "chapter": 9,
      "question": "Forking Workflow가 주로 사용되는 곳은?",
      "options": [
        "회사 내부 프로젝트",
        "오픈소스 프로젝트",
        "개인 프로젝트",
        "소규모 팀"
      ],
      "correctAnswer": 1,
      "explanation": "Forking Workflow는 오픈소스 프로젝트에서 주로 사용됩니다. 기여자가 원본 저장소를 fork하여 작업하고, Pull Request로 기여하는 방식입니다."
    },
    {
      "id": 46,
      "chapter": 10,
      "question": ".env 파일을 실수로 커밋했을 때 가장 먼저 해야 할 일은?",
      "options": [
        "git push 하기",
        ".gitignore에 추가하고 키/비밀번호 즉시 변경",
        "저장소 삭제",
        "아무것도 안 함"
      ],
      "correctAnswer": 1,
      "explanation": "비밀 정보가 커밋되면 즉시 .gitignore에 추가하고, 노출된 키나 비밀번호를 변경해야 합니다. 이미 push했다면 저장소가 공개되어 있는 경우 더욱 긴급합니다."
    },
    {
      "id": 47,
      "chapter": 10,
      "question": "Git Hooks의 용도는?",
      "options": [
        "브랜치 자동 생성",
        "특정 Git 이벤트 시 자동으로 스크립트 실행",
        "커밋 자동 병합",
        "원격 저장소 자동 동기화"
      ],
      "correctAnswer": 1,
      "explanation": "Git Hooks는 커밋, 푸시 등의 Git 이벤트가 발생할 때 자동으로 스크립트를 실행합니다. 예를 들어 pre-commit hook으로 커밋 전 자동으로 테스트나 린터를 실행할 수 있습니다."
    },
    {
      "id": 48,
      "chapter": 10,
      "question": "대용량 파일을 Git으로 관리하기 위한 도구는?",
      "options": [
        "Git Large",
        "Git LFS",
        "Git Big",
        "Git Storage"
      ],
      "correctAnswer": 1,
      "explanation": "Git LFS(Large File Storage)는 대용량 파일(이미지, 비디오, 데이터셋 등)을 효율적으로 관리하기 위한 Git 확장 도구입니다."
    },
    {
      "id": 49,
      "chapter": 10,
      "question": "git config의 alias 기능은 무엇을 위한 것인가요?",
      "options": [
        "브랜치 이름 변경",
        "자주 쓰는 명령어에 짧은 별명 만들기",
        "사용자 이름 변경",
        "저장소 이름 변경"
      ],
      "correctAnswer": 1,
      "explanation": "alias는 긴 Git 명령어에 짧은 별명을 만들어 줍니다. 예: 'git config --global alias.st status'로 설정하면 'git st'로 'git status'를 실행할 수 있습니다."
    },
    {
      "id": 50,
      "chapter": 10,
      "question": "바데부가 강조하는 가장 중요한 Git 습관은?",
      "options": [
        "하루에 한 번만 커밋하기",
        "자주 커밋하고 의미 있는 메시지 작성하기",
        "main 브랜치에 직접 커밋하기",
        "커밋을 최대한 크게 만들기"
      ],
      "correctAnswer": 1,
      "explanation": "자주 커밋하고 명확한 메시지를 작성하는 것이 가장 중요합니다. 작은 단위로 자주 커밋하면 문제 발생 시 되돌리기 쉽고, 명확한 메시지는 나중에 히스토리를 이해하는 데 도움이 됩니다."
    }
  ]
}
