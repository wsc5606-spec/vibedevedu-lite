{
  "language": "kotlin",
  "chapters": [
    {
      "chapterId": 1,
      "title": "1단원: 출력과 주석",
      "content": "# 1단원: 출력과 주석\n\n## Kotlin이란?\n\nKotlin은 JetBrains에서 개발한 현대적인 프로그래밍 언어로, JVM(Java Virtual Machine)에서 실행됩니다. Java와 100% 호환되며, Android 공식 개발 언어로 채택되었습니다. 간결하고 안전한 코드 작성을 지향합니다.\n\n## 기본 프로그램 구조\n\n### 가장 간단한 프로그램\n\n```kotlin\nfun main() {\n    println(\"Hello, Kotlin!\")\n}\n```\n\n- `fun`: 함수 선언 키워드\n- `main()`: 프로그램 진입점\n- `println()`: 출력 후 줄바꿈\n- 세미콜론(;) 생략 가능\n\n### 매개변수가 있는 main 함수\n\n```kotlin\nfun main(args: Array<String>) {\n    println(\"Hello, Kotlin!\")\n}\n```\n\n## 콘솔 출력\n\n### println()과 print()\n\n- `println()`: 출력 후 줄바꿈\n- `print()`: 줄바꿈 없이 출력\n\n### 문자열 템플릿 (String Template)\n\nKotlin의 강력한 문자열 기능입니다.\n\n```kotlin\nval name = \"홍길동\"\nval age = 25\n\nprintln(\"이름: $name\")\nprintln(\"나이: $age세\")\nprintln(\"내년 나이: ${age + 1}세\")\n```\n\n**특징:**\n- `$변수명`: 단순 변수 참조\n- `${식}`: 표현식 평가\n- 중괄호는 표현식이나 속성 접근 시 필수\n\n## 주석 (Comments)\n\n### 한 줄 주석\n\n```kotlin\n// 이것은 한 줄 주석입니다\n```\n\n### 여러 줄 주석\n\n```kotlin\n/*\n여러 줄에 걸친\n주석입니다\n*/\n```\n\n### 중첩 가능한 블록 주석\n\nKotlin은 블록 주석 중첩이 가능합니다.\n\n```kotlin\n/*\n외부 주석\n/* 내부 주석 */\n*/\n```\n\n### KDoc (문서 주석)\n\nKotlin의 문서화 도구로, Javadoc과 유사합니다.\n\n```kotlin\n/**\n * 두 수를 더하는 함수\n * @param a 첫 번째 정수\n * @param b 두 번째 정수\n * @return 두 수의 합\n */\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n## Raw String (삼중 따옴표)\n\n이스케이프 문자 없이 문자열을 작성할 수 있습니다.\n\n```kotlin\nval text = \"\"\"\n    첫 번째 줄\n    두 번째 줄\n    세 번째 줄\n\"\"\".trimIndent()\n\nprintln(text)\n```\n\n**특징:**\n- 줄바꿈, 특수문자 그대로 사용\n- `.trimIndent()`: 공통 들여쓰기 제거\n- `.trimMargin()`: 특정 문자 기준 정렬\n\n## 이스케이프 시퀀스\n\n일반 문자열에서 특수 문자를 표현합니다.\n\n- `\\n`: 줄바꿈\n- `\\t`: 탭\n- `\\\"`: 큰따옴표\n- `\\'`: 작은따옴표\n- `\\\\`: 백슬래시\n- `\\$`: 달러 기호 (템플릿 회피)\n\n## 핵심 요약\n\n- **출력**: `println()` (줄바꿈 포함), `print()` (줄바꿈 없음)\n- **문자열 템플릿**: `$변수` 또는 `${식}` 형태로 변수/표현식 삽입\n- **주석**: `//` (한 줄), `/* */` (여러 줄, 중첩 가능), `/** */` (KDoc)\n- **Raw String**: `\"\"\"...\"\"\"` 형태로 여러 줄, 이스케이프 불필요\n- **세미콜론**: 선택적 (대부분 생략)\n- **이스케이프**: `\\n`, `\\t`, `\\$` 등"
    },
    {
      "chapterId": 2,
      "title": "2단원: 변수와 자료형",
      "content": "# 2단원: 변수와 자료형\n\n## 변수 선언\n\nKotlin은 불변성을 강조하는 언어로, `val`과 `var` 두 가지 변수 선언 방식을 제공합니다.\n\n### val (불변 변수)\n\n한 번 할당하면 변경할 수 없습니다.\n\n```kotlin\nval name = \"홍길동\"\nval age = 25\n// age = 26  // 에러! val은 재할당 불가\n```\n\n**특징:**\n- 읽기 전용 (read-only)\n- Java의 `final`과 유사\n- 불변성 권장 (함수형 프로그래밍)\n\n### var (가변 변수)\n\n값을 변경할 수 있습니다.\n\n```kotlin\nvar count = 10\ncount = 20  // 가능\n```\n\n**권장 사항:**\n- 기본적으로 `val` 사용\n- 꼭 필요한 경우에만 `var` 사용\n\n## 타입 추론과 명시\n\n### 타입 추론\n\nKotlin은 초기화 값으로 타입을 자동 추론합니다.\n\n```kotlin\nval num = 10          // Int로 추론\nval text = \"Hello\"    // String으로 추론\nval pi = 3.14         // Double로 추론\n```\n\n### 타입 명시\n\n```kotlin\nval num: Int = 10\nval text: String = \"Hello\"\nval pi: Double = 3.14\n```\n\n### 초기화 지연\n\n타입을 명시하면 나중에 초기화 가능합니다.\n\n```kotlin\nval age: Int\nage = 25  // 나중에 초기화\n```\n\n## 기본 자료형\n\nKotlin은 모든 것이 객체입니다. 원시 타입과 래퍼 타입의 구분이 없습니다.\n\n### 정수형\n\n- `Byte`: -128 ~ 127 (1바이트)\n- `Short`: -32,768 ~ 32,767 (2바이트)\n- `Int`: 약 -21억 ~ 21억 (4바이트) ★ 기본\n- `Long`: 약 -922경 ~ 922경 (8바이트, L 접미사)\n\n```kotlin\nval byte: Byte = 127\nval short: Short = 32000\nval int = 100\nval long = 10000000000L  // L 접미사 필수\n```\n\n### 실수형\n\n- `Float`: 약 7자리 정밀도 (4바이트, f 또는 F 접미사)\n- `Double`: 약 15자리 정밀도 (8바이트) ★ 기본\n\n```kotlin\nval float = 3.14f\nval double = 3.141592\n```\n\n### 문자형\n\n- `Char`: 16비트 유니코드 문자 (작은따옴표)\n\n```kotlin\nval ch: Char = 'A'\nval korean: Char = '한'\n```\n\n### 불린형\n\n- `Boolean`: true 또는 false\n\n```kotlin\nval isStudent = true\nval hasLicense = false\n```\n\n## String (문자열)\n\nKotlin의 문자열은 불변(immutable)입니다.\n\n### 주요 속성과 메서드\n\n- `.length`: 문자열 길이\n- `.toUpperCase()`: 대문자 변환\n- `.toLowerCase()`: 소문자 변환\n- `.contains()`: 포함 여부\n- `.startsWith()`: 시작 문자열 확인\n- `.endsWith()`: 끝 문자열 확인\n- `.substring()`: 부분 문자열\n- `.split()`: 분리\n- `.replace()`: 치환\n- `.trim()`: 공백 제거\n\n## Nullable 타입\n\nKotlin의 가장 중요한 특징 중 하나로, Null 안전성을 제공합니다.\n\n### Non-null 타입 (기본)\n\n```kotlin\nval name: String = \"홍길동\"\n// name = null  // 에러! null 할당 불가\n```\n\n### Nullable 타입 (? 붙임)\n\n```kotlin\nval name: String? = null  // null 가능\nval age: Int? = null\n```\n\n### Safe Call 연산자 (?.)\n\n객체가 null이 아닐 때만 메서드 호출합니다.\n\n```kotlin\nval text: String? = null\nval length = text?.length  // null 반환 (예외 발생 안 함)\n```\n\n### Elvis 연산자 (?:)\n\nnull일 때 기본값을 제공합니다.\n\n```kotlin\nval name: String? = null\nval displayName = name ?: \"이름 없음\"\n```\n\n### Non-null 단언 (!!)\n\nnull이 아님을 확신할 때 사용합니다 (주의 필요).\n\n```kotlin\nval text: String? = \"Hello\"\nval length = text!!.length  // null이면 예외 발생\n```\n\n## 형변환\n\n### 명시적 변환\n\nKotlin은 암시적 형변환이 없습니다. 명시적으로 변환해야 합니다.\n\n```kotlin\nval i: Int = 10\nval l: Long = i.toLong()     // 명시적 변환 필수\nval d: Double = i.toDouble()\n```\n\n### 변환 함수\n\n- `.toByte()`: Byte로 변환\n- `.toShort()`: Short로 변환\n- `.toInt()`: Int로 변환\n- `.toLong()`: Long로 변환\n- `.toFloat()`: Float로 변환\n- `.toDouble()`: Double로 변환\n- `.toChar()`: Char로 변환\n- `.toString()`: String으로 변환\n\n### 문자열 변환\n\n```kotlin\nval str = \"123\"\nval num = str.toInt()           // String → Int\nval numOrNull = str.toIntOrNull()  // 실패 시 null 반환 (안전)\n```\n\n## 상수\n\n### const val\n\n컴파일 타임 상수입니다.\n\n```kotlin\nconst val MAX_COUNT = 100\nconst val PI = 3.14159\n```\n\n**특징:**\n- 최상위 레벨 또는 object 내에서만 선언\n- 기본 타입과 String만 가능\n- 컴파일 시점에 값 결정\n\n## lateinit과 lazy\n\n### lateinit var\n\n나중에 초기화할 변수입니다.\n\n```kotlin\nlate init var name: String\n// 나중에 초기화\nname = \"홍길동\"\n```\n\n**특징:**\n- var에만 사용 가능\n- Nullable 타입 불가\n- 초기화 전 접근 시 예외 발생\n\n### lazy (지연 초기화)\n\n처음 접근할 때 초기화됩니다.\n\n```kotlin\nval data: String by lazy {\n    // 처음 접근 시 실행\n    \"Heavy computation\"\n}\n```\n\n**특징:**\n- val에만 사용\n- 스레드 안전\n- 한 번만 초기화\n\n## 타입 검사와 캐스팅\n\n### is (타입 검사)\n\n```kotlin\nval obj: Any = \"Hello\"\n\nif (obj is String) {\n    // 스마트 캐스트: 자동으로 String으로 취급\n    println(obj.length)\n}\n```\n\n### as (타입 캐스팅)\n\n```kotlin\nval obj: Any = \"Hello\"\nval str = obj as String  // String으로 캐스팅\n```\n\n### as? (안전한 캐스팅)\n\n```kotlin\nval obj: Any = 123\nval str = obj as? String  // 실패 시 null 반환\n```\n\n## 핵심 요약\n\n**변수 선언:**\n- `val`: 불변 (권장)\n- `var`: 가변\n\n**기본 타입:**\n- 정수: Byte, Short, Int ★, Long (L)\n- 실수: Float (f), Double ★\n- 문자: Char\n- 불린: Boolean\n- 문자열: String\n\n**Null 안전성:**\n- Non-null: 기본\n- Nullable: `타입?`\n- Safe call: `?.`\n- Elvis: `?:`\n- Non-null 단언: `!!`\n\n**형변환:**\n- 명시적 변환 필수\n- `.toInt()`, `.toDouble()` 등\n- `.toIntOrNull()`: 안전한 변환\n\n**상수:**\n- `const val`: 컴파일 타임 상수\n\n**지연 초기화:**\n- `lateinit var`: 나중 초기화\n- `by lazy`: 처음 접근 시 초기화\n\n**타입 검사:**\n- `is`: 타입 확인 (스마트 캐스트)\n- `as`: 캐스팅\n- `as?`: 안전한 캐스팅"
    },
    {
      "chapterId": 3,
      "title": "3단원: 연산자와 입력",
      "content": "# 3단원: 연산자와 입력\n\n## 산술 연산자\n\n- `+`: 덧셈\n- `-`: 뺄셈\n- `*`: 곱셈\n- `/`: 나눗셈\n- `%`: 나머지 (모듈로)\n\n**정수 나눗셈:**\n- 정수 / 정수 = 정수 (소수점 버림)\n- 실수 결과 원하면 하나를 Double로 변환\n\n## 복합 대입 연산자\n\n- `+=`: 더한 후 대입\n- `-=`: 뺀 후 대입\n- `*=`: 곱한 후 대입\n- `/=`: 나눈 후 대입\n- `%=`: 나머지 후 대입\n\n## 증감 연산자\n\n- `++`: 1 증가\n- `--`: 1 감소\n\n**전위와 후위:**\n- 전위 (`++x`): 증가 후 값 사용\n- 후위 (`x++`): 값 사용 후 증가\n\n## 비교 연산자\n\n- `==`: 값이 같음\n- `!=`: 값이 다름\n- `>`: 크다\n- `<`: 작다\n- `>=`: 크거나 같다\n- `<=`: 작거나 같다\n- `===`: 참조가 같음 (동일 객체)\n- `!==`: 참조가 다름\n\n**== vs ===:**\n- `==`: 값 비교 (equals)\n- `===`: 참조 비교 (동일 객체)\n\n## 논리 연산자\n\n- `&&`: 논리 AND (둘 다 true)\n- `||`: 논리 OR (하나라도 true)\n- `!`: 논리 NOT (반전)\n\n**단락 평가:**\n- `&&`: 왼쪽이 false면 오른쪽 평가 안 함\n- `||`: 왼쪽이 true면 오른쪽 평가 안 함\n\n## 비트 연산자 (함수 형태)\n\nKotlin은 비트 연산을 함수로 제공합니다.\n\n- `and`: 비트 AND\n- `or`: 비트 OR\n- `xor`: 비트 XOR\n- `inv()`: 비트 NOT (보수)\n- `shl`: 왼쪽 시프트\n- `shr`: 오른쪽 시프트 (부호 유지)\n- `ushr`: 부호 없는 오른쪽 시프트\n\n```kotlin\nval a = 0b1010  // 10\nval b = 0b1100  // 12\nval result = a and b  // 0b1000 = 8\n```\n\n## in 연산자\n\n범위나 컬렉션에 포함되는지 확인합니다.\n\n```kotlin\nval num = 5\nif (num in 1..10) {\n    println(\"1에서 10 사이\")\n}\n\nif (num !in 1..10) {\n    println(\"범위 밖\")\n}\n```\n\n## 범위 연산자\n\n### .. (범위 생성)\n\n```kotlin\nval range = 1..10        // 1부터 10까지 (10 포함)\nval charRange = 'a'..'z' // 'a'부터 'z'까지\n```\n\n### until (끝 제외)\n\n```kotlin\nval range = 1 until 10   // 1부터 9까지 (10 제외)\n```\n\n### downTo (역순)\n\n```kotlin\nval range = 10 downTo 1  // 10부터 1까지 (역순)\n```\n\n### step (간격)\n\n```kotlin\nval range = 1..10 step 2  // 1, 3, 5, 7, 9\n```\n\n## Elvis 연산자 (?:)\n\nnull일 때 기본값을 제공합니다.\n\n```kotlin\nval name: String? = null\nval displayName = name ?: \"이름 없음\"\n```\n\n## 콘솔 입력\n\n### readLine()\n\n한 줄의 문자열을 입력받습니다.\n\n```kotlin\nval input = readLine()  // String? 반환 (null 가능)\n```\n\n**특징:**\n- Nullable 타입 반환 (String?)\n- Enter 키까지 입력\n- null 체크 필요\n\n### 안전한 입력 처리\n\n```kotlin\nval input = readLine() ?: \"\"  // null이면 빈 문자열\n\nval num = readLine()?.toIntOrNull() ?: 0  // 안전한 변환\n```\n\n### readln() (Kotlin 1.6+)\n\nNon-null String을 반환합니다.\n\n```kotlin\nval input = readln()  // String 반환\n```\n\n## 입력값 변환\n\n```kotlin\nval str = readLine() ?: \"\"\n\n// 안전한 변환\nval intValue = str.toIntOrNull() ?: 0\nval doubleValue = str.toDoubleOrNull() ?: 0.0\n\n// 예외 발생 가능\nval num = str.toInt()  // 실패 시 NumberFormatException\n```\n\n## 연산자 오버로딩\n\nKotlin은 연산자 오버로딩을 지원합니다.\n\n**관례:**\n- `+`: plus\n- `-`: minus\n- `*`: times\n- `/`: div\n- `%`: rem (나머지)\n\n## 핵심 요약\n\n**산술:** `+`, `-`, `*`, `/`, `%`\n\n**복합 대입:** `+=`, `-=`, `*=`, `/=`, `%=`\n\n**증감:** `++`, `--` (전위/후위)\n\n**비교:** `==`, `!=`, `>`, `<`, `>=`, `<=`, `===`, `!==`\n\n**논리:** `&&` (AND), `||` (OR), `!` (NOT)\n\n**비트 (함수):** `and`, `or`, `xor`, `inv()`, `shl`, `shr`\n\n**범위:**\n- `..`: 포함\n- `until`: 끝 제외\n- `downTo`: 역순\n- `step`: 간격\n- `in`: 포함 여부\n\n**Null 처리:**\n- `?:`: Elvis 연산자 (기본값)\n- `?.`: Safe call\n\n**입력:**\n- `readLine()`: String? 반환\n- `readln()`: String 반환 (1.6+)\n- `.toIntOrNull()`: 안전한 변환"
    },
    {
      "chapterId": 4,
      "title": "4단원: 조건문",
      "content": "# 4단원: 조건문\n\n## if 문\n\nKotlin의 if는 문(statement)이자 식(expression)입니다.\n\n### 기본 형태\n\n```kotlin\nif (조건) {\n    // 조건이 참일 때\n}\n```\n\n### if-else\n\n```kotlin\nif (조건) {\n    // 조건이 참\n} else {\n    // 조건이 거짓\n}\n```\n\n### if-else if-else\n\n```kotlin\nif (조건1) {\n    // 조건1이 참\n} else if (조건2) {\n    // 조건2가 참\n} else {\n    // 모든 조건이 거짓\n}\n```\n\n### if 식 (expression)\n\nif를 식으로 사용하여 값을 반환할 수 있습니다.\n\n```kotlin\nval max = if (a > b) a else b\n\nval result = if (score >= 60) {\n    \"합격\"\n} else {\n    \"불합격\"\n}\n```\n\n**특징:**\n- 삼항 연산자가 없음 (if 식으로 대체)\n- 마지막 표현식이 반환값\n\n## when 문\n\nJava의 switch보다 강력한 조건 분기 구문입니다.\n\n### 기본 형태\n\n```kotlin\nwhen (변수) {\n    값1 -> {\n        // 값1일 때\n    }\n    값2 -> {\n        // 값2일 때\n    }\n    else -> {\n        // 기타\n    }\n}\n```\n\n**특징:**\n- `break` 불필요\n- 자동으로 다음 분기로 넘어가지 않음\n- 식으로도 사용 가능\n\n### 여러 조건 묶기\n\n```kotlin\nwhen (day) {\n    \"월\", \"화\", \"수\", \"목\", \"금\" -> println(\"평일\")\n    \"토\", \"일\" -> println(\"주말\")\n    else -> println(\"알 수 없음\")\n}\n```\n\n### 범위와 in 사용\n\n```kotlin\nwhen (score) {\n    in 90..100 -> println(\"A\")\n    in 80..89 -> println(\"B\")\n    in 70..79 -> println(\"C\")\n    !in 0..100 -> println(\"유효하지 않은 점수\")\n    else -> println(\"F\")\n}\n```\n\n### 타입 검사\n\n```kotlin\nwhen (obj) {\n    is String -> println(\"문자열: ${obj.length}\")\n    is Int -> println(\"정수: $obj\")\n    else -> println(\"기타\")\n}\n```\n\n### 인수 없는 when\n\n조건을 자유롭게 작성할 수 있습니다.\n\n```kotlin\nwhen {\n    score >= 90 -> println(\"A\")\n    score >= 80 -> println(\"B\")\n    score >= 70 -> println(\"C\")\n    else -> println(\"F\")\n}\n```\n\n### when 식\n\n```kotlin\nval grade = when (score) {\n    in 90..100 -> \"A\"\n    in 80..89 -> \"B\"\n    in 70..79 -> \"C\"\n    else -> \"F\"\n}\n```\n\n## if vs when 선택\n\n### if를 사용할 때\n- 조건이 단순할 때\n- 불린 조건만 검사할 때\n- 값을 반환하는 간단한 식\n\n### when을 사용할 때\n- 여러 값과 비교할 때\n- 범위 검사가 필요할 때\n- 타입 검사가 필요할 때\n- 복잡한 조건 분기\n\n## null 체크\n\n### Safe Call과 Elvis\n\n```kotlin\nval name: String? = null\n\n// Safe call\nval length = name?.length  // null이면 null 반환\n\n// Elvis 연산자\nval displayName = name ?: \"이름 없음\"\n\n// 조합\nval len = name?.length ?: 0\n```\n\n### let 함수\n\nnull이 아닐 때만 코드 실행합니다.\n\n```kotlin\nval name: String? = \"홍길동\"\n\nname?.let {\n    // name이 null이 아닐 때만 실행\n    println(\"이름: $it\")\n}\n```\n\n## 핵심 요약\n\n**if 문:**\n- 문이자 식 (값 반환 가능)\n- 삼항 연산자 대신 사용\n- `if (조건) 값1 else 값2`\n\n**when 문:**\n- switch보다 강력\n- break 불필요\n- 여러 기능:\n  - 값 매칭\n  - 범위 검사 (`in`)\n  - 타입 검사 (`is`)\n  - 조건식 (인수 없는 when)\n- 식으로 사용 가능\n\n**null 안전성:**\n- `?.`: Safe call\n- `?:`: Elvis (기본값)\n- `?.let {}`: null이 아닐 때 실행\n\n**패턴:**\n- 단순 조건: if\n- 복잡한 분기: when\n- null 처리: ?, ?:, let"
    },
    {
      "chapterId": 5,
      "title": "5단원: 반복문",
      "content": "# 5단원: 반복문\n\n## for 문\n\nKotlin의 for는 범위, 컬렉션, 배열을 순회합니다.\n\n### 범위 순회\n\n```kotlin\n// 1부터 10까지\nfor (i in 1..10) {\n    println(i)\n}\n\n// 1부터 9까지 (10 제외)\nfor (i in 1 until 10) {\n    println(i)\n}\n\n// 10부터 1까지 (역순)\nfor (i in 10 downTo 1) {\n    println(i)\n}\n\n// 간격 지정\nfor (i in 1..10 step 2) {\n    println(i)  // 1, 3, 5, 7, 9\n}\n```\n\n### 배열/컬렉션 순회\n\n```kotlin\nval numbers = arrayOf(1, 2, 3, 4, 5)\n\n// 요소 순회\nfor (num in numbers) {\n    println(num)\n}\n\n// 인덱스와 함께\nfor (index in numbers.indices) {\n    println(\"$index: ${numbers[index]}\")\n}\n\n// 인덱스와 값 동시 순회\nfor ((index, value) in numbers.withIndex()) {\n    println(\"$index: $value\")\n}\n```\n\n**특징:**\n- 전통적인 `for (int i=0; i<n; i++)` 형태 없음\n- 범위나 컬렉션 기반 순회만 지원\n- 더 안전하고 간결\n\n## while 문\n\n조건이 참인 동안 반복합니다.\n\n```kotlin\nwhile (조건) {\n    // 반복할 코드\n}\n```\n\n**특징:**\n- 조건 먼저 검사\n- 0번 실행 가능\n- 반복 횟수 미정일 때 사용\n\n## do-while 문\n\n최소 한 번은 실행합니다.\n\n```kotlin\ndo {\n    // 반복할 코드\n} while (조건)\n```\n\n**특징:**\n- 코드 먼저 실행\n- 최소 1번 보장\n- 조건은 나중에 검사\n\n## repeat 함수\n\n정해진 횟수만큼 반복하는 간편한 방법입니다.\n\n```kotlin\nrepeat(5) {\n    println(\"반복\")\n}\n\n// 인덱스 사용\nrepeat(5) { index ->\n    println(\"$index: 반복\")\n}\n```\n\n## break\n\n반복문을 즉시 종료합니다.\n\n```kotlin\nfor (i in 1..10) {\n    if (i == 5) break\n    println(i)  // 1, 2, 3, 4\n}\n```\n\n## continue\n\n현재 반복을 건너뛰고 다음 반복으로 이동합니다.\n\n```kotlin\nfor (i in 1..10) {\n    if (i % 2 == 0) continue\n    println(i)  // 1, 3, 5, 7, 9 (홀수만)\n}\n```\n\n## 레이블과 break/continue\n\n중첩 반복문에서 외부 반복문을 제어합니다.\n\n### 레이블 정의\n\n```kotlin\nouter@ for (i in 1..3) {\n    inner@ for (j in 1..3) {\n        if (i == 2 && j == 2) break@outer\n        println(\"$i, $j\")\n    }\n}\n```\n\n### continue with label\n\n```kotlin\nouter@ for (i in 1..3) {\n    for (j in 1..3) {\n        if (j == 2) continue@outer\n        println(\"$i, $j\")\n    }\n}\n```\n\n## forEach 함수\n\n컬렉션의 각 요소에 대해 작업을 수행합니다.\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\nnumbers.forEach { num ->\n    println(num)\n}\n\n// it 사용 (단일 매개변수)\nnumbers.forEach {\n    println(it)\n}\n\n// 인덱스와 함께\nnumbers.forEachIndexed { index, value ->\n    println(\"$index: $value\")\n}\n```\n\n**주의:** forEach에서는 break/continue 사용 불가 (return으로 건너뛰기 가능)\n\n## 반복문 선택 가이드\n\n### for 사용\n- 범위나 컬렉션 순회\n- 반복 횟수가 명확\n- 인덱스 필요\n\n### while 사용\n- 조건 기반 반복\n- 반복 횟수 미정\n- 무한 루프\n\n### do-while 사용\n- 최소 1번 실행 필요\n- 입력 검증\n- 메뉴 선택\n\n### repeat 사용\n- 정확한 횟수 반복\n- 간단한 반복\n\n### forEach 사용\n- 함수형 스타일\n- 간결한 코드\n- break/continue 불필요\n\n## 핵심 요약\n\n**for 문:**\n- `for (i in 범위)` 형태\n- `..`: 포함\n- `until`: 끝 제외\n- `downTo`: 역순\n- `step`: 간격\n- `.indices`: 인덱스\n- `.withIndex()`: 인덱스와 값\n\n**while 문:**\n- 조건 먼저 검사\n- 0번 실행 가능\n\n**do-while 문:**\n- 코드 먼저 실행\n- 최소 1번 보장\n\n**repeat 함수:**\n- `repeat(n) { }`\n- 정해진 횟수 반복\n\n**제어:**\n- `break`: 즉시 종료\n- `continue`: 건너뛰기\n- 레이블: `@outer` (중첩 제어)\n\n**forEach:**\n- `.forEach { }`: 각 요소\n- `.forEachIndexed { }`: 인덱스 포함\n- break/continue 불가"
    },
    {
      "chapterId": 6,
      "title": "6단원: 함수",
      "content": "# 6단원: 함수\n\n## 함수 정의\n\nKotlin에서 함수는 `fun` 키워드로 선언합니다.\n\n### 기본 구조\n\n```kotlin\nfun 함수이름(매개변수: 타입): 반환타입 {\n    // 함수 본문\n    return 값\n}\n```\n\n### 반환값이 없는 함수\n\n```kotlin\nfun printHello() {\n    println(\"Hello\")\n}\n// 또는\nfun printHello(): Unit {\n    println(\"Hello\")\n}\n```\n\n**Unit:** 반환값이 없음 (Java의 void와 유사, 생략 가능)\n\n### 반환값이 있는 함수\n\n```kotlin\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n## 단일 표현식 함수\n\n함수 본문이 단일 표현식일 때 간결하게 작성합니다.\n\n```kotlin\n// 일반 방식\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n\n// 단일 표현식 (타입 추론)\nfun add(a: Int, b: Int) = a + b\n\n// 타입 명시\nfun add(a: Int, b: Int): Int = a + b\n```\n\n**특징:**\n- `=` 사용\n- `return` 생략\n- 반환 타입 추론 가능\n\n## 매개변수\n\n### 기본 매개변수\n\n```kotlin\nfun greet(name: String, age: Int) {\n    println(\"이름: $name, 나이: $age\")\n}\n```\n\n### 기본값 (Default Arguments)\n\n```kotlin\nfun greet(name: String = \"손님\", age: Int = 20) {\n    println(\"이름: $name, 나이: $age\")\n}\n\n// 호출\ngreet()                    // \"손님\", 20\ngreet(\"홍길동\")             // \"홍길동\", 20\ngreet(\"홍길동\", 25)         // \"홍길동\", 25\n```\n\n### 명명된 인수 (Named Arguments)\n\n```kotlin\nfun createUser(name: String, age: Int, city: String) {\n    // ...\n}\n\n// 순서 무관\ncreateUser(age = 25, name = \"홍길동\", city = \"서울\")\n```\n\n**장점:**\n- 가독성 향상\n- 순서 자유\n- 일부만 명명 가능\n\n### 가변 인수 (vararg)\n\n```kotlin\nfun sum(vararg numbers: Int): Int {\n    return numbers.sum()\n}\n\n// 호출\nsum(1, 2, 3)           // 6\nsum(1, 2, 3, 4, 5)     // 15\n```\n\n**특징:**\n- 배열처럼 사용\n- 하나만 선언 가능\n- 다른 매개변수와 함께 사용 가능\n\n### 스프레드 연산자 (*)\n\n배열을 vararg 매개변수로 전달합니다.\n\n```kotlin\nval numbers = intArrayOf(1, 2, 3, 4, 5)\nval result = sum(*numbers)  // 스프레드 연산자\n```\n\n## 함수 오버로딩\n\n같은 이름, 다른 매개변수의 함수를 여러 개 정의합니다.\n\n```kotlin\nfun add(a: Int, b: Int) = a + b\nfun add(a: Double, b: Double) = a + b\nfun add(a: Int, b: Int, c: Int) = a + b + c\n```\n\n## 확장 함수 (Extension Function)\n\n기존 클래스에 새로운 함수를 추가합니다.\n\n```kotlin\n// String에 wordCount 함수 추가\nfun String.wordCount(): Int {\n    return this.split(\" \").size\n}\n\n// 사용\nval text = \"Hello World Kotlin\"\nval count = text.wordCount()  // 3\n```\n\n**특징:**\n- 클래스 수정 없이 기능 추가\n- `this`: 수신 객체\n- 널 안전 확장도 가능 (`String?`)\n\n## 중위 함수 (Infix Function)\n\n점(`.`)과 괄호 없이 호출할 수 있는 함수입니다.\n\n```kotlin\ninfix fun Int.power(exponent: Int): Int {\n    var result = 1\n    repeat(exponent) { result *= this }\n    return result\n}\n\n// 호출\nval result1 = 2.power(3)  // 일반 호출\nval result2 = 2 power 3   // 중위 호출\n```\n\n**조건:**\n- 멤버 함수 또는 확장 함수\n- 매개변수가 정확히 하나\n- `infix` 키워드 사용\n\n## 지역 함수 (Local Function)\n\n함수 내부에 정의된 함수입니다.\n\n```kotlin\nfun calculate(x: Int, y: Int): Int {\n    fun validate(value: Int) {\n        if (value < 0) throw IllegalArgumentException(\"음수 불가\")\n    }\n    \n    validate(x)\n    validate(y)\n    return x + y\n}\n```\n\n**특징:**\n- 외부 함수의 변수 접근 가능\n- 해당 함수 내에서만 사용\n\n## 고차 함수 (Higher-Order Function)\n\n함수를 매개변수로 받거나 반환하는 함수입니다.\n\n```kotlin\n// 함수를 매개변수로\nfun operation(a: Int, b: Int, op: (Int, Int) -> Int): Int {\n    return op(a, b)\n}\n\n// 사용\nval sum = operation(10, 20) { x, y -> x + y }\nval product = operation(10, 20) { x, y -> x * y }\n```\n\n## 람다식 (Lambda Expression)\n\n익명 함수를 간결하게 표현합니다.\n\n### 기본 문법\n\n```kotlin\n{ 매개변수 -> 본문 }\n```\n\n### 예제\n\n```kotlin\n// 람다 정의\nval sum = { a: Int, b: Int -> a + b }\n\n// 호출\nval result = sum(10, 20)  // 30\n\n// 타입 추론\nval numbers = listOf(1, 2, 3, 4, 5)\nval doubled = numbers.map { it * 2 }\n```\n\n**it:** 매개변수가 하나일 때 암묵적 이름\n\n### 람다 마지막 매개변수\n\n함수의 마지막 매개변수가 람다면 괄호 밖으로 뺄 수 있습니다.\n\n```kotlin\n// 일반\nnumbers.filter({ it > 3 })\n\n// 괄호 밖으로\nnumbers.filter() { it > 3 }\n\n// 괄호 생략\nnumbers.filter { it > 3 }\n```\n\n## 익명 함수\n\n이름 없는 함수로, 람다와 유사하지만 문법이 다릅니다.\n\n```kotlin\nval sum = fun(a: Int, b: Int): Int {\n    return a + b\n}\n\nval result = sum(10, 20)\n```\n\n## 꼬리 재귀 (Tail Recursion)\n\n`tailrec` 키워드로 재귀를 최적화합니다.\n\n```kotlin\ntailrec fun factorial(n: Int, acc: Int = 1): Int {\n    return if (n <= 1) acc\n    else factorial(n - 1, n * acc)\n}\n```\n\n**특징:**\n- 스택 오버플로우 방지\n- 반복문으로 변환됨\n- 재귀 호출이 마지막 연산이어야 함\n\n## inline 함수\n\n함수 호출 대신 코드를 직접 삽입하여 성능을 향상시킵니다.\n\n```kotlin\ninline fun performOperation(operation: () -> Unit) {\n    operation()\n}\n```\n\n**특징:**\n- 고차 함수에서 주로 사용\n- 런타임 오버헤드 감소\n- 람다 객체 생성 방지\n\n## 핵심 요약\n\n**함수 정의:**\n```kotlin\nfun 이름(매개변수: 타입): 반환타입 {\n    return 값\n}\n```\n\n**단일 표현식:**\n- `fun add(a: Int, b: Int) = a + b`\n- `return` 생략\n- 타입 추론\n\n**매개변수:**\n- 기본값: `name: String = \"기본\"`\n- 명명된 인수: `함수(name = \"값\")`\n- 가변 인수: `vararg`\n- 스프레드: `*배열`\n\n**확장 함수:**\n- `fun 타입.함수이름()`\n- 기존 클래스에 기능 추가\n\n**중위 함수:**\n- `infix fun Int.power(n: Int)`\n- `2 power 3` 형태로 호출\n\n**고차 함수:**\n- 함수를 매개변수로\n- 함수를 반환값으로\n\n**람다식:**\n- `{ 매개변수 -> 본문 }`\n- `it`: 단일 매개변수\n- 마지막 매개변수 람다는 괄호 밖으로\n\n**최적화:**\n- `tailrec`: 꼬리 재귀 최적화\n- `inline`: 코드 직접 삽입"
    },
    {
      "chapterId": 7,
      "title": "7단원: 컬렉션",
      "content": "# 7단원: 컬렉션\n\nKotlin은 불변(immutable)과 가변(mutable) 컬렉션을 명확히 구분합니다.\n\n## List\n\n순서가 있는 컬렉션입니다.\n\n### 불변 리스트 (List)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval names = listOf(\"홍길동\", \"김철수\")\n\n// 읽기만 가능\nval first = numbers[0]\nval size = numbers.size\n```\n\n### 가변 리스트 (MutableList)\n\n```kotlin\nval numbers = mutableListOf(1, 2, 3)\n\nnumbers.add(4)           // 추가\nnumbers.remove(2)        // 제거\nnumbers[0] = 10         // 수정\n```\n\n### 주요 메서드\n\n**읽기:**\n- `.size`: 크기\n- `.get(index)` 또는 `[index]`: 요소 접근\n- `.first()`: 첫 번째 요소\n- `.last()`: 마지막 요소\n- `.contains(value)`: 포함 여부\n- `.indexOf(value)`: 인덱스 찾기\n\n**가변 전용:**\n- `.add(value)`: 추가\n- `.addAll(collection)`: 여러 개 추가\n- `.remove(value)`: 제거\n- `.removeAt(index)`: 인덱스로 제거\n- `.clear()`: 모두 제거\n\n## Set\n\n중복을 허용하지 않는 컬렉션입니다.\n\n### 불변 셋 (Set)\n\n```kotlin\nval numbers = setOf(1, 2, 3, 2, 1)  // 실제로는 1, 2, 3만 저장\n```\n\n### 가변 셋 (MutableSet)\n\n```kotlin\nval numbers = mutableSetOf(1, 2, 3)\n\nnumbers.add(4)      // 추가\nnumbers.remove(2)   // 제거\n```\n\n### 집합 연산\n\n```kotlin\nval set1 = setOf(1, 2, 3, 4)\nval set2 = setOf(3, 4, 5, 6)\n\nval union = set1 union set2         // 합집합: 1,2,3,4,5,6\nval intersect = set1 intersect set2 // 교집합: 3,4\nval subtract = set1 subtract set2   // 차집합: 1,2\n```\n\n## Map\n\n키-값 쌍으로 데이터를 저장합니다.\n\n### 불변 맵 (Map)\n\n```kotlin\nval ages = mapOf(\n    \"홍길동\" to 25,\n    \"김철수\" to 30,\n    \"이영희\" to 28\n)\n\nval age = ages[\"홍길동\"]  // 25\n```\n\n### 가변 맵 (MutableMap)\n\n```kotlin\nval ages = mutableMapOf(\n    \"홍길동\" to 25\n)\n\nages[\"김철수\"] = 30      // 추가\nages.remove(\"홍길동\")    // 제거\n```\n\n### 주요 메서드\n\n**읽기:**\n- `.size`: 크기\n- `.get(key)` 또는 `[key]`: 값 가져오기\n- `.containsKey(key)`: 키 존재 여부\n- `.containsValue(value)`: 값 존재 여부\n- `.keys`: 모든 키\n- `.values`: 모든 값\n- `.entries`: 모든 항목\n\n**가변 전용:**\n- `.put(key, value)` 또는 `[key] = value`: 추가/수정\n- `.remove(key)`: 제거\n- `.clear()`: 모두 제거\n\n### 순회\n\n```kotlin\nfor ((key, value) in ages) {\n    println(\"$key: $value\")\n}\n```\n\n## 배열 (Array)\n\n고정 크기의 배열입니다.\n\n```kotlin\n// 생성\nval numbers = arrayOf(1, 2, 3, 4, 5)\nval strings = arrayOf(\"a\", \"b\", \"c\")\n\n// 크기 지정 생성\nval zeros = IntArray(5)  // 0으로 초기화된 크기 5 배열\nval array = Array(5) { i -> i * 2 }  // 0, 2, 4, 6, 8\n\n// 접근\nval first = numbers[0]\nnumbers[0] = 10\n```\n\n### 원시 타입 배열\n\n- `IntArray`: Int 배열\n- `DoubleArray`: Double 배열\n- `BooleanArray`: Boolean 배열\n- 등등...\n\n## 컬렉션 연산\n\n### 변환 (Transformation)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// map: 각 요소 변환\nval doubled = numbers.map { it * 2 }  // [2, 4, 6, 8, 10]\n\n// flatMap: 변환 후 평탄화\nval nested = listOf(listOf(1, 2), listOf(3, 4))\nval flattened = nested.flatMap { it }  // [1, 2, 3, 4]\n```\n\n### 필터링 (Filtering)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// filter: 조건 만족하는 요소만\nval even = numbers.filter { it % 2 == 0 }  // [2, 4]\n\n// filterNot: 조건 만족하지 않는 요소\nval odd = numbers.filterNot { it % 2 == 0 }  // [1, 3, 5]\n\n// filterNotNull: null 제거\nval withNull = listOf(1, null, 2, null, 3)\nval notNull = withNull.filterNotNull()  // [1, 2, 3]\n```\n\n### 정렬 (Sorting)\n\n```kotlin\nval numbers = listOf(3, 1, 4, 1, 5)\n\nval sorted = numbers.sorted()              // [1, 1, 3, 4, 5]\nval sortedDesc = numbers.sortedDescending()  // [5, 4, 3, 1, 1]\n\n// 사용자 정의 정렬\nval names = listOf(\"홍길동\", \"김철수\", \"이영희\")\nval byLength = names.sortedBy { it.length }\n```\n\n### 집계 (Aggregation)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\nval sum = numbers.sum()           // 15\nval average = numbers.average()   // 3.0\nval max = numbers.maxOrNull()     // 5\nval min = numbers.minOrNull()     // 1\nval count = numbers.count()       // 5\n```\n\n### 검색 (Search)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// find: 첫 번째 일치 요소\nval firstEven = numbers.find { it % 2 == 0 }  // 2\n\n// any: 하나라도 만족\nval hasEven = numbers.any { it % 2 == 0 }  // true\n\n// all: 모두 만족\nval allPositive = numbers.all { it > 0 }  // true\n\n// none: 하나도 만족하지 않음\nval noNegative = numbers.none { it < 0 }  // true\n```\n\n### 분할 (Partitioning)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// take: 앞에서 n개\nval first3 = numbers.take(3)  // [1, 2, 3]\n\n// drop: 앞에서 n개 제거\nval after2 = numbers.drop(2)  // [3, 4, 5]\n\n// partition: 조건으로 분할\nval (even, odd) = numbers.partition { it % 2 == 0 }\n// even: [2, 4], odd: [1, 3, 5]\n```\n\n### 그룹화 (Grouping)\n\n```kotlin\nval words = listOf(\"a\", \"ab\", \"abc\", \"b\", \"bc\")\n\n// groupBy: 조건으로 그룹화\nval byLength = words.groupBy { it.length }\n// {1=[a, b], 2=[ab, bc], 3=[abc]}\n```\n\n### 축약 (Reduction)\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// fold: 초기값과 함께 누적\nval sum = numbers.fold(0) { acc, num -> acc + num }  // 15\n\n// reduce: 첫 요소부터 누적\nval product = numbers.reduce { acc, num -> acc * num }  // 120\n```\n\n## 시퀀스 (Sequence)\n\n지연 평가(lazy evaluation)를 사용하는 컬렉션입니다.\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\n\n// 컬렉션: 즉시 평가\nval result1 = numbers\n    .map { it * 2 }\n    .filter { it > 5 }\n\n// 시퀀스: 지연 평가\nval result2 = numbers.asSequence()\n    .map { it * 2 }\n    .filter { it > 5 }\n    .toList()  // 여기서 평가\n```\n\n**사용 시기:**\n- 대용량 데이터\n- 여러 연산 체인\n- 중간 결과 생성 최소화\n\n## 컬렉션 선택 가이드\n\n### List vs Set\n- 순서 중요, 중복 허용: List\n- 중복 제거, 순서 무관: Set\n\n### 불변 vs 가변\n- 기본: 불변 (listOf, setOf, mapOf)\n- 수정 필요: 가변 (mutableListOf 등)\n\n### Array vs List\n- 고정 크기, 성능 중요: Array\n- 동적 크기, 편의 기능: List\n\n## 핵심 요약\n\n**List:**\n- 불변: `listOf()`\n- 가변: `mutableListOf()`\n- 순서 있음, 중복 허용\n\n**Set:**\n- 불변: `setOf()`\n- 가변: `mutableSetOf()`\n- 중복 불가, 집합 연산\n\n**Map:**\n- 불변: `mapOf(key to value)`\n- 가변: `mutableMapOf()`\n- 키-값 쌍\n\n**Array:**\n- `arrayOf()`, `IntArray()` 등\n- 고정 크기\n\n**주요 연산:**\n- 변환: `map`, `flatMap`\n- 필터: `filter`, `filterNot`\n- 정렬: `sorted`, `sortedBy`\n- 집계: `sum`, `average`, `max`\n- 검색: `find`, `any`, `all`\n- 그룹화: `groupBy`\n- 축약: `fold`, `reduce`\n\n**Sequence:**\n- `.asSequence()`: 지연 평가\n- 대용량 데이터에 유리"
    },
    {
      "chapterId": 8,
      "title": "8단원: 클래스와 객체지향",
      "content": "# 8단원: 클래스와 객체지향\n\n## 클래스 선언\n\n### 기본 클래스\n\n```kotlin\nclass Person {\n    var name: String = \"\"\n    var age: Int = 0\n}\n\n// 사용\nval person = Person()\nperson.name = \"홍길동\"\nperson.age = 25\n```\n\n### 주 생성자 (Primary Constructor)\n\n클래스 헤더에 정의하는 생성자입니다.\n\n```kotlin\nclass Person(val name: String, var age: Int)\n\n// 사용\nval person = Person(\"홍길동\", 25)\n```\n\n**특징:**\n- 클래스 이름 뒤에 선언\n- `val`/`var`로 속성 자동 선언\n- `constructor` 키워드 생략 가능\n\n### 초기화 블록 (init)\n\n```kotlin\nclass Person(val name: String, var age: Int) {\n    init {\n        println(\"Person 생성: $name\")\n        require(age >= 0) { \"나이는 0 이상이어야 합니다\" }\n    }\n}\n```\n\n### 부 생성자 (Secondary Constructor)\n\n```kotlin\nclass Person(val name: String) {\n    var age: Int = 0\n    \n    constructor(name: String, age: Int) : this(name) {\n        this.age = age\n    }\n}\n```\n\n## 속성 (Property)\n\n### 사용자 정의 getter/setter\n\n```kotlin\nclass Person(val name: String) {\n    var age: Int = 0\n        get() = field\n        set(value) {\n            if (value >= 0) field = value\n        }\n}\n```\n\n**field:** 백킹 필드 (실제 값 저장)\n\n### 계산된 속성\n\n```kotlin\nclass Rectangle(val width: Int, val height: Int) {\n    val area: Int\n        get() = width * height\n}\n```\n\n### 지연 초기화 (lateinit)\n\n```kotlin\nclass MyClass {\n    lateinit var name: String\n    \n    fun init() {\n        name = \"홍길동\"\n    }\n}\n```\n\n### 위임 속성 (lazy)\n\n```kotlin\nclass Person {\n    val data: String by lazy {\n        // 처음 접근 시 실행\n        \"Heavy data\"\n    }\n}\n```\n\n## 가시성 제한자\n\n- `public`: 어디서나 접근 (기본값)\n- `private`: 같은 파일/클래스 내에서만\n- `protected`: 같은 클래스와 서브클래스\n- `internal`: 같은 모듈 내에서만\n\n## 상속 (Inheritance)\n\n### open 클래스\n\nKotlin 클래스는 기본적으로 final입니다. 상속하려면 `open` 키워드가 필요합니다.\n\n```kotlin\nopen class Animal(val name: String) {\n    open fun sound() {\n        println(\"소리를 냅니다\")\n    }\n}\n\nclass Dog(name: String) : Animal(name) {\n    override fun sound() {\n        println(\"멍멍!\")\n    }\n}\n```\n\n**특징:**\n- `open`: 상속/재정의 가능\n- `override`: 메서드 재정의\n- `: 부모클래스()`: 상속 및 부모 생성자 호출\n\n### super 키워드\n\n```kotlin\nclass Dog(name: String) : Animal(name) {\n    override fun sound() {\n        super.sound()  // 부모 메서드 호출\n        println(\"멍멍!\")\n    }\n}\n```\n\n## 추상 클래스 (Abstract Class)\n\n```kotlin\nabstract class Shape {\n    abstract val area: Double\n    abstract fun draw()\n    \n    fun describe() {  // 일반 메서드 가능\n        println(\"넓이: $area\")\n    }\n}\n\nclass Circle(val radius: Double) : Shape() {\n    override val area: Double\n        get() = Math.PI * radius * radius\n    \n    override fun draw() {\n        println(\"원 그리기\")\n    }\n}\n```\n\n**특징:**\n- `abstract` 키워드\n- 인스턴스 생성 불가\n- 추상 멤버는 자동으로 open\n\n## 인터페이스 (Interface)\n\n```kotlin\ninterface Drawable {\n    fun draw()\n    \n    fun describe() {  // 기본 구현 가능\n        println(\"도형입니다\")\n    }\n}\n\nclass Rectangle : Drawable {\n    override fun draw() {\n        println(\"사각형 그리기\")\n    }\n}\n```\n\n**특징:**\n- 다중 인터페이스 구현 가능\n- 속성도 선언 가능 (추상)\n- 기본 구현 제공 가능\n\n## 데이터 클래스 (Data Class)\n\n데이터 저장이 주 목적인 클래스입니다.\n\n```kotlin\ndata class User(val name: String, val age: Int)\n```\n\n**자동 생성되는 메서드:**\n- `equals()`: 동등성 비교\n- `hashCode()`: 해시 코드\n- `toString()`: 문자열 표현\n- `copy()`: 복사\n- `componentN()`: 구조 분해\n\n### copy 메서드\n\n```kotlin\nval user1 = User(\"홍길동\", 25)\nval user2 = user1.copy(age = 30)  // 일부만 변경\n```\n\n### 구조 분해 (Destructuring)\n\n```kotlin\nval user = User(\"홍길동\", 25)\nval (name, age) = user  // 구조 분해\n```\n\n## sealed 클래스\n\n제한된 계층 구조를 표현합니다.\n\n```kotlin\nsealed class Result\ndata class Success(val data: String) : Result()\ndata class Error(val message: String) : Result()\nobject Loading : Result()\n\nfun handle(result: Result) = when (result) {\n    is Success -> println(\"성공: ${result.data}\")\n    is Error -> println(\"실패: ${result.message}\")\n    Loading -> println(\"로딩 중\")\n    // else 불필요 (모든 경우 커버)\n}\n```\n\n**특징:**\n- 제한된 서브클래스\n- when 식에서 완전성 보장\n- 같은 파일 내에서만 상속 가능\n\n## object (싱글톤)\n\n### object 선언\n\n```kotlin\nobject DatabaseManager {\n    val url = \"jdbc:mysql://localhost\"\n    \n    fun connect() {\n        println(\"연결됨: $url\")\n    }\n}\n\n// 사용\nDatabaseManager.connect()\n```\n\n### companion object\n\n클래스 내부의 싱글톤 객체입니다.\n\n```kotlin\nclass MyClass {\n    companion object {\n        const val MAX_VALUE = 100\n        \n        fun create(): MyClass {\n            return MyClass()\n        }\n    }\n}\n\n// 사용\nval max = MyClass.MAX_VALUE\nval instance = MyClass.create()\n```\n\n**특징:**\n- 정적 멤버처럼 사용\n- 클래스당 하나만 가능\n- 인터페이스 구현 가능\n\n### 익명 객체 (Anonymous Object)\n\n```kotlin\nval obj = object {\n    val x = 10\n    val y = 20\n}\n\nprintln(obj.x)\n```\n\n## enum 클래스\n\n```kotlin\nenum class Direction {\n    NORTH, SOUTH, EAST, WEST\n}\n\n// 속성과 메서드\nenum class Color(val rgb: Int) {\n    RED(0xFF0000),\n    GREEN(0x00FF00),\n    BLUE(0x0000FF);\n    \n    fun describe() = \"RGB: $rgb\"\n}\n```\n\n## 중첩 클래스와 내부 클래스\n\n### 중첩 클래스 (Nested Class)\n\n```kotlin\nclass Outer {\n    class Nested {\n        fun hello() = \"Nested\"\n    }\n}\n\nval nested = Outer.Nested()\n```\n\n### 내부 클래스 (Inner Class)\n\n```kotlin\nclass Outer {\n    private val bar = 1\n    \n    inner class Inner {\n        fun foo() = bar  // 외부 클래스 접근 가능\n    }\n}\n\nval inner = Outer().Inner()\n```\n\n## 핵심 요약\n\n**클래스 선언:**\n```kotlin\nclass 이름(val 속성: 타입)\n```\n\n**생성자:**\n- 주 생성자: 클래스 헤더\n- 부 생성자: `constructor`\n- 초기화: `init {}`\n\n**상속:**\n- `open`: 상속 허용\n- `override`: 재정의\n- `super`: 부모 참조\n\n**추상화:**\n- `abstract class`: 추상 클래스\n- `interface`: 인터페이스 (다중 구현)\n\n**특수 클래스:**\n- `data class`: 데이터 저장 (equals, copy 등)\n- `sealed class`: 제한된 계층\n- `object`: 싱글톤\n- `companion object`: 정적 멤버\n- `enum class`: 열거형\n\n**중첩:**\n- 중첩 클래스: 정적\n- `inner class`: 외부 클래스 접근\n\n**가시성:**\n- `public` (기본), `private`, `protected`, `internal`"
    },
    {
      "chapterId": 9,
      "title": "9단원: 파일 입출력",
      "content": "# 9단원: 파일 입출력\n\nKotlin은 Java의 I/O 라이브러리를 사용하며, 추가적인 확장 함수를 제공합니다.\n\n## java.io 패키지\n\n```kotlin\nimport java.io.File\nimport java.io.FileReader\nimport java.io.FileWriter\n```\n\n## File 클래스\n\n### 파일 생성 및 확인\n\n```kotlin\nval file = File(\"test.txt\")\n\n// 존재 확인\nif (file.exists()) {\n    println(\"파일 존재\")\n}\n\n// 파일 생성\nfile.createNewFile()\n\n// 디렉토리 생성\nval dir = File(\"mydir\")\ndir.mkdir()          // 한 단계\ndir.mkdirs()         // 여러 단계\n```\n\n### 파일 정보\n\n```kotlin\nval file = File(\"test.txt\")\n\nprintln(\"이름: ${file.name}\")\nprintln(\"경로: ${file.path}\")\nprintln(\"절대 경로: ${file.absolutePath}\")\nprintln(\"크기: ${file.length()} bytes\")\nprintln(\"디렉토리: ${file.isDirectory}\")\nprintln(\"파일: ${file.isFile}\")\nprintln(\"읽기 가능: ${file.canRead()}\")\nprintln(\"쓰기 가능: ${file.canWrite()}\")\n```\n\n### 파일 삭제 및 이동\n\n```kotlin\n// 삭제\nfile.delete()\n\n// 이름 변경/이동\nfile.renameTo(File(\"new.txt\"))\n\n// 디렉토리 내 파일 목록\nval files = dir.listFiles()\nfiles?.forEach { println(it.name) }\n```\n\n## 파일 읽기 (Kotlin 확장 함수)\n\n### 전체 읽기\n\n```kotlin\nval file = File(\"test.txt\")\n\n// 문자열로 읽기\nval content = file.readText()\n\n// 줄 단위로 읽기 (List)\nval lines = file.readLines()\nlines.forEach { println(it) }\n\n// 바이트로 읽기\nval bytes = file.readBytes()\n```\n\n### 한 줄씩 읽기\n\n```kotlin\n// forEachLine: 메모리 효율적\nfile.forEachLine { line ->\n    println(line)\n}\n\n// useLines: 시퀀스로 처리\nfile.useLines { lines ->\n    lines.filter { it.isNotEmpty() }\n         .forEach { println(it) }\n}\n```\n\n### BufferedReader 사용\n\n```kotlin\nfile.bufferedReader().use { reader ->\n    var line = reader.readLine()\n    while (line != null) {\n        println(line)\n        line = reader.readLine()\n    }\n}\n```\n\n## 파일 쓰기 (Kotlin 확장 함수)\n\n### 전체 쓰기\n\n```kotlin\nval file = File(\"test.txt\")\n\n// 문자열 쓰기 (덮어쓰기)\nfile.writeText(\"Hello, Kotlin!\")\n\n// 줄 단위로 쓰기\nval lines = listOf(\"첫 번째 줄\", \"두 번째 줄\")\nfile.writeLines(lines)\n\n// 바이트 쓰기\nfile.writeBytes(byteArrayOf(1, 2, 3))\n```\n\n### 추가 쓰기\n\n```kotlin\n// 기존 내용에 추가\nfile.appendText(\"추가 내용\\n\")\n\n// 줄 추가\nval newLines = listOf(\"새 줄 1\", \"새 줄 2\")\nfile.appendLines(newLines)\n```\n\n### BufferedWriter 사용\n\n```kotlin\nfile.bufferedWriter().use { writer ->\n    writer.write(\"첫 번째 줄\")\n    writer.newLine()\n    writer.write(\"두 번째 줄\")\n}\n```\n\n## use 함수\n\n자동으로 리소스를 닫아주는 함수입니다.\n\n```kotlin\nFile(\"test.txt\").bufferedReader().use { reader ->\n    // 읽기 작업\n}  // 자동으로 close() 호출\n```\n\n**특징:**\n- Java의 try-with-resources와 유사\n- AutoCloseable 구현 객체에 사용\n- 예외 발생 시에도 리소스 해제 보장\n\n## 바이너리 파일\n\n### InputStream과 OutputStream\n\n```kotlin\nimport java.io.FileInputStream\nimport java.io.FileOutputStream\n\n// 쓰기\nFileOutputStream(\"data.bin\").use { output ->\n    val data = byteArrayOf(1, 2, 3, 4, 5)\n    output.write(data)\n}\n\n// 읽기\nFileInputStream(\"data.bin\").use { input ->\n    val data = input.readBytes()\n    data.forEach { println(it) }\n}\n```\n\n### DataInputStream과 DataOutputStream\n\n기본 타입을 바이너리로 읽고 씁니다.\n\n```kotlin\nimport java.io.DataInputStream\nimport java.io.DataOutputStream\n\n// 쓰기\nDataOutputStream(FileOutputStream(\"data.bin\")).use { output ->\n    output.writeInt(100)\n    output.writeDouble(3.14)\n    output.writeUTF(\"Hello\")\n    output.writeBoolean(true)\n}\n\n// 읽기\nDataInputStream(FileInputStream(\"data.bin\")).use { input ->\n    val num = input.readInt()\n    val d = input.readDouble()\n    val str = input.readUTF()\n    val bool = input.readBoolean()\n}\n```\n\n## 직렬화 (Serialization)\n\n### Java 직렬화\n\n```kotlin\nimport java.io.Serializable\nimport java.io.ObjectOutputStream\nimport java.io.ObjectInputStream\n\ndata class Person(val name: String, val age: Int) : Serializable\n\n// 직렬화\nval person = Person(\"홍길동\", 25)\nObjectOutputStream(FileOutputStream(\"person.dat\")).use { output ->\n    output.writeObject(person)\n}\n\n// 역직렬화\nObjectInputStream(FileInputStream(\"person.dat\")).use { input ->\n    val person = input.readObject() as Person\n    println(person)\n}\n```\n\n## 경로 처리\n\n### Path 사용 (java.nio.file)\n\n```kotlin\nimport java.nio.file.Paths\nimport java.nio.file.Files\n\n// 경로 생성\nval path = Paths.get(\"test.txt\")\n\n// 파일 작업\nval content = Files.readString(path)\nFiles.writeString(path, \"Hello\")\n\n// 파일 복사\nval source = Paths.get(\"source.txt\")\nval target = Paths.get(\"target.txt\")\nFiles.copy(source, target)\n\n// 파일 이동\nFiles.move(source, target)\n\n// 파일 삭제\nFiles.delete(path)\n```\n\n## 디렉토리 탐색\n\n### walkTopDown과 walkBottomUp\n\n```kotlin\nval dir = File(\"mydir\")\n\n// 하위 디렉토리 순회 (깊이 우선)\ndir.walkTopDown()\n   .filter { it.isFile }\n   .forEach { println(it.path) }\n\n// 특정 확장자만\ndir.walkTopDown()\n   .filter { it.extension == \"txt\" }\n   .forEach { println(it.name) }\n```\n\n## 예외 처리\n\n파일 작업 시 예외 처리는 필수입니다.\n\n```kotlin\ntry {\n    val content = File(\"test.txt\").readText()\n    println(content)\n} catch (e: FileNotFoundException) {\n    println(\"파일을 찾을 수 없습니다\")\n} catch (e: IOException) {\n    println(\"입출력 오류: ${e.message}\")\n}\n```\n\n## 핵심 요약\n\n**File 클래스:**\n- `File(경로)`: 파일 객체 생성\n- `.exists()`, `.createNewFile()`, `.delete()`\n\n**읽기 (Kotlin 확장):**\n- `.readText()`: 전체 문자열\n- `.readLines()`: 줄 단위 리스트\n- `.readBytes()`: 바이트 배열\n- `.forEachLine {}`: 한 줄씩 처리\n- `.useLines {}`: 시퀀스로 처리\n\n**쓰기 (Kotlin 확장):**\n- `.writeText()`: 문자열 쓰기\n- `.writeLines()`: 줄 단위 쓰기\n- `.appendText()`: 추가 쓰기\n\n**BufferedReader/Writer:**\n```kotlin\nfile.bufferedReader().use { reader ->\n    // 읽기\n}\n\nfile.bufferedWriter().use { writer ->\n    // 쓰기\n}\n```\n\n**use 함수:**\n- 자동 리소스 해제\n- try-with-resources 대체\n\n**바이너리:**\n- `InputStream/OutputStream`: 바이트 스트림\n- `DataInputStream/DataOutputStream`: 기본 타입\n\n**디렉토리:**\n- `.listFiles()`: 파일 목록\n- `.walkTopDown()`: 하위 탐색\n\n**Path (NIO):**\n- `Paths.get()`: 경로 생성\n- `Files.*`: 파일 작업"
    },
    {
      "chapterId": 10,
      "title": "10단원: 예외처리와 고급 기능",
      "content": "# 10단원: 예외처리와 고급 기능\n\n## 예외처리 (Exception Handling)\n\nKotlin의 모든 예외는 Unchecked Exception입니다.\n\n### try-catch\n\n```kotlin\ntry {\n    val result = 10 / 0\n} catch (e: ArithmeticException) {\n    println(\"0으로 나눌 수 없습니다\")\n} catch (e: Exception) {\n    println(\"오류: ${e.message}\")\n} finally {\n    println(\"항상 실행\")\n}\n```\n\n**특징:**\n- Checked Exception 없음\n- throws 선언 불필요\n- finally는 선택적\n\n### try를 식으로 사용\n\nKotlin의 try는 값을 반환할 수 있습니다.\n\n```kotlin\nval result = try {\n    \"123\".toInt()\n} catch (e: NumberFormatException) {\n    0  // 기본값\n}\n```\n\n### throw\n\n예외를 발생시킵니다.\n\n```kotlin\nfun divide(a: Int, b: Int): Int {\n    if (b == 0) {\n        throw IllegalArgumentException(\"0으로 나눌 수 없습니다\")\n    }\n    return a / b\n}\n\n// Nothing 타입\nfun fail(message: String): Nothing {\n    throw IllegalStateException(message)\n}\n```\n\n### 주요 예외 클래스\n\n- `Exception`: 기본 예외\n- `IllegalArgumentException`: 잘못된 인수\n- `IllegalStateException`: 잘못된 상태\n- `NullPointerException`: null 참조\n- `NumberFormatException`: 숫자 형식 오류\n- `IndexOutOfBoundsException`: 인덱스 범위 초과\n- `IOException`: 입출력 오류\n\n## 널 안전성 (Null Safety)\n\nKotlin의 핵심 기능입니다.\n\n### Nullable 타입\n\n```kotlin\nval nonNull: String = \"Hello\"   // null 불가\nval nullable: String? = null    // null 가능\n```\n\n### Safe Call (?.)\n\n```kotlin\nval name: String? = null\nval length = name?.length  // null이면 null 반환\n```\n\n### Elvis 연산자 (?:)\n\n```kotlin\nval name: String? = null\nval displayName = name ?: \"Unknown\"  // null이면 기본값\n```\n\n### Non-null 단언 (!!)\n\n```kotlin\nval name: String? = \"Hello\"\nval length = name!!.length  // null이면 예외 발생\n```\n\n**주의:** 가능한 사용 자제\n\n### let 함수\n\n```kotlin\nval name: String? = \"홍길동\"\n\nname?.let {\n    // name이 null이 아닐 때만 실행\n    println(\"이름: $it\")\n}\n```\n\n## 람다와 고차 함수\n\n### 람다 기본\n\n```kotlin\nval sum = { a: Int, b: Int -> a + b }\nval result = sum(10, 20)  // 30\n```\n\n### 고차 함수\n\n함수를 매개변수로 받거나 반환하는 함수입니다.\n\n```kotlin\nfun operation(a: Int, b: Int, op: (Int, Int) -> Int): Int {\n    return op(a, b)\n}\n\nval sum = operation(10, 20) { x, y -> x + y }\nval product = operation(10, 20) { x, y -> x * y }\n```\n\n### 함수 타입\n\n```kotlin\n// 함수 타입 선언\nval func: (Int, Int) -> Int = { a, b -> a + b }\n\n// nullable 함수 타입\nval nullableFunc: ((Int) -> Int)? = null\n```\n\n### it 사용\n\n```kotlin\nval numbers = listOf(1, 2, 3, 4, 5)\nval doubled = numbers.map { it * 2 }\n```\n\n## 스코프 함수\n\n객체의 컨텍스트 내에서 코드 블록을 실행합니다.\n\n### let\n\nnull이 아닐 때 실행, 결과 반환\n\n```kotlin\nval name: String? = \"홍길동\"\nval length = name?.let {\n    println(\"이름: $it\")\n    it.length  // 반환값\n}\n```\n\n### run\n\n객체에서 실행, 결과 반환\n\n```kotlin\nval result = \"Hello\".run {\n    println(\"길이: $length\")\n    uppercase()  // 반환값\n}\n```\n\n### with\n\n객체를 인수로, 결과 반환\n\n```kotlin\nval numbers = mutableListOf(1, 2, 3)\nval result = with(numbers) {\n    add(4)\n    add(5)\n    size  // 반환값\n}\n```\n\n### apply\n\n객체 설정 후 객체 자체 반환\n\n```kotlin\nval person = Person().apply {\n    name = \"홍길동\"\n    age = 25\n}  // person 반환\n```\n\n### also\n\n추가 작업 후 객체 자체 반환\n\n```kotlin\nval numbers = mutableListOf(1, 2, 3).also {\n    println(\"리스트 크기: ${it.size}\")\n}  // numbers 반환\n```\n\n### 스코프 함수 비교\n\n| 함수 | 객체 참조 | 반환값 | 용도 |\n|------|-----------|--------|------|\n| let | it | 람다 결과 | null 체크, 변환 |\n| run | this | 람다 결과 | 객체 설정 및 계산 |\n| with | this | 람다 결과 | 그룹화된 함수 호출 |\n| apply | this | 객체 자체 | 객체 설정 |\n| also | it | 객체 자체 | 추가 작업 |\n\n## 제네릭 (Generics)\n\n### 제네릭 클래스\n\n```kotlin\nclass Box<T>(val value: T)\n\nval intBox = Box<Int>(10)\nval strBox = Box(\"Hello\")  // 타입 추론\n```\n\n### 제네릭 함수\n\n```kotlin\nfun <T> singletonList(item: T): List<T> {\n    return listOf(item)\n}\n\nval list = singletonList<Int>(1)\nval list2 = singletonList(\"Hello\")  // 타입 추론\n```\n\n### 제약 조건\n\n```kotlin\n// 상한 (upper bound)\nfun <T : Comparable<T>> max(a: T, b: T): T {\n    return if (a > b) a else b\n}\n\n// 여러 제약\nfun <T> copy(source: T) where T : Comparable<T>, T : Cloneable {\n    // ...\n}\n```\n\n### 변성 (Variance)\n\n**공변 (out):**\n```kotlin\nclass Producer<out T>(val value: T) {\n    fun get(): T = value\n    // fun set(value: T) {}  // 에러! out은 반환만\n}\n```\n\n**반공변 (in):**\n```kotlin\nclass Consumer<in T> {\n    fun consume(value: T) {}\n    // fun get(): T = ...  // 에러! in은 매개변수만\n}\n```\n\n## 위임 (Delegation)\n\n### 클래스 위임\n\n```kotlin\ninterface Base {\n    fun print()\n}\n\nclass BaseImpl : Base {\n    override fun print() = println(\"BaseImpl\")\n}\n\n// by 키워드로 위임\nclass Derived(b: Base) : Base by b\n\nval base = BaseImpl()\nval derived = Derived(base)\nderived.print()  // BaseImpl의 print 호출\n```\n\n### 속성 위임\n\n```kotlin\nimport kotlin.properties.Delegates\n\n// lazy: 지연 초기화\nval lazyValue: String by lazy {\n    println(\"초기화\")\n    \"Hello\"\n}\n\n// observable: 변경 감지\nvar name: String by Delegates.observable(\"초기값\") { prop, old, new ->\n    println(\"$old → $new\")\n}\n```\n\n## 코루틴 (Coroutines) 기본\n\n비동기 프로그래밍을 위한 기능입니다.\n\n### 기본 사용\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking {\n    launch {\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello\")\n}\n```\n\n**특징:**\n- 경량 스레드\n- `suspend` 함수\n- `launch`, `async` 빌더\n\n## 어노테이션 (Annotations)\n\n```kotlin\n@Deprecated(\"Use newFunction instead\")\nfun oldFunction() {}\n\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class MyAnnotation(val value: String)\n```\n\n## 연산자 오버로딩\n\n```kotlin\ndata class Point(val x: Int, val y: Int) {\n    operator fun plus(other: Point) = Point(x + other.x, y + other.y)\n    operator fun times(scale: Int) = Point(x * scale, y * scale)\n}\n\nval p1 = Point(10, 20)\nval p2 = Point(30, 40)\nval p3 = p1 + p2  // plus 호출\nval p4 = p1 * 2   // times 호출\n```\n\n## 핵심 요약\n\n**예외처리:**\n- `try-catch-finally`\n- 모든 예외는 Unchecked\n- try를 식으로 사용 가능\n\n**널 안전성:**\n- `타입?`: Nullable\n- `?.`: Safe call\n- `?:`: Elvis\n- `!!`: Non-null 단언\n- `.let {}`: null이 아닐 때 실행\n\n**스코프 함수:**\n- `let`: null 체크, 변환\n- `run`: 객체 설정 및 계산\n- `with`: 그룹 호출\n- `apply`: 객체 설정\n- `also`: 추가 작업\n\n**제네릭:**\n- `<T>`: 타입 매개변수\n- `out`: 공변 (생산자)\n- `in`: 반공변 (소비자)\n\n**위임:**\n- `by`: 클래스/속성 위임\n- `lazy`: 지연 초기화\n- `observable`: 변경 감지\n\n**람다:**\n- `{ 매개변수 -> 본문 }`\n- `it`: 단일 매개변수\n- 고차 함수: 함수를 매개변수/반환값으로"
    }
  ]
}
