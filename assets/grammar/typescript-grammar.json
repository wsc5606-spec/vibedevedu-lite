{
  "language": "typescript",
  "chapters": [
    {
      "chapterId": 1,
      "title": "1단원: 출력과 주석",
      "content": "# 1단원: 출력과 주석\n\n## 출력 (Output)\n\nTypeScript에서 콘솔에 출력하려면 `console.log()`를 사용합니다.\n\n```typescript\nconsole.log('Hello, TypeScript!');\nconsole.log('안녕하세요');\n```\n\n## console 메서드\n\n```typescript\n// 기본 출력\nconsole.log('일반 로그');\n\n// 정보 메시지\nconsole.info('정보 메시지');\n\n// 경고 메시지\nconsole.warn('경고 메시지');\n\n// 에러 메시지\nconsole.error('에러 메시지');\n\n// 테이블 형태로 출력\nconst users = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 }\n];\nconsole.table(users);\n```\n\n## 템플릿 리터럴\n\nTypeScript는 템플릿 리터럴로 문자열을 쉽게 조합할 수 있습니다.\n\n```typescript\nconst name: string = 'Alice';\nconst age: number = 25;\n\n// 템플릿 리터럴 사용\nconsole.log(`이름: ${name}, 나이: ${age}`);\n\n// 계산식 포함\nconsole.log(`내년 나이: ${age + 1}`);\n\n// 여러 줄 문자열\nconst message: string = `\n  안녕하세요,\n  ${name}님!\n  환영합니다.\n`;\nconsole.log(message);\n```\n\n## 주석 (Comments)\n\n주석은 코드에 설명을 추가하는 방법입니다.\n\n### 한 줄 주석\n\n```typescript\n// 이것은 한 줄 주석입니다\nconsole.log('Hello'); // 코드 옆에도 작성 가능\n```\n\n### 여러 줄 주석\n\n```typescript\n/*\n  이것은\n  여러 줄\n  주석입니다\n*/\nconsole.log('World');\n```\n\n### JSDoc 주석\n\n```typescript\n/**\n * 두 숫자를 더하는 함수입니다.\n * @param a - 첫 번째 숫자\n * @param b - 두 번째 숫자\n * @returns 두 숫자의 합\n */\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n```\n\n## 문자열 연결\n\n```typescript\nconst firstName: string = 'Hong';\nconst lastName: string = 'Gildong';\n\n// + 연산자\nconst fullName1: string = firstName + ' ' + lastName;\nconsole.log(fullName1);\n\n// 템플릿 리터럴 (권장)\nconst fullName2: string = `${firstName} ${lastName}`;\nconsole.log(fullName2);\n\n// 여러 값 연결\nconst age: number = 25;\nconsole.log(`${firstName} ${lastName}님은 ${age}세입니다.`);\n```\n\n## 객체와 배열 출력\n\n```typescript\nconst person = {\n  name: 'Alice',\n  age: 25,\n  city: 'Seoul'\n};\n\n// 객체 출력\nconsole.log(person);\nconsole.log('이름:', person.name);\n\n// JSON 형태로 출력\nconsole.log(JSON.stringify(person, null, 2));\n\n// 배열 출력\nconst numbers: number[] = [1, 2, 3, 4, 5];\nconsole.log(numbers);\nconsole.log('배열:', numbers.join(', '));\n```\n\n## 연습 문제\n\n1. 자신의 이름과 나이를 템플릿 리터럴로 출력하세요\n2. JSDoc 주석을 사용해 함수를 문서화하세요\n3. 객체를 생성하고 JSON 형태로 출력하세요\n\n## 핵심 요약\n\n- `console.log()`: 콘솔 출력\n- `console.info()`, `console.warn()`, `console.error()`: 로그 레벨\n- `` ` ` ``: 템플릿 리터럴\n- `${}`: 표현식 삽입\n- `//`: 한 줄 주석\n- `/* */`: 여러 줄 주석\n- `/** */`: JSDoc 주석\n- `JSON.stringify()`: 객체를 JSON 문자열로"
    },
    {
      "chapterId": 2,
      "title": "2단원: 변수와 자료형",
      "content": "# 2단원: 변수와 자료형\n\n## 변수 선언\n\nTypeScript는 정적 타입을 지원하는 JavaScript의 슈퍼셋입니다.\n\n```typescript\n// let: 재할당 가능\nlet name: string = 'Alice';\nlet age: number = 25;\nlet isStudent: boolean = true;\n\n// const: 재할당 불가능 (상수)\nconst PI: number = 3.14159;\nconst MAX_SIZE: number = 100;\n\n// var: 권장하지 않음 (함수 스코프)\nvar oldStyle: string = 'avoid using var';\n\nconsole.log(name, age, isStudent);\n```\n\n## 기본 타입 (Basic Types)\n\n### 숫자 (number)\n\n```typescript\nlet integer: number = 42;\nlet float: number = 3.14;\nlet negative: number = -10;\nlet hex: number = 0xFF;      // 16진수\nlet binary: number = 0b1010;  // 2진수\nlet octal: number = 0o744;    // 8진수\n\nconsole.log(integer, float, negative);\n```\n\n### 문자열 (string)\n\n```typescript\nlet greeting: string = 'Hello';\nlet name: string = \"Alice\";\nlet template: string = `Hello, ${name}!`;\n\n// 여러 줄 문자열\nlet multiline: string = `\n  첫 번째 줄\n  두 번째 줄\n  세 번째 줄\n`;\n\nconsole.log(greeting, template);\n```\n\n### 불리언 (boolean)\n\n```typescript\nlet isTrue: boolean = true;\nlet isFalse: boolean = false;\nlet result: boolean = 5 > 3;  // true\nlet check: boolean = 10 === 5; // false\n\nconsole.log(isTrue, result);\n```\n\n### null과 undefined\n\n```typescript\nlet empty: null = null;\nlet notDefined: undefined = undefined;\n\n// strictNullChecks 옵션에 따라 동작이 다름\nlet nullable: string | null = null;\nlet optional: string | undefined = undefined;\n\nconsole.log(empty, notDefined);\n```\n\n## 배열 (Array)\n\n```typescript\n// 타입[] 문법\nlet numbers: number[] = [1, 2, 3, 4, 5];\nlet names: string[] = ['Alice', 'Bob', 'Charlie'];\n\n// Array<타입> 제네릭 문법\nlet scores: Array<number> = [90, 85, 95];\n\n// 혼합 타입 배열\nlet mixed: (string | number)[] = ['Alice', 25, 'Bob', 30];\n\nconsole.log(numbers, names);\n```\n\n## 튜플 (Tuple)\n\n고정된 개수와 타입의 요소를 가진 배열입니다.\n\n```typescript\n// 튜플 선언\nlet person: [string, number] = ['Alice', 25];\nlet rgb: [number, number, number] = [255, 0, 0];\n\nconsole.log(person[0]); // 'Alice'\nconsole.log(person[1]); // 25\n\n// 튜플 구조 분해\nconst [name, age] = person;\nconsole.log(name, age);\n```\n\n## 열거형 (Enum)\n\n```typescript\n// 숫자 열거형\nenum Direction {\n  Up,      // 0\n  Down,    // 1\n  Left,    // 2\n  Right    // 3\n}\n\nlet dir: Direction = Direction.Up;\nconsole.log(dir); // 0\n\n// 문자열 열거형\nenum Color {\n  Red = 'RED',\n  Green = 'GREEN',\n  Blue = 'BLUE'\n}\n\nlet color: Color = Color.Red;\nconsole.log(color); // 'RED'\n```\n\n## any와 unknown\n\n```typescript\n// any: 모든 타입 허용 (타입 체크 비활성화)\nlet anything: any = 'hello';\nanything = 42;\nanything = true;\n\n// unknown: 타입 안전한 any\nlet something: unknown = 'hello';\n// something.toUpperCase(); // 오류!\n\n// 타입 체크 후 사용\nif (typeof something === 'string') {\n  console.log(something.toUpperCase());\n}\n```\n\n## 타입 추론\n\n```typescript\n// 타입을 명시하지 않아도 추론됨\nlet name = 'Alice';      // string으로 추론\nlet age = 25;            // number로 추론\nlet isStudent = true;    // boolean으로 추론\n\n// 배열도 추론됨\nlet numbers = [1, 2, 3]; // number[]로 추론\nlet mixed = [1, 'two'];  // (string | number)[]로 추론\n```\n\n## 타입 별칭 (Type Alias)\n\n```typescript\n// 타입 별칭 정의\ntype ID = string | number;\ntype Point = { x: number; y: number };\ntype Callback = (value: string) => void;\n\nlet userId: ID = 'user123';\nlet position: Point = { x: 10, y: 20 };\n\nconst handleData: Callback = (value) => {\n  console.log(value);\n};\n```\n\n## 타입 단언 (Type Assertion)\n\n```typescript\n// as 문법\nlet value: any = 'hello';\nlet length: number = (value as string).length;\n\n// <타입> 문법 (JSX에서는 사용 불가)\nlet length2: number = (<string>value).length;\n\nconsole.log(length);\n```\n\n## 리터럴 타입\n\n```typescript\n// 문자열 리터럴 타입\nlet direction: 'left' | 'right' | 'up' | 'down';\ndirection = 'left';  // OK\n// direction = 'forward'; // 오류!\n\n// 숫자 리터럴 타입\nlet diceRoll: 1 | 2 | 3 | 4 | 5 | 6;\ndiceRoll = 3;  // OK\n// diceRoll = 7;  // 오류!\n```\n\n## 연습 문제\n\n1. 여러 타입의 변수를 선언하고 출력하세요\n2. 튜플을 사용해 학생 정보(이름, 나이, 학년)를 저장하세요\n3. 타입 별칭을 사용해 사용자 정의 타입을 만드세요\n\n## 핵심 요약\n\n- `let`: 재할당 가능한 변수\n- `const`: 재할당 불가능한 상수\n- `number`: 숫자 타입\n- `string`: 문자열 타입\n- `boolean`: 불리언 타입\n- `number[]` 또는 `Array<number>`: 배열\n- `[string, number]`: 튜플\n- `enum`: 열거형\n- `any`: 모든 타입 허용\n- `unknown`: 타입 안전한 any\n- `type`: 타입 별칭\n- 타입 추론: 자동 타입 결정"
    },
    {
      "chapterId": 3,
      "title": "3단원: 연산자",
      "content": "# 3단원: 연산자\n\n## 산술 연산자 (Arithmetic Operators)\n\n```typescript\nconst a: number = 10;\nconst b: number = 3;\n\nconsole.log(a + b);  // 13 (덧셈)\nconsole.log(a - b);  // 7  (뺄셈)\nconsole.log(a * b);  // 30 (곱셈)\nconsole.log(a / b);  // 3.333... (나눗셈)\nconsole.log(a % b);  // 1  (나머지)\nconsole.log(a ** b); // 1000 (거듭제곱)\n\n// 정수 나눗셈 (내림)\nconsole.log(Math.floor(a / b)); // 3\n```\n\n## 증감 연산자\n\n```typescript\nlet count: number = 5;\n\ncount++;  // count = count + 1\nconsole.log(count);  // 6\n\ncount--;  // count = count - 1\nconsole.log(count);  // 5\n\n// 전위와 후위의 차이\nlet x: number = 5;\nconsole.log(x++);  // 5 출력 후 6이 됨\nconsole.log(++x);  // 7로 증가 후 7 출력\n```\n\n## 비교 연산자 (Comparison Operators)\n\n```typescript\nconst a: number = 10;\nconst b: number = 20;\n\nconsole.log(a == b);   // false (값만 비교)\nconsole.log(a === b);  // false (값과 타입 비교, 권장)\nconsole.log(a != b);   // true  (값만 비교)\nconsole.log(a !== b);  // true  (값과 타입 비교, 권장)\nconsole.log(a > b);    // false (크다)\nconsole.log(a < b);    // true  (작다)\nconsole.log(a >= b);   // false (크거나 같다)\nconsole.log(a <= b);   // true  (작거나 같다)\n\n// == vs ===\nconsole.log(5 == '5');   // true (타입 변환 후 비교)\nconsole.log(5 === '5');  // false (타입까지 비교)\n```\n\n## 논리 연산자 (Logical Operators)\n\n```typescript\nconst isStudent: boolean = true;\nconst hasTicket: boolean = false;\n\n// AND (&&)\nconsole.log(isStudent && hasTicket);  // false\n\n// OR (||)\nconsole.log(isStudent || hasTicket);  // true\n\n// NOT (!)\nconsole.log(!isStudent);  // false\nconsole.log(!hasTicket);  // true\n\n// 복합 조건\nconst age: number = 20;\nconst canDrive: boolean = age >= 18 && hasTicket;\nconsole.log(canDrive);  // false\n```\n\n## 대입 연산자 (Assignment Operators)\n\n```typescript\nlet x: number = 10;\n\nx += 5;   // x = x + 5  -> 15\nconsole.log(x);\n\nx -= 3;   // x = x - 3  -> 12\nconsole.log(x);\n\nx *= 2;   // x = x * 2  -> 24\nconsole.log(x);\n\nx /= 4;   // x = x / 4  -> 6\nconsole.log(x);\n\nx %= 4;   // x = x % 4  -> 2\nconsole.log(x);\n\nx **= 3;  // x = x ** 3 -> 8\nconsole.log(x);\n```\n\n## 비트 연산자 (Bitwise Operators)\n\n```typescript\nconst a: number = 60;  // 0011 1100\nconst b: number = 13;  // 0000 1101\n\n// AND\nconsole.log(a & b);   // 12 (0000 1100)\n\n// OR\nconsole.log(a | b);   // 61 (0011 1101)\n\n// XOR\nconsole.log(a ^ b);   // 49 (0011 0001)\n\n// NOT\nconsole.log(~a);      // -61\n\n// 왼쪽 시프트\nconsole.log(a << 2);  // 240 (1111 0000)\n\n// 오른쪽 시프트\nconsole.log(a >> 2);  // 15 (0000 1111)\n\n// 부호 없는 오른쪽 시프트\nconsole.log(a >>> 2); // 15\n```\n\n## 삼항 연산자 (Ternary Operator)\n\n```typescript\nconst age: number = 20;\nconst status: string = age >= 18 ? '성인' : '미성년자';\nconsole.log(status);  // '성인'\n\n// 중첩 가능\nconst score: number = 85;\nconst grade: string = score >= 90 ? 'A' :\n                      score >= 80 ? 'B' :\n                      score >= 70 ? 'C' : 'F';\nconsole.log(grade);  // 'B'\n```\n\n## null 병합 연산자 (??)\n\n```typescript\nconst name: string | null = null;\nconst defaultName: string = name ?? 'Guest';\nconsole.log(defaultName);  // 'Guest'\n\nconst count: number | null = 0;\nconst displayCount: number = count ?? 10;\nconsole.log(displayCount);  // 0 (0은 null이 아님)\n\n// || vs ??\nconst value1: number = 0 || 10;  // 10 (0은 falsy)\nconst value2: number = 0 ?? 10;  // 0 (null/undefined만 체크)\n```\n\n## 옵셔널 체이닝 (?.)\n\n```typescript\ninterface User {\n  name: string;\n  address?: {\n    city?: string;\n  };\n}\n\nconst user1: User = { name: 'Alice' };\nconst user2: User = {\n  name: 'Bob',\n  address: { city: 'Seoul' }\n};\n\n// 안전한 접근\nconsole.log(user1.address?.city);  // undefined\nconsole.log(user2.address?.city);  // 'Seoul'\n\n// 배열에서도 사용 가능\nconst arr: number[] | null = null;\nconsole.log(arr?.[0]);  // undefined\n\n// 함수 호출에서도 사용 가능\nconst fn: (() => void) | null = null;\nfn?.();  // 함수가 null이면 호출 안 함\n```\n\n## typeof 연산자\n\n```typescript\nconsole.log(typeof 42);          // 'number'\nconsole.log(typeof 'hello');     // 'string'\nconsole.log(typeof true);        // 'boolean'\nconsole.log(typeof undefined);   // 'undefined'\nconsole.log(typeof null);        // 'object' (JavaScript 버그)\nconsole.log(typeof {});          // 'object'\nconsole.log(typeof []);          // 'object'\nconsole.log(typeof function(){}); // 'function'\n```\n\n## 실전 예제\n\n### 온도 변환\n\n```typescript\nfunction celsiusToFahrenheit(celsius: number): number {\n  return celsius * 9 / 5 + 32;\n}\n\nfunction fahrenheitToCelsius(fahrenheit: number): number {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nconst celsius: number = 25;\nconst fahrenheit: number = celsiusToFahrenheit(celsius);\nconsole.log(`${celsius}°C = ${fahrenheit.toFixed(1)}°F`);\n```\n\n### 짝수/홀수 판별\n\n```typescript\nconst number: number = 17;\nconst result: string = number % 2 === 0 ? '짝수' : '홀수';\nconsole.log(`${number}는 ${result}입니다`);\n```\n\n### 안전한 나눗셈\n\n```typescript\nfunction safeDivide(a: number, b: number): number | null {\n  return b !== 0 ? a / b : null;\n}\n\nconst result1 = safeDivide(10, 2);\nconst result2 = safeDivide(10, 0);\n\nconsole.log(result1 ?? '나눗셈 불가');  // 5\nconsole.log(result2 ?? '나눗셈 불가');  // '나눗셈 불가'\n```\n\n## 연습 문제\n\n1. 두 숫자를 받아 사칙연산 결과를 모두 출력하세요\n2. null 병합 연산자를 사용해 기본값을 설정하세요\n3. 옵셔널 체이닝을 사용해 안전하게 객체에 접근하세요\n\n## 핵심 요약\n\n- `+, -, *, /, %, **`: 산술 연산자\n- `++, --`: 증감 연산자\n- `===, !==`: 엄격한 비교 (권장)\n- `==, !=`: 느슨한 비교 (비권장)\n- `&&, ||, !`: 논리 연산자\n- `+=, -=, *=, /=, %=`: 복합 대입 연산자\n- `? :`: 삼항 연산자\n- `??`: null 병합 연산자\n- `?.`: 옵셔널 체이닝\n- `typeof`: 타입 확인"
    },
    {
      "chapterId": 4,
      "title": "4단원: 조건문",
      "content": "# 4단원: 조건문\n\n## if 문\n\n조건이 참일 때 코드 블록을 실행합니다.\n\n```typescript\nconst age: number = 20;\n\nif (age >= 18) {\n  console.log('성인입니다');\n}\n\nconst score: number = 85;\nif (score >= 60) {\n  console.log('합격입니다');\n}\n```\n\n## if-else 문\n\n```typescript\nconst score: number = 75;\n\nif (score >= 80) {\n  console.log('합격입니다');\n} else {\n  console.log('불합격입니다');\n}\n```\n\n## if-else if-else 문\n\n```typescript\nconst score: number = 85;\n\nif (score >= 90) {\n  console.log('A학점');\n} else if (score >= 80) {\n  console.log('B학점');\n} else if (score >= 70) {\n  console.log('C학점');\n} else if (score >= 60) {\n  console.log('D학점');\n} else {\n  console.log('F학점');\n}\n```\n\n## 중첩 조건문\n\n```typescript\nconst age: number = 20;\nconst hasLicense: boolean = true;\n\nif (age >= 18) {\n  if (hasLicense) {\n    console.log('운전할 수 있습니다');\n  } else {\n    console.log('면허가 필요합니다');\n  }\n} else {\n  console.log('성인이 아닙니다');\n}\n\n// 논리 연산자로 간결하게\nif (age >= 18 && hasLicense) {\n  console.log('운전할 수 있습니다');\n}\n```\n\n## switch 문\n\n값에 따라 다른 코드를 실행합니다.\n\n```typescript\nconst grade: string = 'B';\n\nswitch (grade) {\n  case 'A':\n    console.log('우수');\n    break;\n  case 'B':\n    console.log('양호');\n    break;\n  case 'C':\n    console.log('보통');\n    break;\n  default:\n    console.log('재평가 필요');\n}\n```\n\n## switch fall-through\n\n```typescript\nconst month: number = 3;\nlet season: string;\n\nswitch (month) {\n  case 12:\n  case 1:\n  case 2:\n    season = '겨울';\n    break;\n  case 3:\n  case 4:\n  case 5:\n    season = '봄';\n    break;\n  case 6:\n  case 7:\n  case 8:\n    season = '여름';\n    break;\n  case 9:\n  case 10:\n  case 11:\n    season = '가을';\n    break;\n  default:\n    season = '잘못된 월';\n}\n\nconsole.log(`${month}월은 ${season}입니다`);\n```\n\n## 타입 가드 (Type Guard)\n\n```typescript\nfunction processValue(value: string | number) {\n  // typeof 타입 가드\n  if (typeof value === 'string') {\n    console.log(value.toUpperCase());\n  } else {\n    console.log(value.toFixed(2));\n  }\n}\n\nprocessValue('hello');  // HELLO\nprocessValue(3.14159);  // 3.14\n```\n\n## instanceof 타입 가드\n\n```typescript\nclass Dog {\n  bark() {\n    console.log('멍멍!');\n  }\n}\n\nclass Cat {\n  meow() {\n    console.log('야옹~');\n  }\n}\n\nfunction makeSound(animal: Dog | Cat) {\n  if (animal instanceof Dog) {\n    animal.bark();\n  } else {\n    animal.meow();\n  }\n}\n\nmakeSound(new Dog());  // 멍멍!\nmakeSound(new Cat());  // 야옹~\n```\n\n## in 연산자 타입 가드\n\n```typescript\ninterface Bird {\n  fly: () => void;\n  layEggs: () => void;\n}\n\ninterface Fish {\n  swim: () => void;\n  layEggs: () => void;\n}\n\nfunction move(animal: Bird | Fish) {\n  if ('fly' in animal) {\n    animal.fly();\n  } else {\n    animal.swim();\n  }\n}\n```\n\n## 실전 예제\n\n### BMI 계산기\n\n```typescript\nfunction calculateBMI(height: number, weight: number): void {\n  const bmi: number = weight / (height * height);\n  \n  let category: string;\n  if (bmi < 18.5) {\n    category = '저체중';\n  } else if (bmi < 23) {\n    category = '정상';\n  } else if (bmi < 25) {\n    category = '과체중';\n  } else {\n    category = '비만';\n  }\n  \n  console.log(`BMI: ${bmi.toFixed(1)}`);\n  console.log(`분류: ${category}`);\n}\n\ncalculateBMI(1.75, 70);\n```\n\n### 요일 판별\n\n```typescript\nconst day: number = 3;\nlet dayName: string;\n\nswitch (day) {\n  case 1:\n    dayName = '월요일';\n    break;\n  case 2:\n    dayName = '화요일';\n    break;\n  case 3:\n    dayName = '수요일';\n    break;\n  case 4:\n    dayName = '목요일';\n    break;\n  case 5:\n    dayName = '금요일';\n    break;\n  case 6:\n    dayName = '토요일';\n    break;\n  case 7:\n    dayName = '일요일';\n    break;\n  default:\n    dayName = '잘못된 요일';\n}\n\nconsole.log(dayName);\n```\n\n### 간단한 계산기\n\n```typescript\nfunction calculate(a: number, b: number, operator: string): number | null {\n  switch (operator) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '/':\n      return b !== 0 ? a / b : null;\n    default:\n      console.log('잘못된 연산자');\n      return null;\n  }\n}\n\nconsole.log(calculate(10, 5, '+'));  // 15\nconsole.log(calculate(10, 5, '/'));  // 2\nconsole.log(calculate(10, 0, '/'));  // null\n```\n\n### 타입별 처리\n\n```typescript\nfunction formatValue(value: string | number | boolean): string {\n  if (typeof value === 'string') {\n    return `\"${value}\"`;\n  } else if (typeof value === 'number') {\n    return value.toFixed(2);\n  } else {\n    return value ? 'TRUE' : 'FALSE';\n  }\n}\n\nconsole.log(formatValue('hello'));   // \"hello\"\nconsole.log(formatValue(3.14159));   // 3.14\nconsole.log(formatValue(true));      // TRUE\n```\n\n## 연습 문제\n\n1. 점수를 입력받아 학점을 출력하는 함수를 작성하세요\n2. switch 문을 사용해 계절을 판별하는 함수를 작성하세요\n3. 타입 가드를 사용해 다양한 타입을 처리하세요\n\n## 핵심 요약\n\n- `if`: 조건이 참일 때 실행\n- `else`: 조건이 거짓일 때 실행\n- `else if`: 여러 조건 검사\n- `switch-case`: 값에 따른 분기\n- `break`: switch 문 종료\n- `default`: 일치하는 case가 없을 때\n- 타입 가드: `typeof`, `instanceof`, `in`\n- 중첩 조건문으로 복잡한 로직 구현"
    },
    {
      "chapterId": 5,
      "title": "5단원: 반복문",
      "content": "# 5단원: 반복문\n\n## for 문\n\n정해진 횟수만큼 반복합니다.\n\n```typescript\n// 기본 for 문\nfor (let i = 0; i < 5; i++) {\n  console.log(`반복 ${i}`);\n}\n\n// 거꾸로 반복\nfor (let i = 5; i > 0; i--) {\n  console.log(`카운트다운: ${i}`);\n}\n\n// 2씩 증가\nfor (let i = 0; i < 10; i += 2) {\n  console.log(`짝수: ${i}`);\n}\n```\n\n## for...of 문 (배열 순회)\n\n배열이나 이터러블 객체의 요소를 순회합니다.\n\n```typescript\nconst fruits: string[] = ['사과', '바나나', '오렌지'];\n\n// for...of로 순회\nfor (const fruit of fruits) {\n  console.log(fruit);\n}\n\n// 문자열 순회\nconst text: string = 'Hello';\nfor (const char of text) {\n  console.log(char);\n}\n```\n\n## for...in 문 (객체 키 순회)\n\n객체의 키를 순회합니다.\n\n```typescript\nconst person = {\n  name: 'Alice',\n  age: 25,\n  city: 'Seoul'\n};\n\n// for...in으로 키 순회\nfor (const key in person) {\n  console.log(`${key}: ${person[key as keyof typeof person]}`);\n}\n\n// 배열의 인덱스 순회 (권장하지 않음)\nconst arr: number[] = [10, 20, 30];\nfor (const index in arr) {\n  console.log(`${index}: ${arr[index]}`);\n}\n```\n\n## while 문\n\n조건이 참인 동안 반복합니다.\n\n```typescript\nlet count: number = 0;\n\nwhile (count < 5) {\n  console.log(`count: ${count}`);\n  count++;\n}\n\n// 무한 루프 (조심!)\n// while (true) {\n//   console.log('무한 반복');\n// }\n```\n\n## do...while 문\n\n최소 한 번은 실행하고, 조건이 참인 동안 반복합니다.\n\n```typescript\nlet count: number = 0;\n\ndo {\n  console.log(`count: ${count}`);\n  count++;\n} while (count < 5);\n\n// while과의 차이: 조건이 거짓이어도 한 번은 실행\nlet x: number = 10;\ndo {\n  console.log('한 번은 실행됨: ' + x);\n} while (x < 5);\n```\n\n## break 문\n\n반복문을 즉시 종료합니다.\n\n```typescript\n// 특정 값 찾으면 종료\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) {\n    console.log('5를 찾았습니다!');\n    break;\n  }\n  console.log(i);\n}\n\nconsole.log('반복문 종료');\n```\n\n## continue 문\n\n현재 반복을 건너뛰고 다음 반복으로 넘어갑니다.\n\n```typescript\n// 홀수만 출력\nfor (let i = 0; i < 10; i++) {\n  if (i % 2 === 0) {\n    continue;\n  }\n  console.log(`홀수: ${i}`);\n}\n\n// 3의 배수 건너뛰기\nfor (let i = 1; i <= 10; i++) {\n  if (i % 3 === 0) {\n    continue;\n  }\n  console.log(i);\n}\n```\n\n## 배열 메서드 (forEach, map, filter)\n\n```typescript\nconst numbers: number[] = [1, 2, 3, 4, 5];\n\n// forEach: 각 요소에 함수 적용\nnumbers.forEach((num) => {\n  console.log(num * 2);\n});\n\n// map: 변환된 새 배열 생성\nconst doubled: number[] = numbers.map((num) => num * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]\n\n// filter: 조건에 맞는 요소만 선택\nconst evens: number[] = numbers.filter((num) => num % 2 === 0);\nconsole.log(evens);  // [2, 4]\n\n// reduce: 하나의 값으로 축약\nconst sum: number = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum);  // 15\n```\n\n## 중첩 반복문\n\n```typescript\n// 구구단\nfor (let i = 2; i <= 9; i++) {\n  console.log(`\\n${i}단:`);\n  for (let j = 1; j <= 9; j++) {\n    console.log(`${i} × ${j} = ${i * j}`);\n  }\n}\n\n// 별 찍기\nfor (let i = 1; i <= 5; i++) {\n  let stars = '';\n  for (let j = 0; j < i; j++) {\n    stars += '*';\n  }\n  console.log(stars);\n}\n```\n\n## 실전 예제\n\n### 팩토리얼 계산\n\n```typescript\nfunction factorial(n: number): number {\n  let result: number = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(`5! = ${factorial(5)}`);  // 5! = 120\n```\n\n### 피보나치 수열\n\n```typescript\nfunction fibonacci(n: number): number[] {\n  const fib: number[] = [0, 1];\n  \n  for (let i = 2; i < n; i++) {\n    fib.push(fib[i - 1] + fib[i - 2]);\n  }\n  \n  return fib;\n}\n\nconsole.log('피보나치 수열:', fibonacci(10));\n```\n\n### 소수 판별\n\n```typescript\nfunction isPrime(number: number): boolean {\n  if (number < 2) return false;\n  \n  for (let i = 2; i <= number / 2; i++) {\n    if (number % i === 0) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\nconsole.log(`17은(는) ${isPrime(17) ? '소수' : '소수가 아님'}입니다`);\n```\n\n### 배열 합계와 평균\n\n```typescript\nfunction calculateStats(numbers: number[]): { sum: number; average: number } {\n  let sum: number = 0;\n  \n  for (const num of numbers) {\n    sum += num;\n  }\n  \n  const average: number = sum / numbers.length;\n  \n  return { sum, average };\n}\n\nconst numbers: number[] = [10, 20, 30, 40, 50];\nconst stats = calculateStats(numbers);\nconsole.log(`합계: ${stats.sum}`);\nconsole.log(`평균: ${stats.average}`);\n```\n\n### 배열에서 최댓값, 최솟값 찾기\n\n```typescript\nfunction findMinMax(numbers: number[]): { min: number; max: number } {\n  let min: number = numbers[0];\n  let max: number = numbers[0];\n  \n  for (const num of numbers) {\n    if (num < min) min = num;\n    if (num > max) max = num;\n  }\n  \n  return { min, max };\n}\n\nconst numbers: number[] = [5, 2, 8, 1, 9, 3];\nconst result = findMinMax(numbers);\nconsole.log(`최솟값: ${result.min}, 최댓값: ${result.max}`);\n```\n\n### 문자열 역순\n\n```typescript\nfunction reverseString(str: string): string {\n  let reversed: string = '';\n  \n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n  }\n  \n  return reversed;\n}\n\nconsole.log(reverseString('Hello'));  // olleH\n\n// 배열 메서드 사용\nfunction reverseString2(str: string): string {\n  return str.split('').reverse().join('');\n}\n\nconsole.log(reverseString2('World'));  // dlroW\n```\n\n## 연습 문제\n\n1. 1부터 100까지의 합을 구하는 프로그램을 작성하세요\n2. 배열에서 특정 값을 찾는 함수를 작성하세요\n3. map과 filter를 사용해 배열을 변환하세요\n\n## 핵심 요약\n\n- `for`: 정해진 횟수 반복\n- `for...of`: 배열/이터러블 순회\n- `for...in`: 객체 키 순회\n- `while`: 조건이 참인 동안 반복\n- `do...while`: 최소 한 번 실행 후 반복\n- `break`: 반복문 종료\n- `continue`: 현재 반복 건너뛰기\n- `forEach`, `map`, `filter`, `reduce`: 배열 메서드\n- 중첩 반복문으로 복잡한 패턴 구현"
    },
    {
      "chapterId": 6,
      "title": "6단원: 함수",
      "content": "# 6단원: 함수\n\n## 함수 정의\n\n함수는 재사용 가능한 코드 블록입니다.\n\n```typescript\n// 기본 함수\nfunction greet(): void {\n  console.log('안녕하세요!');\n}\n\ngreet();\ngreet();\n```\n\n## 매개변수와 반환값\n\n```typescript\n// 매개변수와 반환값에 타입 지정\nfunction createGreeting(name: string): string {\n  return `안녕하세요, ${name}님!`;\n}\n\nconst message: string = createGreeting('Alice');\nconsole.log(message);\n\n// 여러 매개변수\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\nconst result: number = add(5, 3);\nconsole.log(`5 + 3 = ${result}`);\n```\n\n## 선택적 매개변수 (Optional Parameters)\n\n```typescript\nfunction greet(name: string, age?: number): string {\n  if (age !== undefined) {\n    return `안녕하세요, ${name}님! ${age}세이시군요.`;\n  }\n  return `안녕하세요, ${name}님!`;\n}\n\nconsole.log(greet('Alice'));       // 안녕하세요, Alice님!\nconsole.log(greet('Bob', 30));     // 안녕하세요, Bob님! 30세이시군요.\n```\n\n## 기본 매개변수 (Default Parameters)\n\n```typescript\nfunction power(base: number, exponent: number = 2): number {\n  return Math.pow(base, exponent);\n}\n\nconsole.log(power(2));      // 4 (2^2)\nconsole.log(power(2, 3));   // 8 (2^3)\n\nfunction createUser(name: string, role: string = 'user'): void {\n  console.log(`${name} (${role})`);\n}\n\ncreateUser('Alice');           // Alice (user)\ncreateUser('Bob', 'admin');    // Bob (admin)\n```\n\n## 나머지 매개변수 (Rest Parameters)\n\n```typescript\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3));           // 6\nconsole.log(sum(1, 2, 3, 4, 5));     // 15\n\nfunction introduce(name: string, ...hobbies: string[]): void {\n  console.log(`${name}의 취미: ${hobbies.join(', ')}`);\n}\n\nintroduce('Alice', '독서', '음악', '운동');\n```\n\n## 화살표 함수 (Arrow Function)\n\n```typescript\n// 기본 형태\nconst greet = (): void => {\n  console.log('안녕하세요!');\n};\n\n// 한 줄인 경우 중괄호 생략\nconst square = (n: number): number => n * n;\n\n// 매개변수가 하나면 괄호 생략 가능 (타입 명시 시 괄호 필요)\nconst double = (n: number): number => n * 2;\n\nconsole.log(square(5));   // 25\nconsole.log(double(3));   // 6\n\n// 객체 반환 시 괄호로 감싸기\nconst createPerson = (name: string, age: number) => ({ name, age });\nconsole.log(createPerson('Alice', 25));\n```\n\n## 함수 타입\n\n```typescript\n// 함수 타입 정의\ntype MathOperation = (a: number, b: number) => number;\n\nconst add: MathOperation = (a, b) => a + b;\nconst multiply: MathOperation = (a, b) => a * b;\n\nconsole.log(add(5, 3));       // 8\nconsole.log(multiply(5, 3));  // 15\n\n// 콜백 함수\nfunction calculate(a: number, b: number, operation: MathOperation): number {\n  return operation(a, b);\n}\n\nconsole.log(calculate(10, 5, add));       // 15\nconsole.log(calculate(10, 5, multiply));  // 50\n```\n\n## 함수 오버로딩\n\n```typescript\n// 함수 시그니처 정의\nfunction combine(a: string, b: string): string;\nfunction combine(a: number, b: number): number;\n\n// 구현\nfunction combine(a: string | number, b: string | number): string | number {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a + b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  }\n  throw new Error('Invalid arguments');\n}\n\nconsole.log(combine('Hello', 'World'));  // HelloWorld\nconsole.log(combine(5, 3));              // 8\n```\n\n## 제네릭 함수\n\n```typescript\n// 제네릭 함수\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconsole.log(identity<string>('hello'));  // hello\nconsole.log(identity<number>(42));       // 42\n\n// 배열 제네릭\nfunction getFirst<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\nconsole.log(getFirst([1, 2, 3]));           // 1\nconsole.log(getFirst(['a', 'b', 'c']));     // a\n```\n\n## 재귀 함수\n\n```typescript\n// 팩토리얼\nfunction factorial(n: number): number {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\nconsole.log(`5! = ${factorial(5)}`);  // 5! = 120\n\n// 피보나치 수열\nfunction fibonacci(n: number): number {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconsole.log(`fib(10) = ${fibonacci(10)}`);  // fib(10) = 55\n```\n\n## 실전 예제\n\n### 계산기 함수\n\n```typescript\nfunction calculator(a: number, b: number, operator: string): number | null {\n  switch (operator) {\n    case '+':\n      return a + b;\n    case '-':\n      return a - b;\n    case '*':\n      return a * b;\n    case '/':\n      return b !== 0 ? a / b : null;\n    default:\n      return null;\n  }\n}\n\nconsole.log(calculator(10, 5, '+'));  // 15\nconsole.log(calculator(10, 5, '/'));  // 2\n```\n\n### 배열 처리 함수\n\n```typescript\nfunction arrayStats(numbers: number[]): {\n  sum: number;\n  average: number;\n  min: number;\n  max: number;\n} {\n  const sum = numbers.reduce((acc, num) => acc + num, 0);\n  const average = sum / numbers.length;\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  \n  return { sum, average, min, max };\n}\n\nconst numbers: number[] = [1, 2, 3, 4, 5];\nconst stats = arrayStats(numbers);\nconsole.log(stats);\n// { sum: 15, average: 3, min: 1, max: 5 }\n```\n\n### 문자열 처리 함수\n\n```typescript\nfunction reverseString(str: string): string {\n  return str.split('').reverse().join('');\n}\n\nfunction isPalindrome(str: string): boolean {\n  const reversed = reverseString(str);\n  return str === reversed;\n}\n\nconsole.log(reverseString('Hello'));      // olleH\nconsole.log(isPalindrome('radar'));       // true\nconsole.log(isPalindrome('hello'));       // false\n```\n\n### 고차 함수\n\n```typescript\n// 함수를 반환하는 함수\nfunction multiplier(factor: number): (n: number) => number {\n  return (n: number) => n * factor;\n}\n\nconst double = multiplier(2);\nconst triple = multiplier(3);\n\nconsole.log(double(5));  // 10\nconsole.log(triple(5));  // 15\n\n// 함수를 인자로 받는 함수\nfunction repeat(fn: () => void, times: number): void {\n  for (let i = 0; i < times; i++) {\n    fn();\n  }\n}\n\nrepeat(() => console.log('Hello'), 3);\n```\n\n## 연습 문제\n\n1. 두 숫자 중 큰 값을 반환하는 함수를 작성하세요\n2. 배열에서 특정 값을 찾아 인덱스를 반환하는 제네릭 함수를 작성하세요\n3. 재귀 함수로 1부터 n까지의 합을 구하세요\n\n## 핵심 요약\n\n- `function 이름(매개변수: 타입): 반환타입`: 함수 정의\n- `parameter?`: 선택적 매개변수\n- `parameter = 기본값`: 기본 매개변수\n- `...rest`: 나머지 매개변수\n- `() => {}`: 화살표 함수\n- `type FuncType = () => void`: 함수 타입\n- 함수 오버로딩: 여러 시그니처\n- `<T>`: 제네릭\n- 재귀: 함수가 자기 자신 호출\n- 고차 함수: 함수를 인자로 받거나 반환"
    },
    {
      "chapterId": 7,
      "title": "7단원: 리스트·배열·컬렉션",
      "content": "# 7단원: 리스트·배열·컬렉션\n\n## 배열 기본\n\nTypeScript의 배열은 같은 타입의 요소를 순서대로 저장합니다.\n\n```typescript\n// 배열 선언\nconst numbers: number[] = [1, 2, 3, 4, 5];\nconst fruits: string[] = ['사과', '바나나', '오렌지'];\n\n// 제네릭 문법\nconst scores: Array<number> = [90, 85, 95];\n\n// 빈 배열\nconst emptyArray: number[] = [];\n\nconsole.log(numbers);\nconsole.log(fruits);\n```\n\n## 배열 접근과 수정\n\n```typescript\nconst fruits: string[] = ['사과', '바나나', '오렌지', '포도'];\n\n// 인덱스로 접근\nconsole.log(fruits[0]);  // '사과'\nconsole.log(fruits[2]);  // '오렌지'\n\n// 마지막 요소\nconsole.log(fruits[fruits.length - 1]);  // '포도'\n\n// 값 수정\nfruits[0] = '딸기';\nconsole.log(fruits);  // ['딸기', '바나나', '오렌지', '포도']\n\n// 배열 길이\nconsole.log(fruits.length);  // 4\n```\n\n## 배열 메서드\n\n### 추가/삭제\n\n```typescript\nconst fruits: string[] = ['사과', '바나나'];\n\n// push: 끝에 추가\nfruits.push('오렌지');\nconsole.log(fruits);  // ['사과', '바나나', '오렌지']\n\n// pop: 끝에서 제거\nconst last = fruits.pop();\nconsole.log(last);     // '오렌지'\nconsole.log(fruits);   // ['사과', '바나나']\n\n// unshift: 앞에 추가\nfruits.unshift('포도');\nconsole.log(fruits);   // ['포도', '사과', '바나나']\n\n// shift: 앞에서 제거\nconst first = fruits.shift();\nconsole.log(first);    // '포도'\nconsole.log(fruits);   // ['사과', '바나나']\n```\n\n### splice와 slice\n\n```typescript\nconst numbers: number[] = [1, 2, 3, 4, 5];\n\n// splice: 요소 추가/제거 (원본 변경)\nconst removed = numbers.splice(2, 2);  // 인덱스 2부터 2개 제거\nconsole.log(removed);   // [3, 4]\nconsole.log(numbers);   // [1, 2, 5]\n\nnumbers.splice(1, 0, 10, 20);  // 인덱스 1에 10, 20 추가\nconsole.log(numbers);   // [1, 10, 20, 2, 5]\n\n// slice: 부분 배열 추출 (원본 유지)\nconst arr: number[] = [1, 2, 3, 4, 5];\nconst sliced = arr.slice(1, 4);  // 인덱스 1부터 4 전까지\nconsole.log(sliced);    // [2, 3, 4]\nconsole.log(arr);       // [1, 2, 3, 4, 5] (원본 유지)\n```\n\n## 배열 검색\n\n```typescript\nconst numbers: number[] = [10, 20, 30, 40, 50];\n\n// indexOf: 첫 번째 인덱스\nconsole.log(numbers.indexOf(30));    // 2\nconsole.log(numbers.indexOf(100));   // -1 (없음)\n\n// includes: 포함 여부\nconsole.log(numbers.includes(30));   // true\nconsole.log(numbers.includes(100));  // false\n\n// find: 조건에 맞는 첫 번째 요소\nconst found = numbers.find(n => n > 25);\nconsole.log(found);  // 30\n\n// findIndex: 조건에 맞는 첫 번째 인덱스\nconst index = numbers.findIndex(n => n > 25);\nconsole.log(index);  // 2\n```\n\n## 배열 변환\n\n```typescript\nconst numbers: number[] = [1, 2, 3, 4, 5];\n\n// map: 각 요소 변환\nconst doubled = numbers.map(n => n * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]\n\n// filter: 조건에 맞는 요소만 선택\nconst evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens);  // [2, 4]\n\n// reduce: 하나의 값으로 축약\nconst sum = numbers.reduce((acc, n) => acc + n, 0);\nconsole.log(sum);  // 15\n\nconst product = numbers.reduce((acc, n) => acc * n, 1);\nconsole.log(product);  // 120\n```\n\n## 배열 정렬\n\n```typescript\nconst numbers: number[] = [5, 2, 8, 1, 9, 3];\n\n// 오름차순 정렬\nconst sorted1 = [...numbers].sort((a, b) => a - b);\nconsole.log(sorted1);  // [1, 2, 3, 5, 8, 9]\n\n// 내림차순 정렬\nconst sorted2 = [...numbers].sort((a, b) => b - a);\nconsole.log(sorted2);  // [9, 8, 5, 3, 2, 1]\n\n// 문자열 정렬\nconst fruits: string[] = ['banana', 'apple', 'orange'];\nconst sortedFruits = [...fruits].sort();\nconsole.log(sortedFruits);  // ['apple', 'banana', 'orange']\n```\n\n## 배열 합치기\n\n```typescript\nconst arr1: number[] = [1, 2, 3];\nconst arr2: number[] = [4, 5, 6];\n\n// concat\nconst combined1 = arr1.concat(arr2);\nconsole.log(combined1);  // [1, 2, 3, 4, 5, 6]\n\n// 스프레드 연산자\nconst combined2 = [...arr1, ...arr2];\nconsole.log(combined2);  // [1, 2, 3, 4, 5, 6]\n```\n\n## 다차원 배열\n\n```typescript\n// 2차원 배열\nconst matrix: number[][] = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nconsole.log(matrix[0][0]);  // 1\nconsole.log(matrix[1][2]);  // 6\n\n// 순회\nfor (const row of matrix) {\n  for (const value of row) {\n    console.log(value);\n  }\n}\n```\n\n## 튜플 (Tuple)\n\n```typescript\n// 튜플: 고정된 타입과 길이\nconst person: [string, number] = ['Alice', 25];\nconst rgb: [number, number, number] = [255, 0, 0];\n\nconsole.log(person[0]);  // 'Alice'\nconsole.log(person[1]);  // 25\n\n// 구조 분해\nconst [name, age] = person;\nconsole.log(name, age);\n\n// readonly 튜플\nconst point: readonly [number, number] = [10, 20];\n// point[0] = 30;  // 오류!\n```\n\n## 실전 예제\n\n### 중복 제거\n\n```typescript\nfunction removeDuplicates<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n\nconst numbers: number[] = [1, 2, 2, 3, 3, 3, 4, 5, 5];\nconsole.log(removeDuplicates(numbers));  // [1, 2, 3, 4, 5]\n```\n\n### 배열 평탄화 (Flatten)\n\n```typescript\nconst nested: number[][] = [[1, 2], [3, 4], [5, 6]];\n\n// flat 메서드\nconst flattened1 = nested.flat();\nconsole.log(flattened1);  // [1, 2, 3, 4, 5, 6]\n\n// reduce 사용\nconst flattened2 = nested.reduce((acc, arr) => [...acc, ...arr], []);\nconsole.log(flattened2);  // [1, 2, 3, 4, 5, 6]\n```\n\n### 배열 그룹핑\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n\nfunction groupBy<T>(arr: T[], key: keyof T): Record<string, T[]> {\n  return arr.reduce((groups, item) => {\n    const value = String(item[key]);\n    return {\n      ...groups,\n      [value]: [...(groups[value] || []), item]\n    };\n  }, {} as Record<string, T[]>);\n}\n\nconst people: Person[] = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 25 }\n];\n\nconst grouped = groupBy(people, 'age');\nconsole.log(grouped);\n// { '25': [...], '30': [...] }\n```\n\n## 연습 문제\n\n1. 배열의 최댓값과 최솟값을 찾는 함수를 작성하세요\n2. 배열에서 특정 값을 모두 제거하는 함수를 작성하세요\n3. 두 배열의 교집합을 구하는 함수를 작성하세요\n\n## 핵심 요약\n\n- `number[]` 또는 `Array<number>`: 배열 타입\n- `push()`, `pop()`: 끝에 추가/제거\n- `unshift()`, `shift()`: 앞에 추가/제거\n- `splice()`: 추가/제거 (원본 변경)\n- `slice()`: 부분 추출 (원본 유지)\n- `map()`, `filter()`, `reduce()`: 배열 변환\n- `find()`, `findIndex()`: 검색\n- `sort()`: 정렬\n- `[타입1, 타입2]`: 튜플\n- `...`: 스프레드 연산자"
    },
    {
      "chapterId": 8,
      "title": "8단원: 딕셔너리·맵·세트",
      "content": "# 8단원: 딕셔너리·맵·세트\n\n## 객체 (Object)\n\nTypeScript에서 객체는 키-값 쌍으로 데이터를 저장합니다.\n\n```typescript\n// 객체 생성\nconst person: { name: string; age: number } = {\n  name: 'Alice',\n  age: 25\n};\n\nconsole.log(person.name);  // 'Alice'\nconsole.log(person.age);   // 25\n\n// 인터페이스 사용\ninterface Person {\n  name: string;\n  age: number;\n  city?: string;  // 선택적 속성\n}\n\nconst person2: Person = {\n  name: 'Bob',\n  age: 30,\n  city: 'Seoul'\n};\n```\n\n## Map\n\nMap은 키-값 쌍을 저장하는 컬렉션입니다.\n\n```typescript\n// Map 생성\nconst ages = new Map<string, number>();\n\n// 요소 추가\nages.set('Alice', 25);\nages.set('Bob', 30);\nages.set('Charlie', 35);\n\nconsole.log(ages);\n\n// 값 가져오기\nconsole.log(ages.get('Alice'));  // 25\nconsole.log(ages.get('David'));  // undefined\n\n// 초기값과 함께 생성\nconst scores = new Map<string, number>([\n  ['math', 90],\n  ['english', 85],\n  ['science', 95]\n]);\n```\n\n## Map 메서드\n\n```typescript\nconst map = new Map<string, number>();\nmap.set('a', 1);\nmap.set('b', 2);\nmap.set('c', 3);\n\n// 키 존재 확인\nconsole.log(map.has('a'));     // true\nconsole.log(map.has('d'));     // false\n\n// 크기\nconsole.log(map.size);         // 3\n\n// 삭제\nmap.delete('b');\nconsole.log(map.size);         // 2\n\n// 전체 삭제\nmap.clear();\nconsole.log(map.size);         // 0\n```\n\n## Map 순회\n\n```typescript\nconst scores = new Map<string, number>([\n  ['Alice', 90],\n  ['Bob', 85],\n  ['Charlie', 95]\n]);\n\n// forEach\nscores.forEach((score, name) => {\n  console.log(`${name}: ${score}`);\n});\n\n// for...of로 키 순회\nfor (const name of scores.keys()) {\n  console.log(name);\n}\n\n// for...of로 값 순회\nfor (const score of scores.values()) {\n  console.log(score);\n}\n\n// for...of로 엔트리 순회\nfor (const [name, score] of scores.entries()) {\n  console.log(`${name}: ${score}`);\n}\n\n// 간단한 형태\nfor (const [name, score] of scores) {\n  console.log(`${name}: ${score}`);\n}\n```\n\n## Set\n\nSet은 중복되지 않는 값들의 집합입니다.\n\n```typescript\n// Set 생성\nconst numbers = new Set<number>();\n\n// 요소 추가\nnumbers.add(1);\nnumbers.add(2);\nnumbers.add(3);\nnumbers.add(2);  // 중복은 무시됨\n\nconsole.log(numbers);  // Set { 1, 2, 3 }\n\n// 초기값과 함께 생성\nconst fruits = new Set<string>(['사과', '바나나', '오렌지']);\nconsole.log(fruits);\n```\n\n## Set 메서드\n\n```typescript\nconst set = new Set<number>([1, 2, 3, 4, 5]);\n\n// 포함 여부\nconsole.log(set.has(3));      // true\nconsole.log(set.has(10));     // false\n\n// 크기\nconsole.log(set.size);        // 5\n\n// 삭제\nset.delete(3);\nconsole.log(set.size);        // 4\n\n// 전체 삭제\nset.clear();\nconsole.log(set.size);        // 0\n```\n\n## Set 집합 연산\n\n```typescript\nconst setA = new Set<number>([1, 2, 3, 4, 5]);\nconst setB = new Set<number>([4, 5, 6, 7, 8]);\n\n// 합집합\nconst union = new Set([...setA, ...setB]);\nconsole.log(union);  // Set { 1, 2, 3, 4, 5, 6, 7, 8 }\n\n// 교집합\nconst intersection = new Set(\n  [...setA].filter(x => setB.has(x))\n);\nconsole.log(intersection);  // Set { 4, 5 }\n\n// 차집합\nconst difference = new Set(\n  [...setA].filter(x => !setB.has(x))\n);\nconsole.log(difference);  // Set { 1, 2, 3 }\n```\n\n## Record 타입\n\n```typescript\n// Record<K, V>: 키-값 타입 정의\ntype Scores = Record<string, number>;\n\nconst scores: Scores = {\n  math: 90,\n  english: 85,\n  science: 95\n};\n\nconsole.log(scores.math);  // 90\n\n// 제한된 키\ntype Subject = 'math' | 'english' | 'science';\ntype StudentScores = Record<Subject, number>;\n\nconst studentScores: StudentScores = {\n  math: 90,\n  english: 85,\n  science: 95\n  // 다른 키는 추가 불가\n};\n```\n\n## WeakMap과 WeakSet\n\n```typescript\n// WeakMap: 객체만 키로 사용 가능\nconst weakMap = new WeakMap<object, string>();\n\nconst key1 = { id: 1 };\nconst key2 = { id: 2 };\n\nweakMap.set(key1, 'value1');\nweakMap.set(key2, 'value2');\n\nconsole.log(weakMap.get(key1));  // 'value1'\n\n// WeakSet: 객체만 저장 가능\nconst weakSet = new WeakSet<object>();\n\nconst obj1 = { name: 'Alice' };\nconst obj2 = { name: 'Bob' };\n\nweakSet.add(obj1);\nweakSet.add(obj2);\n\nconsole.log(weakSet.has(obj1));  // true\n```\n\n## 실전 예제\n\n### 단어 빈도수 세기\n\n```typescript\nfunction countWords(text: string): Map<string, number> {\n  const words = text.toLowerCase().split(/\\s+/);\n  const wordCount = new Map<string, number>();\n  \n  for (const word of words) {\n    wordCount.set(word, (wordCount.get(word) || 0) + 1);\n  }\n  \n  return wordCount;\n}\n\nconst text = 'apple banana apple cherry banana apple';\nconst count = countWords(text);\nconsole.log(count);\n// Map { 'apple' => 3, 'banana' => 2, 'cherry' => 1 }\n```\n\n### 전화번호부\n\n```typescript\nclass PhoneBook {\n  private contacts: Map<string, string>;\n  \n  constructor() {\n    this.contacts = new Map();\n  }\n  \n  add(name: string, phone: string): void {\n    this.contacts.set(name, phone);\n  }\n  \n  find(name: string): string | undefined {\n    return this.contacts.get(name);\n  }\n  \n  remove(name: string): boolean {\n    return this.contacts.delete(name);\n  }\n  \n  list(): void {\n    this.contacts.forEach((phone, name) => {\n      console.log(`${name}: ${phone}`);\n    });\n  }\n}\n\nconst phonebook = new PhoneBook();\nphonebook.add('Alice', '010-1234-5678');\nphonebook.add('Bob', '010-2345-6789');\nphonebook.list();\n```\n\n### 중복 제거\n\n```typescript\nfunction removeDuplicates<T>(arr: T[]): T[] {\n  return [...new Set(arr)];\n}\n\nconst numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5];\nconsole.log(removeDuplicates(numbers));  // [1, 2, 3, 4, 5]\n\nconst words = ['apple', 'banana', 'apple', 'cherry'];\nconsole.log(removeDuplicates(words));  // ['apple', 'banana', 'cherry']\n```\n\n### 캐시 구현\n\n```typescript\nclass Cache<K, V> {\n  private cache: Map<K, V>;\n  private maxSize: number;\n  \n  constructor(maxSize: number) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n  \n  set(key: K, value: V): void {\n    if (this.cache.size >= this.maxSize) {\n      // 가장 오래된 항목 제거\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n  \n  get(key: K): V | undefined {\n    return this.cache.get(key);\n  }\n  \n  has(key: K): boolean {\n    return this.cache.has(key);\n  }\n}\n\nconst cache = new Cache<string, number>(3);\ncache.set('a', 1);\ncache.set('b', 2);\ncache.set('c', 3);\ncache.set('d', 4);  // 'a'가 제거됨\n\nconsole.log(cache.has('a'));  // false\nconsole.log(cache.has('d'));  // true\n```\n\n## 연습 문제\n\n1. Map을 사용해 학생 정보를 저장하고 조회하세요\n2. Set을 사용해 두 배열의 교집합을 구하세요\n3. 문자열에서 각 문자의 등장 횟수를 Map으로 만드세요\n\n## 핵심 요약\n\n- 객체: `{ key: value }` 형태\n- `Map<K, V>`: 키-값 쌍 컬렉션\n- `set()`, `get()`, `has()`: Map 메서드\n- `Set<T>`: 중복 없는 집합\n- `add()`, `has()`, `delete()`: Set 메서드\n- `Record<K, V>`: 객체 타입 정의\n- `WeakMap`, `WeakSet`: 약한 참조\n- Map/Set은 순회 순서 보장\n- `...`: 스프레드로 배열 변환"
    },
    {
      "chapterId": 9,
      "title": "9단원: 입출력",
      "content": "# 9단원: 입출력\n\n## Node.js 환경에서의 입출력\n\nTypeScript는 주로 Node.js 환경에서 실행됩니다.\n\n### 콘솔 입력 (readline)\n\n```typescript\nimport * as readline from 'readline';\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.question('이름을 입력하세요: ', (name) => {\n  console.log(`안녕하세요, ${name}님!`);\n  \n  rl.question('나이를 입력하세요: ', (age) => {\n    console.log(`${age}세이시군요.`);\n    rl.close();\n  });\n});\n```\n\n### Promise 기반 입력\n\n```typescript\nimport * as readline from 'readline';\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction question(prompt: string): Promise<string> {\n  return new Promise((resolve) => {\n    rl.question(prompt, (answer) => {\n      resolve(answer);\n    });\n  });\n}\n\nasync function main() {\n  const name = await question('이름을 입력하세요: ');\n  const age = await question('나이를 입력하세요: ');\n  \n  console.log(`${name}님은 ${age}세입니다.`);\n  rl.close();\n}\n\nmain();\n```\n\n## 파일 입출력 (fs)\n\n### 파일 쓰기\n\n```typescript\nimport * as fs from 'fs';\n\n// 동기 방식\ntry {\n  fs.writeFileSync('output.txt', 'Hello, TypeScript!\\n');\n  console.log('파일 쓰기 완료');\n} catch (error) {\n  console.error('파일 쓰기 오류:', error);\n}\n\n// 비동기 방식\nfs.writeFile('output.txt', 'Hello, File!\\n', (error) => {\n  if (error) {\n    console.error('파일 쓰기 오류:', error);\n  } else {\n    console.log('파일 쓰기 완료');\n  }\n});\n\n// Promise 방식\nimport { promises as fsPromises } from 'fs';\n\nasync function writeFileAsync() {\n  try {\n    await fsPromises.writeFile('output.txt', 'Hello, Async!\\n');\n    console.log('파일 쓰기 완료');\n  } catch (error) {\n    console.error('파일 쓰기 오류:', error);\n  }\n}\n```\n\n### 파일 읽기\n\n```typescript\nimport * as fs from 'fs';\n\n// 동기 방식\ntry {\n  const data = fs.readFileSync('output.txt', 'utf8');\n  console.log('파일 내용:');\n  console.log(data);\n} catch (error) {\n  console.error('파일 읽기 오류:', error);\n}\n\n// 비동기 방식\nfs.readFile('output.txt', 'utf8', (error, data) => {\n  if (error) {\n    console.error('파일 읽기 오류:', error);\n  } else {\n    console.log('파일 내용:');\n    console.log(data);\n  }\n});\n\n// Promise 방식\nimport { promises as fsPromises } from 'fs';\n\nasync function readFileAsync() {\n  try {\n    const data = await fsPromises.readFile('output.txt', 'utf8');\n    console.log('파일 내용:');\n    console.log(data);\n  } catch (error) {\n    console.error('파일 읽기 오류:', error);\n  }\n}\n```\n\n### 파일 추가\n\n```typescript\nimport * as fs from 'fs';\n\n// appendFile: 파일에 내용 추가\nfs.appendFile('log.txt', '새 로그 내용\\n', (error) => {\n  if (error) {\n    console.error('파일 추가 오류:', error);\n  } else {\n    console.log('내용 추가 완료');\n  }\n});\n\n// 동기 방식\nfs.appendFileSync('log.txt', '동기 로그\\n');\n```\n\n## JSON 파일 처리\n\n```typescript\nimport * as fs from 'fs';\nimport { promises as fsPromises } from 'fs';\n\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n}\n\n// JSON 파일 쓰기\nconst user: User = {\n  name: 'Alice',\n  age: 25,\n  email: 'alice@example.com'\n};\n\nconst jsonString = JSON.stringify(user, null, 2);\nfs.writeFileSync('user.json', jsonString);\n\n// JSON 파일 읽기\nconst fileContent = fs.readFileSync('user.json', 'utf8');\nconst loadedUser: User = JSON.parse(fileContent);\nconsole.log(loadedUser);\n\n// async/await 사용\nasync function saveJSON(filename: string, data: any): Promise<void> {\n  const jsonString = JSON.stringify(data, null, 2);\n  await fsPromises.writeFile(filename, jsonString);\n}\n\nasync function loadJSON<T>(filename: string): Promise<T> {\n  const content = await fsPromises.readFile(filename, 'utf8');\n  return JSON.parse(content) as T;\n}\n```\n\n## 파일 존재 확인\n\n```typescript\nimport * as fs from 'fs';\nimport { promises as fsPromises } from 'fs';\n\n// 동기 방식\nif (fs.existsSync('test.txt')) {\n  console.log('파일이 존재합니다');\n} else {\n  console.log('파일이 존재하지 않습니다');\n}\n\n// async/await 방식\nasync function fileExists(path: string): Promise<boolean> {\n  try {\n    await fsPromises.access(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst exists = await fileExists('test.txt');\nconsole.log(exists);\n```\n\n## 디렉토리 작업\n\n```typescript\nimport * as fs from 'fs';\nimport { promises as fsPromises } from 'fs';\n\n// 디렉토리 생성\nif (!fs.existsSync('my_folder')) {\n  fs.mkdirSync('my_folder');\n  console.log('디렉토리 생성');\n}\n\n// 디렉토리 내 파일 목록\nconst files = fs.readdirSync('.');\nfor (const file of files) {\n  console.log(file);\n}\n\n// async/await 방식\nasync function listFiles(dir: string): Promise<string[]> {\n  return await fsPromises.readdir(dir);\n}\n\nconst fileList = await listFiles('.');\nconsole.log(fileList);\n```\n\n## 실전 예제\n\n### 간단한 메모장\n\n```typescript\nimport * as readline from 'readline';\nimport * as fs from 'fs';\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst MEMO_FILE = 'memo.txt';\n\nfunction showMenu() {\n  console.log('\\n=== 메모장 ===');\n  console.log('1. 메모 읽기');\n  console.log('2. 메모 쓰기');\n  console.log('3. 종료');\n  rl.question('선택: ', handleChoice);\n}\n\nfunction handleChoice(choice: string) {\n  switch (choice.trim()) {\n    case '1':\n      readMemo();\n      break;\n    case '2':\n      rl.question('메모 내용: ', writeMemo);\n      break;\n    case '3':\n      console.log('프로그램을 종료합니다.');\n      rl.close();\n      break;\n    default:\n      console.log('잘못된 선택입니다.');\n      showMenu();\n  }\n}\n\nfunction readMemo() {\n  if (fs.existsSync(MEMO_FILE)) {\n    const content = fs.readFileSync(MEMO_FILE, 'utf8');\n    console.log('\\n--- 저장된 메모 ---');\n    console.log(content);\n  } else {\n    console.log('저장된 메모가 없습니다.');\n  }\n  showMenu();\n}\n\nfunction writeMemo(content: string) {\n  fs.appendFileSync(MEMO_FILE, content + '\\n');\n  console.log('메모가 저장되었습니다.');\n  showMenu();\n}\n\nshowMenu();\n```\n\n### 로그 시스템\n\n```typescript\nimport * as fs from 'fs';\n\nclass Logger {\n  private logFile: string;\n  \n  constructor(filename: string) {\n    this.logFile = filename;\n  }\n  \n  private getTimestamp(): string {\n    return new Date().toISOString();\n  }\n  \n  log(message: string): void {\n    const entry = `[${this.getTimestamp()}] INFO: ${message}\\n`;\n    fs.appendFileSync(this.logFile, entry);\n  }\n  \n  error(message: string): void {\n    const entry = `[${this.getTimestamp()}] ERROR: ${message}\\n`;\n    fs.appendFileSync(this.logFile, entry);\n  }\n  \n  warn(message: string): void {\n    const entry = `[${this.getTimestamp()}] WARN: ${message}\\n`;\n    fs.appendFileSync(this.logFile, entry);\n  }\n}\n\nconst logger = new Logger('app.log');\nlogger.log('프로그램 시작');\nlogger.warn('경고 메시지');\nlogger.error('오류 발생');\nlogger.log('프로그램 종료');\n```\n\n### CSV 파일 처리\n\n```typescript\nimport * as fs from 'fs';\n\ninterface CsvRow {\n  [key: string]: string;\n}\n\nfunction writeCSV(filename: string, data: CsvRow[]): void {\n  if (data.length === 0) return;\n  \n  // 헤더\n  const headers = Object.keys(data[0]);\n  let csv = headers.join(',') + '\\n';\n  \n  // 데이터\n  for (const row of data) {\n    const values = headers.map(header => row[header]);\n    csv += values.join(',') + '\\n';\n  }\n  \n  fs.writeFileSync(filename, csv);\n}\n\nfunction readCSV(filename: string): CsvRow[] {\n  const content = fs.readFileSync(filename, 'utf8');\n  const lines = content.trim().split('\\n');\n  \n  if (lines.length === 0) return [];\n  \n  const headers = lines[0].split(',');\n  const data: CsvRow[] = [];\n  \n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row: CsvRow = {};\n    \n    for (let j = 0; j < headers.length; j++) {\n      row[headers[j]] = values[j];\n    }\n    \n    data.push(row);\n  }\n  \n  return data;\n}\n\n// 사용 예시\nconst users: CsvRow[] = [\n  { name: 'Alice', age: '25', city: 'Seoul' },\n  { name: 'Bob', age: '30', city: 'Busan' }\n];\n\nwriteCSV('users.csv', users);\nconst loadedUsers = readCSV('users.csv');\nconsole.log(loadedUsers);\n```\n\n## 연습 문제\n\n1. 파일에 여러 줄의 텍스트를 저장하는 프로그램을 작성하세요\n2. JSON 파일에서 데이터를 읽어 필터링하는 함수를 작성하세요\n3. 특정 디렉토리의 모든 파일 크기를 계산하세요\n\n## 핵심 요약\n\n- `readline`: 콘솔 입력\n- `fs.readFile()`, `fs.writeFile()`: 파일 읽기/쓰기\n- `fs.appendFile()`: 파일에 추가\n- `fs.readFileSync()`: 동기 읽기\n- `promises.readFile()`: Promise 기반\n- `JSON.stringify()`, `JSON.parse()`: JSON 변환\n- `fs.existsSync()`: 파일 존재 확인\n- `fs.readdir()`: 디렉토리 내용\n- async/await로 비동기 처리"
    },
    {
      "chapterId": 10,
      "title": "10단원: 예외처리·오류 관리",
      "content": "# 10단원: 예외처리·오류 관리\n\n## 예외란?\n\n프로그램 실행 중 발생하는 오류를 예외(Exception)라고 합니다.\n\n```typescript\n// 예외 발생 예시\nfunction divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('0으로 나눌 수 없습니다');\n  }\n  return a / b;\n}\n\n// divide(10, 0);  // Error 발생!\n```\n\n## try-catch 문\n\n예외를 처리하여 프로그램이 중단되지 않도록 합니다.\n\n```typescript\ntry {\n  const result = divide(10, 0);\n  console.log(result);\n} catch (error) {\n  console.log('오류 발생:', error);\n}\n\nconsole.log('프로그램 계속 실행');\n```\n\n## Error 타입\n\n```typescript\ntry {\n  throw new Error('예외 발생!');\n} catch (error) {\n  // error의 타입 체크\n  if (error instanceof Error) {\n    console.log('메시지:', error.message);\n    console.log('스택:', error.stack);\n  }\n}\n\n// unknown 타입으로 처리\ntry {\n  someFunction();\n} catch (error: unknown) {\n  if (error instanceof Error) {\n    console.log(error.message);\n  } else {\n    console.log('알 수 없는 오류');\n  }\n}\n```\n\n## finally 블록\n\n예외 발생 여부와 관계없이 항상 실행됩니다.\n\n```typescript\nfunction readFile(filename: string): string {\n  console.log('파일 열기');\n  \n  try {\n    if (!filename) {\n      throw new Error('파일명이 없습니다');\n    }\n    // 파일 읽기 로직\n    return '파일 내용';\n  } catch (error) {\n    console.log('오류:', error);\n    return '';\n  } finally {\n    console.log('finally 블록 실행 (항상 실행됨)');\n  }\n}\n\nreadFile('');\n```\n\n## 사용자 정의 예외\n\n```typescript\n// 사용자 정의 Error 클래스\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass InsufficientFundsError extends Error {\n  constructor(\n    message: string,\n    public balance: number,\n    public amount: number\n  ) {\n    super(message);\n    this.name = 'InsufficientFundsError';\n  }\n}\n\nfunction withdraw(balance: number, amount: number): number {\n  if (amount <= 0) {\n    throw new ValidationError('출금액은 양수여야 합니다');\n  }\n  \n  if (amount > balance) {\n    throw new InsufficientFundsError(\n      `잔액 부족: 잔액 ${balance}원, 출금 시도 ${amount}원`,\n      balance,\n      amount\n    );\n  }\n  \n  return balance - amount;\n}\n\ntry {\n  withdraw(1000, 1500);\n} catch (error) {\n  if (error instanceof InsufficientFundsError) {\n    console.log(error.message);\n    console.log(`부족 금액: ${error.amount - error.balance}원`);\n  } else if (error instanceof ValidationError) {\n    console.log('입력 오류:', error.message);\n  } else {\n    console.log('알 수 없는 오류');\n  }\n}\n```\n\n## Result 타입 패턴\n\nTypeScript에서는 예외 대신 Result 타입을 사용할 수 있습니다.\n\n```typescript\n// Result 타입 정의\ntype Result<T, E = Error> = \n  | { success: true; value: T }\n  | { success: false; error: E };\n\nfunction safeDivide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return {\n      success: false,\n      error: new Error('0으로 나눌 수 없습니다')\n    };\n  }\n  \n  return {\n    success: true,\n    value: a / b\n  };\n}\n\nconst result = safeDivide(10, 2);\nif (result.success) {\n  console.log('결과:', result.value);\n} else {\n  console.log('오류:', result.error.message);\n}\n```\n\n## 비동기 예외 처리\n\n### Promise\n\n```typescript\nfunction asyncOperation(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.5;\n      if (success) {\n        resolve('성공!');\n      } else {\n        reject(new Error('실패!'));\n      }\n    }, 1000);\n  });\n}\n\n// then/catch 사용\nasyncOperation()\n  .then(result => console.log(result))\n  .catch(error => console.log('오류:', error.message));\n```\n\n### async/await\n\n```typescript\nasync function performOperation(): Promise<void> {\n  try {\n    const result = await asyncOperation();\n    console.log('결과:', result);\n  } catch (error) {\n    if (error instanceof Error) {\n      console.log('오류:', error.message);\n    }\n  }\n}\n\nperformOperation();\n```\n\n## 타입 가드로 안전한 코드\n\n```typescript\n// null/undefined 체크\nfunction processValue(value: string | null): void {\n  if (value === null) {\n    throw new Error('값이 null입니다');\n  }\n  // 이제 value는 string 타입\n  console.log(value.toUpperCase());\n}\n\n// 타입 가드 함수\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction processInput(input: unknown): void {\n  if (isString(input)) {\n    console.log(input.toUpperCase());\n  } else {\n    throw new Error('문자열이 아닙니다');\n  }\n}\n```\n\n## 실전 예제\n\n### 안전한 JSON 파싱\n\n```typescript\nfunction safeParseJSON<T>(jsonString: string): Result<T> {\n  try {\n    const value = JSON.parse(jsonString) as T;\n    return { success: true, value };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error('알 수 없는 오류')\n    };\n  }\n}\n\nconst result = safeParseJSON<{ name: string }>('{ \"name\": \"Alice\" }');\nif (result.success) {\n  console.log(result.value.name);\n} else {\n  console.log('파싱 실패:', result.error.message);\n}\n```\n\n### 재시도 로직\n\n```typescript\nasync function retry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 1000\n): Promise<T> {\n  let lastError: Error;\n  \n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('알 수 없는 오류');\n      console.log(`시도 ${i + 1}/${maxRetries} 실패:`, lastError.message);\n      \n      if (i < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  throw lastError!;\n}\n\n// 사용 예시\nasync function unreliableOperation(): Promise<string> {\n  if (Math.random() > 0.7) {\n    return '성공!';\n  }\n  throw new Error('실패!');\n}\n\nretry(unreliableOperation)\n  .then(result => console.log('최종 성공:', result))\n  .catch(error => console.log('모든 시도 실패:', error.message));\n```\n\n### 입력 검증\n\n```typescript\nclass ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateEmail(email: string): void {\n  if (!email) {\n    throw new ValidationError('이메일은 필수입니다');\n  }\n  \n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(email)) {\n    throw new ValidationError('올바른 이메일 형식이 아닙니다');\n  }\n}\n\nfunction validateAge(age: number): void {\n  if (age < 0) {\n    throw new ValidationError('나이는 0 이상이어야 합니다');\n  }\n  \n  if (age > 150) {\n    throw new ValidationError('나이가 너무 큽니다');\n  }\n}\n\ninterface UserInput {\n  email: string;\n  age: number;\n}\n\nfunction validateUser(input: UserInput): void {\n  try {\n    validateEmail(input.email);\n    validateAge(input.age);\n    console.log('검증 성공');\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      console.log('검증 실패:', error.message);\n    } else {\n      console.log('알 수 없는 오류');\n    }\n  }\n}\n\nvalidateUser({ email: 'test@example.com', age: 25 });\nvalidateUser({ email: 'invalid', age: -5 });\n```\n\n### 에러 로깅\n\n```typescript\nimport * as fs from 'fs';\n\nclass ErrorLogger {\n  private logFile: string;\n  \n  constructor(logFile: string) {\n    this.logFile = logFile;\n  }\n  \n  log(error: Error): void {\n    const timestamp = new Date().toISOString();\n    const entry = `[${timestamp}] ${error.name}: ${error.message}\\n${error.stack}\\n\\n`;\n    \n    try {\n      fs.appendFileSync(this.logFile, entry);\n    } catch (logError) {\n      console.error('로그 기록 실패:', logError);\n    }\n  }\n}\n\nconst logger = new ErrorLogger('errors.log');\n\ntry {\n  throw new Error('테스트 에러');\n} catch (error) {\n  if (error instanceof Error) {\n    logger.log(error);\n  }\n}\n```\n\n## 연습 문제\n\n1. 사용자 정의 예외를 만들어 특정 상황을 처리하세요\n2. Result 타입을 사용해 안전한 함수를 작성하세요\n3. async/await로 비동기 예외를 처리하세요\n\n## 핵심 요약\n\n- `try-catch`: 예외 처리\n- `finally`: 항상 실행되는 블록\n- `throw`: 예외 발생\n- `Error`: 내장 에러 타입\n- `extends Error`: 사용자 정의 예외\n- `instanceof`: 에러 타입 확인\n- Result 타입: 예외 대신 반환값으로 처리\n- `async/await`에서 try-catch 사용\n- 타입 가드로 안전한 코드 작성\n- 적절한 예외 처리로 안정적인 프로그램"
    }
  ]
}
