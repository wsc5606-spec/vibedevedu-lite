{
  "language": "sql",
  "chapters": [
    {
      "chapterId": 1,
      "title": "1단원: SQL 기초와 주석",
      "content": "# 1단원: SQL 기초와 주석\n\n## SQL이란?\n\nSQL(Structured Query Language)은 데이터베이스를 관리하고 조작하기 위한 표준 언어입니다.\n\n### SQL의 종류\n\n- **DDL** (Data Definition Language): CREATE, ALTER, DROP\n- **DML** (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE\n- **DCL** (Data Control Language): GRANT, REVOKE\n- **TCL** (Transaction Control Language): COMMIT, ROLLBACK\n\n## 주석 (Comments)\n\n### 한 줄 주석\n\n```sql\n-- 이것은 한 줄 주석입니다\nSELECT * FROM users; -- 모든 사용자 조회\n```\n\n### 여러 줄 주석\n\n```sql\n/*\n이것은 여러 줄 주석입니다.\n여러 줄에 걸쳐 설명을 작성할 수 있습니다.\n*/\n\nSELECT name, age\nFROM users\nWHERE age >= 18;\n```\n\n## 기본 SELECT 문\n\n### 모든 데이터 조회\n\n```sql\n-- users 테이블의 모든 데이터 조회\nSELECT * FROM users;\n```\n\n### 특정 컬럼 조회\n\n```sql\n-- 이름과 나이만 조회\nSELECT name, age FROM users;\n\n-- 여러 컬럼 조회\nSELECT id, name, email, created_at FROM users;\n```\n\n### DISTINCT (중복 제거)\n\n```sql\n-- 중복을 제거한 도시 목록\nSELECT DISTINCT city FROM users;\n\n-- 여러 컬럼의 조합이 중복되지 않는 결과\nSELECT DISTINCT city, country FROM users;\n```\n\n## 실습 예제\n\n```sql\n-- 학생 테이블 조회\nSELECT * FROM students;\n\n-- 학생 이름과 학년만 조회\nSELECT name, grade FROM students;\n\n-- 중복 없이 모든 학과 조회\nSELECT DISTINCT department FROM students;\n```\n\n## 연습 문제\n\n1. products 테이블에서 모든 상품 정보를 조회하세요.\n2. employees 테이블에서 이름(name)과 직급(position)만 조회하세요.\n3. orders 테이블에서 중복 없이 모든 고객 ID를 조회하세요.\n\n## 핵심 요약\n\n- `--`: 한 줄 주석\n- `/* */`: 여러 줄 주석\n- `SELECT`: 데이터 조회\n- `FROM`: 테이블 지정\n- `*`: 모든 컬럼 선택\n- `DISTINCT`: 중복 제거"
    },
    {
      "chapterId": 2,
      "title": "2단원: 데이터 타입과 테이블 생성",
      "content": "# 2단원: 데이터 타입과 테이블 생성\n\n## 주요 데이터 타입\n\n### 숫자형\n\n```sql\nINT           -- 정수 (-2147483648 ~ 2147483647)\nBIGINT        -- 큰 정수\nSMALLINT      -- 작은 정수 (-32768 ~ 32767)\nDECIMAL(p,s)  -- 고정 소수점 (예: DECIMAL(10,2))\nNUMERIC(p,s)  -- DECIMAL과 동일\nFLOAT         -- 부동 소수점\nREAL          -- 단정밀도 부동 소수점\n```\n\n### 문자형\n\n```sql\nCHAR(n)       -- 고정 길이 문자열 (예: CHAR(10))\nVARCHAR(n)    -- 가변 길이 문자열 (예: VARCHAR(255))\nTEXT          -- 긴 텍스트 (크기 제한 없음)\n```\n\n### 날짜/시간형\n\n```sql\nDATE          -- 날짜 (YYYY-MM-DD)\nTIME          -- 시간 (HH:MM:SS)\nDATETIME      -- 날짜와 시간\nTIMESTAMP     -- 타임스탬프 (자동 업데이트 가능)\nYEAR          -- 연도\n```\n\n### 기타\n\n```sql\nBOOLEAN       -- 참/거짓 (TRUE/FALSE)\nBLOB          -- 이진 데이터 (이미지, 파일 등)\nJSON          -- JSON 데이터 (MySQL 5.7+, PostgreSQL)\n```\n\n## 테이블 생성 (CREATE TABLE)\n\n### 기본 문법\n\n```sql\nCREATE TABLE users (\n    id INT,\n    name VARCHAR(100),\n    age INT,\n    email VARCHAR(255)\n);\n```\n\n### 제약 조건 (Constraints)\n\n```sql\nCREATE TABLE students (\n    id INT PRIMARY KEY,              -- 기본 키\n    student_id VARCHAR(20) UNIQUE,   -- 고유 값\n    name VARCHAR(100) NOT NULL,      -- NULL 불가\n    age INT CHECK (age >= 0),        -- 조건 검사\n    grade INT DEFAULT 1,             -- 기본값\n    email VARCHAR(255) UNIQUE NOT NULL\n);\n```\n\n### AUTO_INCREMENT (자동 증가)\n\n```sql\n-- MySQL/MariaDB\nCREATE TABLE products (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- PostgreSQL\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n### 외래 키 (Foreign Key)\n\n```sql\nCREATE TABLE orders (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    user_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT DEFAULT 1,\n    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id),\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);\n```\n\n## 테이블 수정 (ALTER TABLE)\n\n```sql\n-- 컬럼 추가\nALTER TABLE users\nADD COLUMN phone VARCHAR(20);\n\n-- 컬럼 삭제\nALTER TABLE users\nDROP COLUMN phone;\n\n-- 컬럼 수정\nALTER TABLE users\nMODIFY COLUMN name VARCHAR(200); -- MySQL\n\n-- 또는\nALTER TABLE users\nALTER COLUMN name TYPE VARCHAR(200); -- PostgreSQL\n\n-- 제약 조건 추가\nALTER TABLE users\nADD CONSTRAINT unique_email UNIQUE (email);\n```\n\n## 테이블 삭제 (DROP TABLE)\n\n```sql\n-- 테이블 완전 삭제\nDROP TABLE users;\n\n-- 테이블이 존재할 때만 삭제\nDROP TABLE IF EXISTS users;\n\n-- 테이블 데이터만 삭제 (구조 유지)\nTRUNCATE TABLE users;\n```\n\n## 실습 예제\n\n```sql\n-- 학생 관리 테이블 생성\nCREATE TABLE students (\n    student_id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    birth_date DATE,\n    email VARCHAR(255) UNIQUE,\n    phone VARCHAR(20),\n    major VARCHAR(100),\n    gpa DECIMAL(3, 2) CHECK (gpa >= 0.0 AND gpa <= 4.5),\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- 성적 테이블 생성\nCREATE TABLE grades (\n    grade_id INT AUTO_INCREMENT PRIMARY KEY,\n    student_id INT NOT NULL,\n    subject VARCHAR(100) NOT NULL,\n    score INT CHECK (score >= 0 AND score <= 100),\n    semester VARCHAR(20),\n    FOREIGN KEY (student_id) REFERENCES students(student_id)\n        ON DELETE CASCADE\n);\n\n-- 테이블 구조 확인\nDESC students;  -- MySQL\n-- 또는\n\\d students;    -- PostgreSQL\n```\n\n## 연습 문제\n\n1. 책(books) 테이블을 생성하세요 (id, title, author, price, published_date).\n2. employees 테이블에 department 컬럼을 추가하세요.\n3. 주문(orders) 테이블을 생성하고 외래 키로 customers 테이블과 연결하세요.\n\n## 핵심 요약\n\n- 숫자형: `INT`, `DECIMAL`, `FLOAT`\n- 문자형: `VARCHAR`, `TEXT`\n- 날짜형: `DATE`, `TIMESTAMP`\n- `CREATE TABLE`: 테이블 생성\n- `PRIMARY KEY`: 기본 키\n- `FOREIGN KEY`: 외래 키\n- `NOT NULL`: 필수 값\n- `UNIQUE`: 중복 불가\n- `DEFAULT`: 기본값\n- `AUTO_INCREMENT` / `SERIAL`: 자동 증가"
    },
    {
      "chapterId": 3,
      "title": "3단원: WHERE 절과 연산자",
      "content": "# 3단원: WHERE 절과 연산자\n\n## WHERE 절\n\nWHERE 절은 조건에 맞는 데이터만 필터링합니다.\n\n```sql\n-- 기본 사용\nSELECT * FROM users\nWHERE age >= 18;\n\n-- 특정 값 검색\nSELECT name, email FROM users\nWHERE city = '서울';\n```\n\n## 비교 연산자\n\n```sql\n-- 같음\nSELECT * FROM products WHERE price = 10000;\n\n-- 같지 않음\nSELECT * FROM products WHERE category != '전자제품';\n-- 또는\nSELECT * FROM products WHERE category <> '전자제품';\n\n-- 크기 비교\nSELECT * FROM students WHERE score > 80;\nSELECT * FROM students WHERE score < 60;\nSELECT * FROM students WHERE score >= 70;\nSELECT * FROM students WHERE score <= 90;\n```\n\n## 논리 연산자\n\n### AND (그리고)\n\n```sql\n-- 여러 조건을 모두 만족\nSELECT * FROM users\nWHERE age >= 18 AND city = '서울';\n\nSELECT * FROM products\nWHERE price >= 10000 AND price <= 50000 AND stock > 0;\n```\n\n### OR (또는)\n\n```sql\n-- 조건 중 하나라도 만족\nSELECT * FROM users\nWHERE city = '서울' OR city = '부산';\n\nSELECT * FROM products\nWHERE category = '의류' OR category = '신발';\n```\n\n### NOT (부정)\n\n```sql\n-- 조건을 만족하지 않는 데이터\nSELECT * FROM users\nWHERE NOT city = '서울';\n\nSELECT * FROM products\nWHERE NOT (price < 10000);\n```\n\n### 복합 조건\n\n```sql\n-- AND와 OR 함께 사용 (괄호로 우선순위 명시)\nSELECT * FROM products\nWHERE (category = '전자제품' OR category = '가전제품')\n  AND price < 100000;\n\nSELECT * FROM students\nWHERE (grade = 1 OR grade = 2) AND score >= 80;\n```\n\n## BETWEEN (범위)\n\n```sql\n-- 범위 검색\nSELECT * FROM products\nWHERE price BETWEEN 10000 AND 50000;\n-- 위와 동일: price >= 10000 AND price <= 50000\n\n-- 날짜 범위\nSELECT * FROM orders\nWHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';\n\n-- NOT BETWEEN\nSELECT * FROM products\nWHERE price NOT BETWEEN 10000 AND 50000;\n```\n\n## IN (목록)\n\n```sql\n-- 여러 값 중 하나와 일치\nSELECT * FROM users\nWHERE city IN ('서울', '부산', '대구');\n-- 위와 동일: city = '서울' OR city = '부산' OR city = '대구'\n\nSELECT * FROM products\nWHERE category IN ('의류', '신발', '가방');\n\n-- NOT IN\nSELECT * FROM users\nWHERE city NOT IN ('서울', '부산');\n```\n\n## LIKE (패턴 매칭)\n\n```sql\n-- % : 0개 이상의 문자\nSELECT * FROM users\nWHERE name LIKE '김%';      -- 김으로 시작\n\nSELECT * FROM users\nWHERE name LIKE '%수';      -- 수로 끝남\n\nSELECT * FROM users\nWHERE name LIKE '%민%';     -- 민이 포함됨\n\n-- _ : 정확히 1개의 문자\nSELECT * FROM users\nWHERE phone LIKE '010-____-____';\n\nSELECT * FROM products\nWHERE code LIKE 'A___';     -- A로 시작하는 4자리\n\n-- NOT LIKE\nSELECT * FROM users\nWHERE email NOT LIKE '%@gmail.com';\n```\n\n## IS NULL / IS NOT NULL\n\n```sql\n-- NULL 값 검색\nSELECT * FROM users\nWHERE phone IS NULL;\n\nSELECT * FROM products\nWHERE description IS NULL;\n\n-- NULL이 아닌 값 검색\nSELECT * FROM users\nWHERE email IS NOT NULL;\n\n-- 주의: = NULL 은 동작하지 않음!\n-- 잘못된 예\nSELECT * FROM users WHERE phone = NULL;  -- 결과 없음\n-- 올바른 예\nSELECT * FROM users WHERE phone IS NULL; -- 정상 동작\n```\n\n## 실습 예제\n\n```sql\n-- 20세 이상 30세 이하 사용자\nSELECT name, age FROM users\nWHERE age BETWEEN 20 AND 30;\n\n-- 서울, 부산, 대구에 사는 사용자\nSELECT name, city FROM users\nWHERE city IN ('서울', '부산', '대구');\n\n-- 이메일이 gmail인 사용자\nSELECT name, email FROM users\nWHERE email LIKE '%@gmail.com';\n\n-- 가격이 10000원 이상이고 재고가 있는 상품\nSELECT name, price, stock FROM products\nWHERE price >= 10000 AND stock > 0;\n\n-- 전화번호가 없는 사용자\nSELECT name, email FROM users\nWHERE phone IS NULL;\n\n-- 복합 조건: 1학년 또는 2학년 중 80점 이상\nSELECT name, grade, score FROM students\nWHERE (grade = 1 OR grade = 2) AND score >= 80;\n```\n\n## 연습 문제\n\n1. employees 테이블에서 급여가 3000000 이상인 직원을 조회하세요.\n2. products 테이블에서 가격이 10000원에서 50000원 사이인 상품을 조회하세요.\n3. users 테이블에서 이름이 '김'으로 시작하고 나이가 20세 이상인 사용자를 조회하세요.\n4. orders 테이블에서 상태가 'pending' 또는 'processing'인 주문을 조회하세요.\n\n## 핵심 요약\n\n- `WHERE`: 조건 필터링\n- 비교: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=`\n- 논리: `AND`, `OR`, `NOT`\n- `BETWEEN`: 범위 검색\n- `IN`: 목록 중 일치\n- `LIKE`: 패턴 매칭 (`%`, `_`)\n- `IS NULL` / `IS NOT NULL`: NULL 검사\n- 괄호로 우선순위 명시"
    },
    {
      "chapterId": 4,
      "title": "4단원: 정렬과 제한",
      "content": "# 4단원: 정렬과 제한\n\n## ORDER BY (정렬)\n\n### 오름차순 정렬 (ASC)\n\n```sql\n-- 기본은 오름차순\nSELECT * FROM products\nORDER BY price;\n\n-- 명시적으로 ASC 사용\nSELECT * FROM products\nORDER BY price ASC;\n\n-- 문자열 정렬 (가나다순)\nSELECT name, city FROM users\nORDER BY name ASC;\n```\n\n### 내림차순 정렬 (DESC)\n\n```sql\n-- 가격이 높은 순\nSELECT * FROM products\nORDER BY price DESC;\n\n-- 최신 순 (날짜)\nSELECT * FROM orders\nORDER BY order_date DESC;\n\n-- 점수가 높은 순\nSELECT name, score FROM students\nORDER BY score DESC;\n```\n\n### 다중 정렬\n\n```sql\n-- 먼저 카테고리로 정렬, 같은 카테고리 내에서는 가격순\nSELECT * FROM products\nORDER BY category ASC, price DESC;\n\n-- 학년 오름차순, 같은 학년은 점수 내림차순\nSELECT * FROM students\nORDER BY grade ASC, score DESC;\n\n-- 3개 기준 정렬\nSELECT * FROM employees\nORDER BY department ASC, position DESC, salary DESC;\n```\n\n### NULL 값 정렬\n\n```sql\n-- NULL을 마지막에 (MySQL)\nSELECT * FROM users\nORDER BY phone IS NULL, phone ASC;\n\n-- PostgreSQL에서 명시적으로\nSELECT * FROM users\nORDER BY phone ASC NULLS LAST;\n\nSELECT * FROM users\nORDER BY phone DESC NULLS FIRST;\n```\n\n## LIMIT (결과 제한)\n\n### 상위 N개 조회\n\n```sql\n-- 상위 10개\nSELECT * FROM products\nORDER BY sales DESC\nLIMIT 10;\n\n-- 가장 비싼 5개 상품\nSELECT name, price FROM products\nORDER BY price DESC\nLIMIT 5;\n\n-- 최신 주문 3개\nSELECT * FROM orders\nORDER BY order_date DESC\nLIMIT 3;\n```\n\n### OFFSET (건너뛰기)\n\n```sql\n-- 6번째부터 10개 (페이징)\nSELECT * FROM products\nORDER BY id\nLIMIT 10 OFFSET 5;\n\n-- 또는\nSELECT * FROM products\nORDER BY id\nLIMIT 5, 10;  -- MySQL 문법: LIMIT offset, count\n```\n\n### 페이징 구현\n\n```sql\n-- 1페이지 (1~10번)\nSELECT * FROM products\nORDER BY id\nLIMIT 10 OFFSET 0;\n\n-- 2페이지 (11~20번)\nSELECT * FROM products\nORDER BY id\nLIMIT 10 OFFSET 10;\n\n-- 3페이지 (21~30번)\nSELECT * FROM products\nORDER BY id\nLIMIT 10 OFFSET 20;\n\n-- 공식: LIMIT [페이지당 개수] OFFSET [(페이지번호-1) * 페이지당 개수]\n```\n\n### SQL Server / MS SQL (TOP)\n\n```sql\n-- TOP 사용\nSELECT TOP 10 * FROM products\nORDER BY price DESC;\n\n-- PERCENT 사용\nSELECT TOP 10 PERCENT * FROM products\nORDER BY sales DESC;\n```\n\n### Oracle (ROWNUM)\n\n```sql\n-- ROWNUM 사용\nSELECT * FROM (\n    SELECT * FROM products\n    ORDER BY price DESC\n)\nWHERE ROWNUM <= 10;\n```\n\n## 실습 예제\n\n```sql\n-- 가장 비싼 상품 10개\nSELECT name, price FROM products\nORDER BY price DESC\nLIMIT 10;\n\n-- 최근 가입한 사용자 5명\nSELECT name, created_at FROM users\nORDER BY created_at DESC\nLIMIT 5;\n\n-- 성적 상위 20명 (동점자 포함)\nSELECT name, score FROM students\nORDER BY score DESC, name ASC\nLIMIT 20;\n\n-- 2페이지 데이터 (11~20번째)\nSELECT * FROM products\nWHERE category = '전자제품'\nORDER BY price ASC\nLIMIT 10 OFFSET 10;\n\n-- 부서별로 정렬하고 각 부서에서 급여 높은 순\nSELECT name, department, salary FROM employees\nORDER BY department ASC, salary DESC;\n\n-- 재고가 있는 상품 중 가장 저렴한 5개\nSELECT name, price, stock FROM products\nWHERE stock > 0\nORDER BY price ASC\nLIMIT 5;\n```\n\n## 고급 활용\n\n### CASE를 사용한 커스텀 정렬\n\n```sql\n-- 특정 순서로 정렬\nSELECT * FROM products\nORDER BY \n    CASE category\n        WHEN '인기' THEN 1\n        WHEN '신상' THEN 2\n        WHEN '세일' THEN 3\n        ELSE 4\n    END,\n    price DESC;\n```\n\n### 무작위 정렬\n\n```sql\n-- MySQL\nSELECT * FROM products\nORDER BY RAND()\nLIMIT 10;\n\n-- PostgreSQL\nSELECT * FROM products\nORDER BY RANDOM()\nLIMIT 10;\n\n-- SQL Server\nSELECT TOP 10 * FROM products\nORDER BY NEWID();\n```\n\n## 연습 문제\n\n1. employees 테이블에서 급여가 높은 순으로 상위 5명을 조회하세요.\n2. products 테이블에서 가격이 저렴한 순으로 정렬하고 3페이지(21~30번째)를 조회하세요.\n3. students 테이블에서 학년별로 그룹화하고, 같은 학년 내에서는 성적순으로 정렬하세요.\n4. orders 테이블에서 최근 주문 10개를 조회하되, 같은 날짜는 금액이 큰 순으로 정렬하세요.\n\n## 핵심 요약\n\n- `ORDER BY`: 정렬\n- `ASC`: 오름차순 (기본값)\n- `DESC`: 내림차순\n- 다중 정렬: `ORDER BY col1, col2`\n- `LIMIT n`: 상위 n개\n- `OFFSET n`: n개 건너뛰기\n- 페이징: `LIMIT [size] OFFSET [(page-1) * size]`\n- 정렬 후 제한: `ORDER BY ... LIMIT ...`"
    },
    {
      "chapterId": 5,
      "title": "5단원: 집계 함수와 그룹화",
      "content": "# 5단원: 집계 함수와 그룹화\n\n## 집계 함수 (Aggregate Functions)\n\n### COUNT (개수)\n\n```sql\n-- 전체 행 개수\nSELECT COUNT(*) FROM users;\n\n-- 특정 컬럼 개수 (NULL 제외)\nSELECT COUNT(phone) FROM users;\n\n-- 중복 제거 개수\nSELECT COUNT(DISTINCT city) FROM users;\n\n-- 조건에 맞는 개수\nSELECT COUNT(*) FROM products\nWHERE price > 10000;\n```\n\n### SUM (합계)\n\n```sql\n-- 전체 합계\nSELECT SUM(price) FROM orders;\n\n-- 특정 조건의 합계\nSELECT SUM(quantity) FROM order_items\nWHERE product_id = 1;\n\n-- 계산된 값의 합계\nSELECT SUM(price * quantity) AS total_sales\nFROM order_items;\n```\n\n### AVG (평균)\n\n```sql\n-- 평균 계산\nSELECT AVG(score) FROM students;\n\n-- 소수점 자릿수 제한\nSELECT ROUND(AVG(price), 2) FROM products;\n\n-- 조건부 평균\nSELECT AVG(salary) FROM employees\nWHERE department = '개발팀';\n```\n\n### MAX / MIN (최댓값 / 최솟값)\n\n```sql\n-- 최댓값\nSELECT MAX(price) FROM products;\nSELECT MAX(score) FROM students;\n\n-- 최솟값\nSELECT MIN(price) FROM products;\nSELECT MIN(birth_date) FROM users;  -- 가장 오래된 날짜\n\n-- 여러 집계 함수 동시 사용\nSELECT \n    MIN(price) AS min_price,\n    MAX(price) AS max_price,\n    AVG(price) AS avg_price\nFROM products;\n```\n\n## GROUP BY (그룹화)\n\n### 기본 그룹화\n\n```sql\n-- 도시별 사용자 수\nSELECT city, COUNT(*) AS user_count\nFROM users\nGROUP BY city;\n\n-- 카테고리별 상품 수\nSELECT category, COUNT(*) AS product_count\nFROM products\nGROUP BY category;\n\n-- 학년별 평균 점수\nSELECT grade, AVG(score) AS avg_score\nFROM students\nGROUP BY grade;\n```\n\n### 다중 그룹화\n\n```sql\n-- 도시와 성별로 그룹화\nSELECT city, gender, COUNT(*) AS count\nFROM users\nGROUP BY city, gender;\n\n-- 카테고리와 브랜드별 평균 가격\nSELECT category, brand, AVG(price) AS avg_price\nFROM products\nGROUP BY category, brand;\n\n-- 연도, 월별 매출\nSELECT \n    YEAR(order_date) AS year,\n    MONTH(order_date) AS month,\n    SUM(amount) AS total_sales\nFROM orders\nGROUP BY YEAR(order_date), MONTH(order_date);\n```\n\n### GROUP BY with ORDER BY\n\n```sql\n-- 카테고리별 상품 수 (많은 순)\nSELECT category, COUNT(*) AS count\nFROM products\nGROUP BY category\nORDER BY count DESC;\n\n-- 도시별 평균 연령 (높은 순)\nSELECT city, AVG(age) AS avg_age\nFROM users\nGROUP BY city\nORDER BY avg_age DESC;\n```\n\n## HAVING (그룹 필터링)\n\nHAVING은 GROUP BY 결과를 필터링합니다 (WHERE는 그룹화 전 필터링).\n\n```sql\n-- 사용자가 10명 이상인 도시만\nSELECT city, COUNT(*) AS user_count\nFROM users\nGROUP BY city\nHAVING COUNT(*) >= 10;\n\n-- 평균 점수가 80점 이상인 학년\nSELECT grade, AVG(score) AS avg_score\nFROM students\nGROUP BY grade\nHAVING AVG(score) >= 80;\n\n-- 총 매출이 1000000 이상인 상품\nSELECT product_id, SUM(amount) AS total_sales\nFROM orders\nGROUP BY product_id\nHAVING SUM(amount) >= 1000000;\n```\n\n### WHERE vs HAVING\n\n```sql\n-- WHERE: 그룹화 전 필터링\nSELECT category, AVG(price) AS avg_price\nFROM products\nWHERE stock > 0  -- 재고가 있는 상품만\nGROUP BY category;\n\n-- HAVING: 그룹화 후 필터링\nSELECT category, AVG(price) AS avg_price\nFROM products\nGROUP BY category\nHAVING AVG(price) > 50000;  -- 평균 가격이 50000 이상인 카테고리만\n\n-- 둘 다 사용\nSELECT category, COUNT(*) AS count\nFROM products\nWHERE stock > 0              -- 재고가 있는 것만\nGROUP BY category\nHAVING COUNT(*) >= 5;        -- 5개 이상인 카테고리만\n```\n\n## 실습 예제\n\n```sql\n-- 부서별 평균 급여\nSELECT department, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department\nORDER BY avg_salary DESC;\n\n-- 날짜별 주문 건수와 총 금액\nSELECT \n    DATE(order_date) AS order_day,\n    COUNT(*) AS order_count,\n    SUM(amount) AS total_amount\nFROM orders\nGROUP BY DATE(order_date)\nORDER BY order_day DESC;\n\n-- 학년별 최고점, 최저점, 평균\nSELECT \n    grade,\n    MAX(score) AS max_score,\n    MIN(score) AS min_score,\n    AVG(score) AS avg_score,\n    COUNT(*) AS student_count\nFROM students\nGROUP BY grade\nORDER BY grade;\n\n-- 상품당 주문 횟수가 10회 이상인 것만\nSELECT \n    product_id,\n    COUNT(*) AS order_count,\n    SUM(quantity) AS total_quantity\nFROM order_items\nGROUP BY product_id\nHAVING COUNT(*) >= 10\nORDER BY order_count DESC;\n\n-- 도시별, 연령대별 사용자 분포\nSELECT \n    city,\n    CASE \n        WHEN age < 20 THEN '10대'\n        WHEN age < 30 THEN '20대'\n        WHEN age < 40 THEN '30대'\n        ELSE '40대 이상'\n    END AS age_group,\n    COUNT(*) AS count\nFROM users\nGROUP BY city, age_group\nORDER BY city, age_group;\n```\n\n## 고급 활용\n\n### WITH ROLLUP (소계)\n\n```sql\n-- MySQL에서 소계와 총계\nSELECT \n    category,\n    SUM(price) AS total\nFROM products\nGROUP BY category WITH ROLLUP;\n```\n\n### DISTINCT와 집계 함수\n\n```sql\n-- 중복 제거 후 합계\nSELECT SUM(DISTINCT price) FROM products;\n\n-- 카테고리별 중복 없는 브랜드 수\nSELECT category, COUNT(DISTINCT brand) AS brand_count\nFROM products\nGROUP BY category;\n```\n\n## 연습 문제\n\n1. products 테이블에서 카테고리별 평균 가격을 구하세요.\n2. orders 테이블에서 고객별 총 주문 금액이 100000 이상인 고객만 조회하세요.\n3. students 테이블에서 학년별 학생 수와 평균 점수를 구하고, 학생이 30명 이상인 학년만 표시하세요.\n4. employees 테이블에서 부서별 최고 급여와 최저 급여의 차이를 구하세요.\n\n## 핵심 요약\n\n- `COUNT()`: 개수 세기\n- `SUM()`: 합계\n- `AVG()`: 평균\n- `MAX()` / `MIN()`: 최댓값 / 최솟값\n- `GROUP BY`: 그룹화\n- `HAVING`: 그룹 필터링\n- WHERE는 그룹화 전, HAVING은 그룹화 후\n- 실행 순서: WHERE → GROUP BY → HAVING → ORDER BY"
    },
    {
      "chapterId": 6,
      "title": "6단원: JOIN (테이블 조인)",
      "content": "# 6단원: JOIN (테이블 조인)\n\n## JOIN이란?\n\nJOIN은 두 개 이상의 테이블을 연결하여 데이터를 조회하는 기능입니다.\n\n## INNER JOIN (내부 조인)\n\n양쪽 테이블에 모두 존재하는 데이터만 조회합니다.\n\n```sql\n-- 기본 문법\nSELECT users.name, orders.order_date, orders.amount\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n\n-- 테이블 별칭 사용 (권장)\nSELECT u.name, o.order_date, o.amount\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n\n-- INNER 생략 가능\nSELECT u.name, o.order_date\nFROM users u\nJOIN orders o ON u.id = o.user_id;\n```\n\n### 여러 컬럼으로 조인\n\n```sql\nSELECT *\nFROM orders o\nJOIN order_details od \n    ON o.id = od.order_id \n    AND o.status = od.status;\n```\n\n## LEFT JOIN (왼쪽 조인)\n\n왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 일치하는 데이터를 조회합니다.\n\n```sql\n-- 모든 사용자와 그들의 주문 (주문이 없어도 표시)\nSELECT u.name, o.order_date, o.amount\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n\n-- 주문하지 않은 사용자 찾기\nSELECT u.name\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.id IS NULL;\n```\n\n## RIGHT JOIN (오른쪽 조인)\n\n오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 일치하는 데이터를 조회합니다.\n\n```sql\n-- 모든 주문과 사용자 정보\nSELECT u.name, o.order_date, o.amount\nFROM users u\nRIGHT JOIN orders o ON u.id = o.user_id;\n\n-- LEFT JOIN으로 바꿔 쓰는 것이 일반적\nSELECT u.name, o.order_date, o.amount\nFROM orders o\nLEFT JOIN users u ON o.user_id = u.id;\n```\n\n## FULL OUTER JOIN (완전 외부 조인)\n\n양쪽 테이블의 모든 데이터를 조회합니다. (MySQL은 미지원)\n\n```sql\n-- PostgreSQL, SQL Server\nSELECT u.name, o.order_date\nFROM users u\nFULL OUTER JOIN orders o ON u.id = o.user_id;\n\n-- MySQL에서 UNION으로 구현\nSELECT u.name, o.order_date\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nUNION\nSELECT u.name, o.order_date\nFROM users u\nRIGHT JOIN orders o ON u.id = o.user_id;\n```\n\n## CROSS JOIN (교차 조인)\n\n모든 조합을 생성합니다 (카테시안 곱).\n\n```sql\n-- 모든 조합\nSELECT c.name AS color, s.name AS size\nFROM colors c\nCROSS JOIN sizes s;\n\n-- 또는\nSELECT c.name, s.name\nFROM colors c, sizes s;\n```\n\n## SELF JOIN (자기 조인)\n\n같은 테이블을 조인합니다.\n\n```sql\n-- 직원과 매니저 정보\nSELECT \n    e.name AS employee_name,\n    m.name AS manager_name\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n\n-- 같은 도시에 사는 사용자 찾기\nSELECT \n    u1.name AS user1,\n    u2.name AS user2,\n    u1.city\nFROM users u1\nJOIN users u2 ON u1.city = u2.city AND u1.id < u2.id;\n```\n\n## 다중 테이블 JOIN\n\n```sql\n-- 3개 테이블 조인\nSELECT \n    u.name AS user_name,\n    p.name AS product_name,\n    o.quantity,\n    o.price\nFROM users u\nJOIN orders o ON u.id = o.user_id\nJOIN products p ON o.product_id = p.id;\n\n-- 4개 이상도 가능\nSELECT \n    u.name,\n    o.order_date,\n    p.name,\n    c.name AS category\nFROM users u\nJOIN orders o ON u.id = o.user_id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nJOIN categories c ON p.category_id = c.id;\n```\n\n## JOIN with WHERE\n\n```sql\n-- JOIN 후 필터링\nSELECT u.name, o.amount\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.amount > 100000\n  AND u.city = '서울';\n\n-- JOIN 조건과 WHERE 조건 구분\nSELECT u.name, o.order_date\nFROM users u\nLEFT JOIN orders o \n    ON u.id = o.user_id \n    AND o.status = 'completed'  -- JOIN 조건\nWHERE u.created_at >= '2024-01-01';  -- 필터 조건\n```\n\n## JOIN with GROUP BY\n\n```sql\n-- 사용자별 주문 건수\nSELECT u.name, COUNT(o.id) AS order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- 상품별 총 판매액\nSELECT \n    p.name,\n    SUM(oi.quantity * oi.price) AS total_sales\nFROM products p\nLEFT JOIN order_items oi ON p.id = oi.product_id\nGROUP BY p.id, p.name\nORDER BY total_sales DESC;\n```\n\n## 실습 예제\n\n```sql\n-- 주문 내역과 사용자 정보\nSELECT \n    o.id AS order_id,\n    u.name AS customer_name,\n    u.email,\n    o.order_date,\n    o.total_amount\nFROM orders o\nJOIN users u ON o.user_id = u.id\nORDER BY o.order_date DESC;\n\n-- 주문이 없는 고객 찾기\nSELECT u.id, u.name, u.email\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.id IS NULL;\n\n-- 카테고리별 상품 수와 평균 가격\nSELECT \n    c.name AS category_name,\n    COUNT(p.id) AS product_count,\n    AVG(p.price) AS avg_price\nFROM categories c\nLEFT JOIN products p ON c.id = p.category_id\nGROUP BY c.id, c.name\nORDER BY product_count DESC;\n\n-- 학생, 수강 과목, 성적 조회\nSELECT \n    s.name AS student_name,\n    c.name AS course_name,\n    e.grade,\n    e.score\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nJOIN courses c ON e.course_id = c.id\nWHERE e.score >= 80\nORDER BY s.name, c.name;\n\n-- 부서별 직원 수와 평균 급여\nSELECT \n    d.name AS department_name,\n    COUNT(e.id) AS employee_count,\n    AVG(e.salary) AS avg_salary,\n    MAX(e.salary) AS max_salary\nFROM departments d\nLEFT JOIN employees e ON d.id = e.department_id\nGROUP BY d.id, d.name\nHAVING COUNT(e.id) > 0\nORDER BY avg_salary DESC;\n```\n\n## 성능 최적화 팁\n\n```sql\n-- 1. 인덱스 활용 (JOIN 컬럼에 인덱스)\nCREATE INDEX idx_user_id ON orders(user_id);\n\n-- 2. 필요한 컬럼만 SELECT\nSELECT u.name, o.total  -- Good\nFROM users u\nJOIN orders o ON u.id = o.user_id;\n\n-- SELECT * -- Bad (불필요한 데이터)\n\n-- 3. WHERE 조건을 먼저 적용\nSELECT u.name, o.total\nFROM (\n    SELECT * FROM users WHERE city = '서울'\n) u\nJOIN orders o ON u.id = o.user_id;\n```\n\n## 연습 문제\n\n1. customers와 orders 테이블을 조인하여 고객별 총 주문 금액을 구하세요.\n2. products와 categories 테이블을 조인하여 카테고리별 상품 목록을 조회하세요.\n3. 주문한 적이 없는 상품을 찾으세요 (LEFT JOIN 사용).\n4. 학생, 수강신청, 과목 테이블을 조인하여 학생별 수강 과목 수를 구하세요.\n\n## 핵심 요약\n\n- `INNER JOIN`: 양쪽 모두 일치하는 데이터\n- `LEFT JOIN`: 왼쪽 테이블 전체 + 일치하는 오른쪽 데이터\n- `RIGHT JOIN`: 오른쪽 테이블 전체 + 일치하는 왼쪽 데이터\n- `FULL OUTER JOIN`: 양쪽 테이블 전체\n- `CROSS JOIN`: 모든 조합\n- `SELF JOIN`: 같은 테이블 조인\n- JOIN 컬럼에 인덱스 생성 권장\n- 테이블 별칭 사용으로 가독성 향상"
    },
    {
      "chapterId": 7,
      "title": "7단원: 서브쿼리",
      "content": "# 7단원: 서브쿼리\n\n## 서브쿼리란?\n\n서브쿼리는 다른 쿼리 내부에 중첩된 SELECT 문입니다.\n\n## WHERE 절 서브쿼리\n\n### 단일 값 반환\n\n```sql\n-- 평균보다 높은 가격의 상품\nSELECT name, price\nFROM products\nWHERE price > (SELECT AVG(price) FROM products);\n\n-- 최고 점수를 받은 학생\nSELECT name, score\nFROM students\nWHERE score = (SELECT MAX(score) FROM students);\n\n-- 가장 최근 주문의 고객\nSELECT name\nFROM users\nWHERE id = (\n    SELECT user_id \n    FROM orders \n    ORDER BY order_date DESC \n    LIMIT 1\n);\n```\n\n### IN / NOT IN\n\n```sql\n-- 주문한 적이 있는 고객\nSELECT name, email\nFROM users\nWHERE id IN (\n    SELECT DISTINCT user_id FROM orders\n);\n\n-- 주문한 적이 없는 고객\nSELECT name, email\nFROM users\nWHERE id NOT IN (\n    SELECT user_id FROM orders WHERE user_id IS NOT NULL\n);\n\n-- 특정 카테고리의 상품을 주문한 고객\nSELECT name\nFROM users\nWHERE id IN (\n    SELECT user_id FROM orders\n    WHERE product_id IN (\n        SELECT id FROM products WHERE category = '전자제품'\n    )\n);\n```\n\n### EXISTS / NOT EXISTS\n\n```sql\n-- 주문이 있는 고객 (EXISTS는 성능이 더 좋음)\nSELECT u.name\nFROM users u\nWHERE EXISTS (\n    SELECT 1 FROM orders o WHERE o.user_id = u.id\n);\n\n-- 주문이 없는 고객\nSELECT u.name\nFROM users u\nWHERE NOT EXISTS (\n    SELECT 1 FROM orders o WHERE o.user_id = u.id\n);\n\n-- 재고가 있는 카테고리\nSELECT c.name\nFROM categories c\nWHERE EXISTS (\n    SELECT 1 FROM products p \n    WHERE p.category_id = c.id AND p.stock > 0\n);\n```\n\n### ANY / ALL\n\n```sql\n-- ANY: 서브쿼리 결과 중 하나라도 만족\nSELECT name, price\nFROM products\nWHERE price > ANY (\n    SELECT price FROM products WHERE category = '전자제품'\n);\n\n-- ALL: 서브쿼리 결과 모두를 만족\nSELECT name, price\nFROM products\nWHERE price > ALL (\n    SELECT price FROM products WHERE category = '액세서리'\n);\n\n-- 모든 부서의 평균 급여보다 높은 직원\nSELECT name, salary\nFROM employees\nWHERE salary > ALL (\n    SELECT AVG(salary) FROM employees GROUP BY department\n);\n```\n\n## SELECT 절 서브쿼리 (스칼라 서브쿼리)\n\n```sql\n-- 각 상품과 카테고리 평균 가격 비교\nSELECT \n    name,\n    price,\n    (\n        SELECT AVG(price) \n        FROM products p2 \n        WHERE p2.category_id = p1.category_id\n    ) AS category_avg\nFROM products p1;\n\n-- 사용자별 주문 건수\nSELECT \n    u.name,\n    u.email,\n    (\n        SELECT COUNT(*) \n        FROM orders o \n        WHERE o.user_id = u.id\n    ) AS order_count\nFROM users u;\n\n-- 상품과 해당 카테고리명\nSELECT \n    p.name AS product_name,\n    p.price,\n    (SELECT c.name FROM categories c WHERE c.id = p.category_id) AS category_name\nFROM products p;\n```\n\n## FROM 절 서브쿼리 (인라인 뷰)\n\n```sql\n-- 카테고리별 평균 가격보다 비싼 상품\nSELECT p.name, p.price, avg_prices.avg_price\nFROM products p\nJOIN (\n    SELECT category_id, AVG(price) AS avg_price\n    FROM products\n    GROUP BY category_id\n) avg_prices ON p.category_id = avg_prices.category_id\nWHERE p.price > avg_prices.avg_price;\n\n-- 월별 매출 순위\nSELECT month, total_sales,\n    RANK() OVER (ORDER BY total_sales DESC) AS ranking\nFROM (\n    SELECT \n        DATE_FORMAT(order_date, '%Y-%m') AS month,\n        SUM(amount) AS total_sales\n    FROM orders\n    GROUP BY month\n) monthly_sales;\n\n-- 페이징 처리\nSELECT *\nFROM (\n    SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS row_num\n    FROM products\n) ranked\nWHERE row_num BETWEEN 11 AND 20;\n```\n\n## 상호 연관 서브쿼리 (Correlated Subquery)\n\n```sql\n-- 각 카테고리에서 가장 비싼 상품\nSELECT p1.name, p1.category_id, p1.price\nFROM products p1\nWHERE p1.price = (\n    SELECT MAX(p2.price)\n    FROM products p2\n    WHERE p2.category_id = p1.category_id\n);\n\n-- 평균보다 높은 점수를 받은 학생 (학년별)\nSELECT s1.name, s1.grade, s1.score\nFROM students s1\nWHERE s1.score > (\n    SELECT AVG(s2.score)\n    FROM students s2\n    WHERE s2.grade = s1.grade\n);\n\n-- 부서별 최고 급여를 받는 직원\nSELECT e1.name, e1.department, e1.salary\nFROM employees e1\nWHERE e1.salary = (\n    SELECT MAX(e2.salary)\n    FROM employees e2\n    WHERE e2.department = e1.department\n);\n```\n\n## CTE (Common Table Expression)\n\nWITH 절을 사용한 임시 결과 집합입니다.\n\n```sql\n-- 단일 CTE\nWITH high_price_products AS (\n    SELECT * FROM products WHERE price > 50000\n)\nSELECT category, COUNT(*) AS count\nFROM high_price_products\nGROUP BY category;\n\n-- 다중 CTE\nWITH \ncategory_avg AS (\n    SELECT category_id, AVG(price) AS avg_price\n    FROM products\n    GROUP BY category_id\n),\nexpensive_products AS (\n    SELECT p.*, ca.avg_price\n    FROM products p\n    JOIN category_avg ca ON p.category_id = ca.category_id\n    WHERE p.price > ca.avg_price\n)\nSELECT * FROM expensive_products;\n\n-- 재귀 CTE (조직도, 계층 구조)\nWITH RECURSIVE org_chart AS (\n    -- 기본 케이스: 최상위 직원\n    SELECT id, name, manager_id, 1 AS level\n    FROM employees\n    WHERE manager_id IS NULL\n    \n    UNION ALL\n    \n    -- 재귀 케이스: 부하 직원\n    SELECT e.id, e.name, e.manager_id, oc.level + 1\n    FROM employees e\n    JOIN org_chart oc ON e.manager_id = oc.id\n)\nSELECT * FROM org_chart ORDER BY level, name;\n```\n\n## 실습 예제\n\n```sql\n-- 평균 주문 금액보다 큰 주문\nSELECT order_id, user_id, amount\nFROM orders\nWHERE amount > (SELECT AVG(amount) FROM orders);\n\n-- 가장 많이 팔린 상품 TOP 5를 주문한 고객\nSELECT DISTINCT u.name, u.email\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.product_id IN (\n    SELECT product_id\n    FROM order_items\n    GROUP BY product_id\n    ORDER BY SUM(quantity) DESC\n    LIMIT 5\n);\n\n-- 부서별 평균 급여와 각 직원 정보\nWITH dept_avg AS (\n    SELECT department, AVG(salary) AS avg_salary\n    FROM employees\n    GROUP BY department\n)\nSELECT \n    e.name,\n    e.department,\n    e.salary,\n    da.avg_salary,\n    e.salary - da.avg_salary AS diff\nFROM employees e\nJOIN dept_avg da ON e.department = da.department\nORDER BY e.department, e.salary DESC;\n\n-- 최근 3개월간 구매한 고객\nSELECT name, email\nFROM users\nWHERE EXISTS (\n    SELECT 1 FROM orders\n    WHERE orders.user_id = users.id\n      AND order_date >= DATE_SUB(NOW(), INTERVAL 3 MONTH)\n);\n```\n\n## 성능 최적화\n\n```sql\n-- Bad: NOT IN with NULL\nSELECT * FROM users\nWHERE id NOT IN (SELECT user_id FROM orders);\n-- user_id에 NULL이 있으면 결과가 없을 수 있음\n\n-- Good: NOT EXISTS 사용\nSELECT * FROM users u\nWHERE NOT EXISTS (\n    SELECT 1 FROM orders o WHERE o.user_id = u.id\n);\n\n-- Bad: 중복된 서브쿼리\nSELECT \n    (SELECT AVG(price) FROM products) AS avg1,\n    (SELECT AVG(price) FROM products) AS avg2\nFROM dual;\n\n-- Good: JOIN 또는 CTE 사용\nWITH avg_price AS (\n    SELECT AVG(price) AS avg FROM products\n)\nSELECT avg, avg FROM avg_price;\n```\n\n## 연습 문제\n\n1. products 테이블에서 각 카테고리의 평균 가격보다 비싼 상품을 조회하세요.\n2. 주문 금액이 전체 평균의 2배 이상인 주문을 찾으세요.\n3. EXISTS를 사용하여 리뷰가 있는 상품만 조회하세요.\n4. CTE를 사용하여 월별 매출과 전월 대비 증감률을 계산하세요.\n\n## 핵심 요약\n\n- 서브쿼리: 쿼리 안의 쿼리\n- `IN` / `NOT IN`: 목록 포함 여부\n- `EXISTS` / `NOT EXISTS`: 존재 여부 (성능 우수)\n- `ANY` / `ALL`: 일부/전체 만족\n- 스칼라 서브쿼리: SELECT 절에 사용\n- 인라인 뷰: FROM 절에 사용\n- `WITH`: CTE (Common Table Expression)\n- EXISTS가 IN보다 성능이 좋은 경우가 많음"
    },
    {
      "chapterId": 8,
      "title": "8단원: INSERT, UPDATE, DELETE",
      "content": "# 8단원: INSERT, UPDATE, DELETE\n\n## INSERT (데이터 삽입)\n\n### 기본 INSERT\n\n```sql\n-- 모든 컬럼에 값 삽입\nINSERT INTO users\nVALUES (1, '홍길동', 'hong@example.com', 25, '서울');\n\n-- 특정 컬럼만 지정 (권장)\nINSERT INTO users (name, email, age)\nVALUES ('김철수', 'kim@example.com', 30);\n\n-- 여러 행 동시 삽입\nINSERT INTO users (name, email, age) VALUES\n    ('이영희', 'lee@example.com', 28),\n    ('박민수', 'park@example.com', 32),\n    ('정수진', 'jung@example.com', 27);\n```\n\n### AUTO_INCREMENT와 함께 사용\n\n```sql\n-- id는 자동 생성\nINSERT INTO products (name, price, stock)\nVALUES ('노트북', 1500000, 10);\n\n-- 마지막 삽입된 ID 확인 (MySQL)\nSELECT LAST_INSERT_ID();\n\n-- PostgreSQL\nINSERT INTO products (name, price)\nVALUES ('마우스', 30000)\nRETURNING id;\n```\n\n### DEFAULT 값 사용\n\n```sql\n-- DEFAULT 키워드 사용\nINSERT INTO orders (user_id, product_id, status, created_at)\nVALUES (1, 100, 'pending', DEFAULT);\n\n-- 컬럼 생략 시 자동으로 DEFAULT 사용\nINSERT INTO products (name, price)\nVALUES ('키보드', 80000);\n-- stock 컬럼은 DEFAULT 값으로 설정됨\n```\n\n### SELECT 결과 삽입 (INSERT INTO SELECT)\n\n```sql\n-- 다른 테이블에서 데이터 복사\nINSERT INTO users_backup (name, email, age)\nSELECT name, email, age\nFROM users\nWHERE created_at < '2024-01-01';\n\n-- 조건부 복사\nINSERT INTO premium_users (user_id, name, total_orders)\nSELECT u.id, u.name, COUNT(o.id)\nFROM users u\nJOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name\nHAVING COUNT(o.id) >= 10;\n```\n\n### INSERT IGNORE / ON DUPLICATE KEY UPDATE (MySQL)\n\n```sql\n-- 중복 시 무시\nINSERT IGNORE INTO users (email, name)\nVALUES ('hong@example.com', '홍길동');\n\n-- 중복 시 업데이트\nINSERT INTO users (id, name, email, age)\nVALUES (1, '홍길동', 'hong@example.com', 26)\nON DUPLICATE KEY UPDATE \n    name = VALUES(name),\n    age = VALUES(age);\n\n-- PostgreSQL의 UPSERT\nINSERT INTO users (id, name, email, age)\nVALUES (1, '홍길동', 'hong@example.com', 26)\nON CONFLICT (id) \nDO UPDATE SET \n    name = EXCLUDED.name,\n    age = EXCLUDED.age;\n```\n\n## UPDATE (데이터 수정)\n\n### 기본 UPDATE\n\n```sql\n-- 단일 컬럼 수정\nUPDATE users\nSET age = 26\nWHERE id = 1;\n\n-- 여러 컬럼 동시 수정\nUPDATE users\nSET name = '홍길동', age = 26, city = '부산'\nWHERE id = 1;\n\n-- 모든 행 수정 (주의!)\nUPDATE products\nSET stock = 0;  -- WHERE 절이 없으면 모든 행이 수정됨\n```\n\n### 조건부 UPDATE\n\n```sql\n-- 특정 조건의 행만 수정\nUPDATE products\nSET price = price * 0.9\nWHERE category = '의류' AND stock > 50;\n\n-- 범위 조건\nUPDATE students\nSET grade_level = grade_level + 1\nWHERE graduation_year = 2025;\n\n-- IN 사용\nUPDATE orders\nSET status = 'cancelled'\nWHERE id IN (100, 101, 102, 103);\n```\n\n### 계산식 UPDATE\n\n```sql\n-- 가격 10% 인상\nUPDATE products\nSET price = price * 1.1\nWHERE category = '전자제품';\n\n-- 재고 감소\nUPDATE products\nSET stock = stock - 5\nWHERE id = 1;\n\n-- 점수 정규화\nUPDATE students\nSET normalized_score = (score - 60) / 40 * 100\nWHERE score >= 60;\n```\n\n### CASE를 사용한 UPDATE\n\n```sql\n-- 조건별로 다른 값 설정\nUPDATE students\nSET grade = CASE\n    WHEN score >= 90 THEN 'A'\n    WHEN score >= 80 THEN 'B'\n    WHEN score >= 70 THEN 'C'\n    WHEN score >= 60 THEN 'D'\n    ELSE 'F'\nEND\nWHERE grade IS NULL;\n\n-- 여러 컬럼 조건부 수정\nUPDATE employees\nSET \n    salary = CASE\n        WHEN department = '개발' THEN salary * 1.15\n        WHEN department = '영업' THEN salary * 1.10\n        ELSE salary * 1.05\n    END,\n    bonus = CASE\n        WHEN performance >= 90 THEN 1000000\n        WHEN performance >= 80 THEN 500000\n        ELSE 0\n    END;\n```\n\n### JOIN을 사용한 UPDATE\n\n```sql\n-- MySQL\nUPDATE products p\nJOIN categories c ON p.category_id = c.id\nSET p.category_name = c.name;\n\n-- 서브쿼리 사용\nUPDATE users\nSET total_orders = (\n    SELECT COUNT(*) FROM orders WHERE orders.user_id = users.id\n);\n\n-- PostgreSQL\nUPDATE products\nSET category_name = c.name\nFROM categories c\nWHERE products.category_id = c.id;\n```\n\n## DELETE (데이터 삭제)\n\n### 기본 DELETE\n\n```sql\n-- 특정 행 삭제\nDELETE FROM users\nWHERE id = 1;\n\n-- 조건부 삭제\nDELETE FROM orders\nWHERE status = 'cancelled' AND created_at < '2023-01-01';\n\n-- 모든 행 삭제 (주의!)\nDELETE FROM temp_table;  -- WHERE 없으면 모든 데이터 삭제\n```\n\n### 다중 조건 DELETE\n\n```sql\n-- AND 조건\nDELETE FROM products\nWHERE stock = 0 AND discontinued = TRUE;\n\n-- OR 조건\nDELETE FROM logs\nWHERE level = 'DEBUG' OR created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);\n\n-- IN 사용\nDELETE FROM users\nWHERE id IN (10, 20, 30, 40);\n\n-- NOT IN\nDELETE FROM temp_users\nWHERE id NOT IN (SELECT user_id FROM orders);\n```\n\n### 서브쿼리를 사용한 DELETE\n\n```sql\n-- 주문이 없는 고객 삭제\nDELETE FROM users\nWHERE id NOT IN (\n    SELECT DISTINCT user_id FROM orders WHERE user_id IS NOT NULL\n);\n\n-- 평균보다 낮은 점수의 기록 삭제\nDELETE FROM scores\nWHERE score < (SELECT AVG(score) FROM scores);\n\n-- EXISTS 사용\nDELETE FROM products p\nWHERE NOT EXISTS (\n    SELECT 1 FROM order_items oi WHERE oi.product_id = p.id\n);\n```\n\n### JOIN을 사용한 DELETE\n\n```sql\n-- MySQL\nDELETE p\nFROM products p\nJOIN categories c ON p.category_id = c.id\nWHERE c.name = '단종품';\n\n-- 여러 테이블에서 동시 삭제\nDELETE u, o\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.status = 'deleted';\n\n-- PostgreSQL\nDELETE FROM products\nUSING categories\nWHERE products.category_id = categories.id\n  AND categories.name = '단종품';\n```\n\n### LIMIT를 사용한 DELETE (MySQL)\n\n```sql\n-- 최대 100개만 삭제\nDELETE FROM logs\nWHERE created_at < '2023-01-01'\nLIMIT 100;\n\n-- 오래된 것부터 1000개 삭제\nDELETE FROM notifications\nWHERE is_read = TRUE\nORDER BY created_at ASC\nLIMIT 1000;\n```\n\n## TRUNCATE (테이블 초기화)\n\n```sql\n-- 모든 데이터 삭제 (빠름, 롤백 불가)\nTRUNCATE TABLE logs;\n\n-- AUTO_INCREMENT도 초기화됨\nTRUNCATE TABLE temp_data;\n\n-- DELETE vs TRUNCATE\n-- DELETE: 느림, 롤백 가능, WHERE 조건 가능, 트리거 실행\n-- TRUNCATE: 빠름, 롤백 불가, 전체 삭제만, 트리거 미실행\n```\n\n## 실습 예제\n\n```sql\n-- 신규 회원 등록\nINSERT INTO users (name, email, password, created_at)\nVALUES ('새회원', 'new@example.com', 'hashed_pw', NOW());\n\n-- 주문 생성\nINSERT INTO orders (user_id, total_amount, status)\nVALUES (1, 50000, 'pending');\n\nINSERT INTO order_items (order_id, product_id, quantity, price) VALUES\n    (LAST_INSERT_ID(), 101, 2, 15000),\n    (LAST_INSERT_ID(), 205, 1, 20000);\n\n-- 재고 차감\nUPDATE products\nSET stock = stock - 2\nWHERE id = 101;\n\nUPDATE products\nSET stock = stock - 1\nWHERE id = 205;\n\n-- 주문 상태 변경\nUPDATE orders\nSET status = 'completed', completed_at = NOW()\nWHERE id = 123 AND status = 'pending';\n\n-- 30일 이상 된 로그 삭제\nDELETE FROM activity_logs\nWHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);\n\n-- 탈퇴 회원 처리\nUPDATE users\nSET status = 'deleted', deleted_at = NOW()\nWHERE id = 456;\n\n-- 실제 데이터는 보관하고 익명화\nUPDATE users\nSET \n    name = CONCAT('탈퇴회원', id),\n    email = CONCAT('deleted', id, '@deleted.com'),\n    phone = NULL\nWHERE status = 'deleted';\n```\n\n## 안전한 데이터 수정\n\n```sql\n-- 1. 먼저 SELECT로 확인\nSELECT * FROM users WHERE age < 18;\n\n-- 2. 문제 없으면 UPDATE\nUPDATE users SET status = 'minor' WHERE age < 18;\n\n-- 3. 트랜잭션 사용 (다음 장에서 학습)\nSTART TRANSACTION;\nUPDATE products SET price = price * 1.1;\n-- 확인 후\nCOMMIT;  -- 또는 ROLLBACK;\n```\n\n## 연습 문제\n\n1. products 테이블에 새 상품 3개를 한 번에 추가하세요.\n2. 재고가 10개 미만인 상품의 가격을 5% 인상하세요.\n3. 1년 이상 주문이 없는 고객을 삭제하세요 (서브쿼리 사용).\n4. 점수에 따라 학생들의 등급을 업데이트하세요 (CASE 사용).\n\n## 핵심 요약\n\n- `INSERT INTO`: 데이터 삽입\n- `VALUES`: 삽입할 값 지정\n- `INSERT INTO SELECT`: 조회 결과 삽입\n- `UPDATE SET`: 데이터 수정\n- `DELETE FROM`: 데이터 삭제\n- `TRUNCATE`: 테이블 전체 삭제 (빠름)\n- WHERE 절로 조건 지정 (없으면 전체 대상)\n- 항상 SELECT로 먼저 확인 후 수정/삭제"
    },
    {
      "chapterId": 9,
      "title": "9단원: 트랜잭션과 인덱스",
      "content": "# 9단원: 트랜잭션과 인덱스\n\n## 트랜잭션 (Transaction)\n\n트랜잭션은 데이터베이스 작업의 논리적 단위로, 모두 성공하거나 모두 실패해야 합니다.\n\n### ACID 속성\n\n- **Atomicity (원자성)**: 전부 실행되거나 전혀 실행되지 않음\n- **Consistency (일관성)**: 트랜잭션 전후 데이터 일관성 유지\n- **Isolation (격리성)**: 동시 실행 트랜잭션들이 서로 영향 없음\n- **Durability (영속성)**: 완료된 트랜잭션은 영구 보존\n\n### 기본 트랜잭션\n\n```sql\n-- 트랜잭션 시작\nSTART TRANSACTION;  -- 또는 BEGIN;\n\n-- 작업 수행\nUPDATE accounts SET balance = balance - 10000 WHERE id = 1;\nUPDATE accounts SET balance = balance + 10000 WHERE id = 2;\n\n-- 성공 시 커밋\nCOMMIT;\n\n-- 또는 실패 시 롤백\nROLLBACK;\n```\n\n### 실제 예제: 계좌 이체\n\n```sql\n-- 안전한 계좌 이체\nSTART TRANSACTION;\n\n-- 출금 계좌에서 차감\nUPDATE accounts \nSET balance = balance - 50000 \nWHERE account_number = '111-222-333'\n  AND balance >= 50000;  -- 잔액 확인\n\n-- 영향받은 행이 1개인지 확인 (애플리케이션에서)\n-- IF affected_rows = 1 THEN\n\n-- 입금 계좌에 추가\nUPDATE accounts \nSET balance = balance + 50000 \nWHERE account_number = '444-555-666';\n\n-- 거래 내역 기록\nINSERT INTO transactions (from_account, to_account, amount, type)\nVALUES ('111-222-333', '444-555-666', 50000, 'transfer');\n\n-- 성공 시 커밋\nCOMMIT;\n-- ELSE ROLLBACK;\n```\n\n### SAVEPOINT (저장점)\n\n```sql\nSTART TRANSACTION;\n\nINSERT INTO orders (user_id, total) VALUES (1, 50000);\nSAVEPOINT order_created;\n\nINSERT INTO order_items (order_id, product_id, quantity)\nVALUES (LAST_INSERT_ID(), 101, 2);\nSAVEPOINT items_added;\n\nUPDATE products SET stock = stock - 2 WHERE id = 101;\n-- 문제 발생 시\nROLLBACK TO items_added;  -- 특정 시점으로 롤백\n\n-- 또는 전체 롤백\nROLLBACK;\n\n-- 또는 성공 시\nCOMMIT;\n```\n\n### 자동 커밋\n\n```sql\n-- 자동 커밋 확인\nSELECT @@autocommit;  -- 1이면 자동 커밋 활성화\n\n-- 자동 커밋 비활성화\nSET autocommit = 0;\n\n-- 수동으로 커밋 필요\nUPDATE users SET status = 'active' WHERE id = 1;\nCOMMIT;\n\n-- 자동 커밋 다시 활성화\nSET autocommit = 1;\n```\n\n### 트랜잭션 격리 수준\n\n```sql\n-- 현재 격리 수준 확인\nSELECT @@transaction_isolation;\n\n-- 격리 수준 설정\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;  -- 가장 낮음\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;   -- MySQL 기본값\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;      -- 가장 높음\n\n-- 세션 레벨 설정\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n### 잠금 (Lock)\n\n```sql\n-- 공유 잠금 (읽기 잠금)\nSELECT * FROM products WHERE id = 1 LOCK IN SHARE MODE;\n\n-- 배타적 잠금 (쓰기 잠금)\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n\n-- 예제: 재고 차감 (동시성 문제 방지)\nSTART TRANSACTION;\n\nSELECT stock FROM products WHERE id = 1 FOR UPDATE;\n-- stock이 충분한지 확인 (애플리케이션에서)\n\nUPDATE products SET stock = stock - 5 WHERE id = 1;\n\nCOMMIT;\n```\n\n## 인덱스 (Index)\n\n인덱스는 데이터 검색 속도를 향상시키는 자료구조입니다.\n\n### 인덱스 생성\n\n```sql\n-- 단일 컬럼 인덱스\nCREATE INDEX idx_email ON users(email);\n\n-- 복합 인덱스 (여러 컬럼)\nCREATE INDEX idx_name_age ON users(name, age);\n\n-- 고유 인덱스\nCREATE UNIQUE INDEX idx_unique_email ON users(email);\n\n-- 전문 검색 인덱스 (Full-Text)\nCREATE FULLTEXT INDEX idx_content ON articles(content);\n```\n\n### 인덱스 조회\n\n```sql\n-- 테이블의 인덱스 확인\nSHOW INDEX FROM users;\n\n-- 또는\nSHOW KEYS FROM users;\n\n-- 실행 계획 확인 (인덱스 사용 여부)\nEXPLAIN SELECT * FROM users WHERE email = 'test@example.com';\n```\n\n### 인덱스 삭제\n\n```sql\n-- 인덱스 삭제\nDROP INDEX idx_email ON users;\n\n-- 또는\nALTER TABLE users DROP INDEX idx_email;\n```\n\n### 인덱스 활용 예제\n\n```sql\n-- 인덱스 생성 전\nSELECT * FROM orders WHERE user_id = 123;  -- 느림 (풀 스캔)\n\n-- 인덱스 생성\nCREATE INDEX idx_user_id ON orders(user_id);\n\n-- 인덱스 생성 후\nSELECT * FROM orders WHERE user_id = 123;  -- 빠름 (인덱스 스캔)\n\n-- 복합 인덱스 활용\nCREATE INDEX idx_status_date ON orders(status, order_date);\n\n-- 효과적으로 사용됨\nSELECT * FROM orders \nWHERE status = 'pending' AND order_date >= '2024-01-01';\n\n-- 첫 번째 컬럼만 사용해도 효과적\nSELECT * FROM orders WHERE status = 'pending';\n\n-- 두 번째 컬럼만 사용하면 비효율적\nSELECT * FROM orders WHERE order_date >= '2024-01-01';  -- 인덱스 미사용\n```\n\n### 인덱스 사용 시 주의사항\n\n```sql\n-- 인덱스가 사용되지 않는 경우\n\n-- 1. 함수 사용\nSELECT * FROM users WHERE UPPER(email) = 'TEST@EXAMPLE.COM';  -- 인덱스 미사용\nSELECT * FROM users WHERE email = 'test@example.com';          -- 인덱스 사용\n\n-- 2. LIKE의 와일드카드가 앞에\nSELECT * FROM users WHERE name LIKE '%길동';   -- 인덱스 미사용\nSELECT * FROM users WHERE name LIKE '홍%';     -- 인덱스 사용\n\n-- 3. OR 조건 (인덱스가 없는 컬럼과 함께)\nSELECT * FROM users WHERE email = 'test@example.com' OR phone = '010-1234-5678';\n-- phone에 인덱스 없으면 풀 스캔\n\n-- 4. NOT 연산자\nSELECT * FROM users WHERE email != 'test@example.com';  -- 인덱스 미사용\n\n-- 5. 타입이 다른 경우\nSELECT * FROM users WHERE user_id = '123';  -- user_id가 INT면 인덱스 미사용\nSELECT * FROM users WHERE user_id = 123;    -- 인덱스 사용\n```\n\n### 커버링 인덱스\n\n```sql\n-- 인덱스만으로 쿼리 처리 가능 (테이블 접근 불필요)\nCREATE INDEX idx_name_age_city ON users(name, age, city);\n\n-- 커버링 인덱스 사용\nSELECT name, age, city FROM users WHERE name = '홍길동';\n-- 인덱스에 필요한 모든 컬럼이 있어서 매우 빠름\n\n-- 커버링 인덱스 미사용\nSELECT name, age, city, email FROM users WHERE name = '홍길동';\n-- email이 인덱스에 없어서 테이블 접근 필요\n```\n\n## 실습 예제\n\n```sql\n-- 주문 처리 트랜잭션\nSTART TRANSACTION;\n\n-- 1. 재고 확인 및 잠금\nSELECT stock FROM products WHERE id = 101 FOR UPDATE;\n\n-- 2. 재고가 충분하면 주문 생성\nINSERT INTO orders (user_id, total_amount, status)\nVALUES (1, 50000, 'pending');\n\nSET @order_id = LAST_INSERT_ID();\n\n-- 3. 주문 상세 추가\nINSERT INTO order_items (order_id, product_id, quantity, price)\nVALUES (@order_id, 101, 2, 25000);\n\n-- 4. 재고 차감\nUPDATE products SET stock = stock - 2 WHERE id = 101;\n\n-- 5. 포인트 차감\nUPDATE users SET points = points - 1000 WHERE id = 1;\n\nCOMMIT;\n\n-- 성능 개선을 위한 인덱스 생성\nCREATE INDEX idx_user_orders ON orders(user_id, order_date);\nCREATE INDEX idx_product_category ON products(category_id, price);\nCREATE INDEX idx_order_status ON orders(status, created_at);\n\n-- 쿼리 성능 확인\nEXPLAIN SELECT * FROM orders \nWHERE user_id = 1 \nORDER BY order_date DESC;\n```\n\n## 연습 문제\n\n1. 계좌 이체를 구현하는 트랜잭션을 작성하세요.\n2. users 테이블의 email 컬럼에 고유 인덱스를 생성하세요.\n3. orders 테이블에서 user_id와 status를 함께 검색하는 복합 인덱스를 만드세요.\n4. EXPLAIN을 사용하여 쿼리가 인덱스를 사용하는지 확인하세요.\n\n## 핵심 요약\n\n- `START TRANSACTION` / `BEGIN`: 트랜잭션 시작\n- `COMMIT`: 변경사항 확정\n- `ROLLBACK`: 변경사항 취소\n- `SAVEPOINT`: 중간 저장점\n- ACID: 원자성, 일관성, 격리성, 영속성\n- `CREATE INDEX`: 인덱스 생성\n- `EXPLAIN`: 실행 계획 확인\n- 인덱스는 조회 속도 향상, 삽입/수정/삭제 속도 저하\n- 적절한 인덱스 설계가 성능의 핵심"
    },
    {
      "chapterId": 10,
      "title": "10단원: 고급 기능과 최적화",
      "content": "# 10단원: 고급 기능과 최적화\n\n## 윈도우 함수 (Window Functions)\n\n윈도우 함수는 그룹화하지 않고 집계 결과를 계산합니다.\n\n### ROW_NUMBER, RANK, DENSE_RANK\n\n```sql\n-- 순위 매기기\nSELECT \n    name,\n    score,\n    ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num,\n    RANK() OVER (ORDER BY score DESC) AS rank,\n    DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank\nFROM students;\n\n-- 결과:\n-- name   score  row_num  rank  dense_rank\n-- Alice  100    1        1     1\n-- Bob    95     2        2     2\n-- Carol  95     3        2     2\n-- David  90     4        4     3\n\n-- 부서별 순위\nSELECT \n    name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank\nFROM employees;\n```\n\n### NTILE (그룹 나누기)\n\n```sql\n-- 4분위수로 나누기\nSELECT \n    name,\n    score,\n    NTILE(4) OVER (ORDER BY score DESC) AS quartile\nFROM students;\n```\n\n### LAG, LEAD (이전/다음 행)\n\n```sql\n-- 이전 행, 다음 행 값 가져오기\nSELECT \n    order_date,\n    amount,\n    LAG(amount) OVER (ORDER BY order_date) AS prev_amount,\n    LEAD(amount) OVER (ORDER BY order_date) AS next_amount,\n    amount - LAG(amount) OVER (ORDER BY order_date) AS diff\nFROM orders;\n\n-- 전월 대비 매출 증감\nSELECT \n    DATE_FORMAT(order_date, '%Y-%m') AS month,\n    SUM(amount) AS monthly_sales,\n    LAG(SUM(amount)) OVER (ORDER BY DATE_FORMAT(order_date, '%Y-%m')) AS prev_month,\n    SUM(amount) - LAG(SUM(amount)) OVER (ORDER BY DATE_FORMAT(order_date, '%Y-%m')) AS growth\nFROM orders\nGROUP BY month;\n```\n\n### FIRST_VALUE, LAST_VALUE\n\n```sql\n-- 그룹 내 첫/마지막 값\nSELECT \n    name,\n    department,\n    salary,\n    FIRST_VALUE(salary) OVER (\n        PARTITION BY department ORDER BY salary DESC\n    ) AS highest_in_dept\nFROM employees;\n```\n\n## 피벗 (Pivot)\n\n```sql\n-- CASE를 사용한 피벗\nSELECT \n    product_name,\n    SUM(CASE WHEN MONTH(order_date) = 1 THEN amount ELSE 0 END) AS Jan,\n    SUM(CASE WHEN MONTH(order_date) = 2 THEN amount ELSE 0 END) AS Feb,\n    SUM(CASE WHEN MONTH(order_date) = 3 THEN amount ELSE 0 END) AS Mar\nFROM order_items\nGROUP BY product_name;\n\n-- 동적 피벗 (저장 프로시저 필요)\n-- MySQL 8.0+\nSET @sql = NULL;\nSELECT\n  GROUP_CONCAT(DISTINCT\n    CONCAT(\n      'SUM(CASE WHEN month = \"', month, '\" THEN amount ELSE 0 END) AS `', month, '`'\n    )\n  ) INTO @sql\nFROM monthly_sales;\n\nSET @sql = CONCAT('SELECT product_id, ', @sql, ' FROM monthly_sales GROUP BY product_id');\nPREPARE stmt FROM @sql;\nEXECUTE stmt;\nDEALLOCATE PREPARE stmt;\n```\n\n## JSON 처리\n\n```sql\n-- JSON 컬럼 생성\nCREATE TABLE products (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    attributes JSON\n);\n\n-- JSON 데이터 삽입\nINSERT INTO products (id, name, attributes) VALUES\n(1, '노트북', '{\"color\": \"silver\", \"weight\": 1.5, \"ports\": [\"USB-C\", \"HDMI\"]}'),\n(2, '마우스', '{\"color\": \"black\", \"wireless\": true}');\n\n-- JSON 값 추출\nSELECT \n    name,\n    JSON_EXTRACT(attributes, '$.color') AS color,\n    attributes->>'$.color' AS color_text,\n    JSON_EXTRACT(attributes, '$.ports[0]') AS first_port\nFROM products;\n\n-- JSON 값으로 필터링\nSELECT * FROM products\nWHERE JSON_EXTRACT(attributes, '$.wireless') = true;\n\n-- JSON 수정\nUPDATE products\nSET attributes = JSON_SET(attributes, '$.color', 'blue')\nWHERE id = 1;\n\n-- JSON 배열 다루기\nSELECT \n    name,\n    JSON_LENGTH(attributes, '$.ports') AS port_count\nFROM products;\n```\n\n## 뷰 (View)\n\n```sql\n-- 뷰 생성\nCREATE VIEW active_users AS\nSELECT id, name, email, created_at\nFROM users\nWHERE status = 'active';\n\n-- 뷰 사용\nSELECT * FROM active_users;\n\n-- 복잡한 쿼리를 뷰로\nCREATE VIEW user_order_summary AS\nSELECT \n    u.id,\n    u.name,\n    COUNT(o.id) AS order_count,\n    SUM(o.amount) AS total_spent,\n    MAX(o.order_date) AS last_order_date\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- 뷰 수정\nCREATE OR REPLACE VIEW active_users AS\nSELECT id, name, email, phone, created_at\nFROM users\nWHERE status = 'active' AND deleted_at IS NULL;\n\n-- 뷰 삭제\nDROP VIEW active_users;\n```\n\n## 저장 프로시저 (Stored Procedure)\n\n```sql\n-- 간단한 프로시저\nDELIMITER $$\n\nCREATE PROCEDURE GetUserOrders(IN userId INT)\nBEGIN\n    SELECT * FROM orders WHERE user_id = userId;\nEND$$\n\nDELIMITER ;\n\n-- 프로시저 호출\nCALL GetUserOrders(1);\n\n-- 매개변수가 있는 프로시저\nDELIMITER $$\n\nCREATE PROCEDURE CreateOrder(\n    IN p_user_id INT,\n    IN p_product_id INT,\n    IN p_quantity INT,\n    OUT p_order_id INT\n)\nBEGIN\n    DECLARE v_price DECIMAL(10,2);\n    \n    -- 상품 가격 조회\n    SELECT price INTO v_price FROM products WHERE id = p_product_id;\n    \n    -- 주문 생성\n    INSERT INTO orders (user_id, total_amount, status)\n    VALUES (p_user_id, v_price * p_quantity, 'pending');\n    \n    SET p_order_id = LAST_INSERT_ID();\n    \n    -- 주문 상세 추가\n    INSERT INTO order_items (order_id, product_id, quantity, price)\n    VALUES (p_order_id, p_product_id, p_quantity, v_price);\n    \n    -- 재고 차감\n    UPDATE products SET stock = stock - p_quantity WHERE id = p_product_id;\nEND$$\n\nDELIMITER ;\n\n-- 프로시저 호출\nCALL CreateOrder(1, 101, 2, @new_order_id);\nSELECT @new_order_id;\n```\n\n## 트리거 (Trigger)\n\n```sql\n-- INSERT 후 트리거\nDELIMITER $$\n\nCREATE TRIGGER after_order_insert\nAFTER INSERT ON orders\nFOR EACH ROW\nBEGIN\n    -- 사용자의 총 주문 금액 업데이트\n    UPDATE users\n    SET total_spent = total_spent + NEW.amount\n    WHERE id = NEW.user_id;\nEND$$\n\nDELIMITER ;\n\n-- UPDATE 전 트리거 (유효성 검사)\nDELIMITER $$\n\nCREATE TRIGGER before_product_update\nBEFORE UPDATE ON products\nFOR EACH ROW\nBEGIN\n    IF NEW.price < 0 THEN\n        SIGNAL SQLSTATE '45000'\n        SET MESSAGE_TEXT = '가격은 음수일 수 없습니다';\n    END IF;\n    \n    IF NEW.stock < 0 THEN\n        SET NEW.stock = 0;\n    END IF;\nEND$$\n\nDELIMITER ;\n\n-- 로그 기록 트리거\nDELIMITER $$\n\nCREATE TRIGGER log_product_changes\nAFTER UPDATE ON products\nFOR EACH ROW\nBEGIN\n    INSERT INTO product_audit_log (product_id, old_price, new_price, changed_at)\n    VALUES (NEW.id, OLD.price, NEW.price, NOW());\nEND$$\n\nDELIMITER ;\n```\n\n## 쿼리 최적화\n\n```sql\n-- 1. EXPLAIN으로 실행 계획 확인\nEXPLAIN SELECT * FROM orders WHERE user_id = 1;\n\n-- 2. 인덱스 활용 확인\nEXPLAIN SELECT * FROM products WHERE category_id = 1 AND price > 10000;\n\n-- 3. COUNT(*) 최적화\n-- Bad\nSELECT COUNT(*) FROM large_table;\n-- Good (대략적인 수가 필요한 경우)\nSELECT table_rows FROM information_schema.tables \nWHERE table_name = 'large_table';\n\n-- 4. EXISTS vs IN\n-- EXISTS가 더 빠름 (특히 큰 테이블)\nSELECT * FROM users u\nWHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);\n\n-- 5. LIMIT 사용\nSELECT * FROM products ORDER BY created_at DESC LIMIT 100;\n\n-- 6. 필요한 컬럼만 SELECT\n-- Bad\nSELECT * FROM users;\n-- Good\nSELECT id, name, email FROM users;\n\n-- 7. JOIN 순서 최적화 (작은 테이블 먼저)\nSELECT *\nFROM small_table s\nJOIN large_table l ON s.id = l.small_id;\n```\n\n## 파티셔닝\n\n```sql\n-- RANGE 파티셔닝 (날짜별)\nCREATE TABLE orders_partitioned (\n    id INT,\n    user_id INT,\n    order_date DATE,\n    amount DECIMAL(10,2)\n)\nPARTITION BY RANGE (YEAR(order_date)) (\n    PARTITION p2022 VALUES LESS THAN (2023),\n    PARTITION p2023 VALUES LESS THAN (2024),\n    PARTITION p2024 VALUES LESS THAN (2025),\n    PARTITION p_future VALUES LESS THAN MAXVALUE\n);\n\n-- LIST 파티셔닝\nCREATE TABLE users_partitioned (\n    id INT,\n    name VARCHAR(100),\n    country VARCHAR(50)\n)\nPARTITION BY LIST COLUMNS(country) (\n    PARTITION p_asia VALUES IN ('KR', 'JP', 'CN'),\n    PARTITION p_europe VALUES IN ('UK', 'FR', 'DE'),\n    PARTITION p_america VALUES IN ('US', 'CA')\n);\n```\n\n## 실습 예제\n\n```sql\n-- 복합 쿼리: 월별 매출 순위와 전월 대비 증감\nWITH monthly_sales AS (\n    SELECT \n        DATE_FORMAT(order_date, '%Y-%m') AS month,\n        SUM(amount) AS total_sales\n    FROM orders\n    GROUP BY month\n)\nSELECT \n    month,\n    total_sales,\n    LAG(total_sales) OVER (ORDER BY month) AS prev_month_sales,\n    total_sales - LAG(total_sales) OVER (ORDER BY month) AS growth,\n    ROUND(\n        (total_sales - LAG(total_sales) OVER (ORDER BY month)) \n        / LAG(total_sales) OVER (ORDER BY month) * 100, 2\n    ) AS growth_rate\nFROM monthly_sales\nORDER BY month DESC;\n\n-- 성능 분석\nSHOW PROFILE;\nSHOW PROFILES;\n\n-- 슬로우 쿼리 로그 활성화\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 1;  -- 1초 이상 쿼리 기록\n```\n\n## 연습 문제\n\n1. ROW_NUMBER를 사용하여 각 카테고리별 상위 3개 상품을 조회하세요.\n2. 전월 대비 매출 증감률을 계산하는 쿼리를 작성하세요 (LAG 사용).\n3. 주문 생성 시 재고를 자동으로 차감하는 트리거를 만드세요.\n4. EXPLAIN을 사용하여 느린 쿼리를 분석하고 최적화하세요.\n\n## 핵심 요약\n\n- 윈도우 함수: `ROW_NUMBER`, `RANK`, `LAG`, `LEAD`\n- `PARTITION BY`: 그룹별 윈도우 함수 적용\n- 뷰: 복잡한 쿼리를 간단하게\n- 저장 프로시저: 재사용 가능한 SQL 로직\n- 트리거: 자동 실행되는 이벤트 핸들러\n- `EXPLAIN`: 쿼리 실행 계획 분석\n- 인덱스, 파티셔닝으로 성능 최적화\n- JSON 지원으로 유연한 데이터 저장"
    }
  ]
}
