{
  "language": "go",
  "chapters": [
    {
      "chapterId": 1,
      "title": "1단원: 출력과 주석",
      "content": "# 1단원: 출력과 주석\n\n## 출력 (Output)\n\nGo에서 콘솔에 출력하려면 `fmt` 패키지를 사용합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n    fmt.Println(\"안녕하세요\")\n}\n```\n\n## fmt 패키지의 출력 함수\n\n### Println vs Print vs Printf\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Println: 줄바꿈 포함\n    fmt.Println(\"Hello\")\n    fmt.Println(\"World\")\n    \n    // Print: 줄바꿈 없음\n    fmt.Print(\"Hello \")\n    fmt.Print(\"World\\n\")\n    \n    // Printf: 형식 지정 출력\n    name := \"Alice\"\n    age := 25\n    fmt.Printf(\"이름: %s, 나이: %d\\n\", name, age)\n}\n```\n\n## Printf 형식 지정자\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // %v: 기본 형식\n    fmt.Printf(\"%v\\n\", 42)\n    \n    // %d: 정수\n    fmt.Printf(\"%d\\n\", 42)\n    \n    // %f: 실수\n    fmt.Printf(\"%.2f\\n\", 3.14159)\n    \n    // %s: 문자열\n    fmt.Printf(\"%s\\n\", \"Hello\")\n    \n    // %t: 불리언\n    fmt.Printf(\"%t\\n\", true)\n    \n    // %T: 타입\n    fmt.Printf(\"%T\\n\", 42)\n}\n```\n\n## 주석 (Comments)\n\n주석은 코드에 설명을 추가하는 방법입니다.\n\n### 한 줄 주석\n\n```go\n// 이것은 한 줄 주석입니다\nfmt.Println(\"Hello\") // 코드 옆에도 작성 가능\n```\n\n### 여러 줄 주석\n\n```go\n/*\n  이것은\n  여러 줄\n  주석입니다\n*/\nfmt.Println(\"World\")\n```\n\n### 문서화 주석\n\n```go\n// Add 함수는 두 정수를 더합니다.\n// a와 b를 더한 결과를 반환합니다.\nfunc Add(a, b int) int {\n    return a + b\n}\n```\n\n## 이스케이프 문자\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"줄바꿈\\n테스트\")\n    fmt.Println(\"탭\\t간격\")\n    fmt.Println(\"작은따옴표: 'Hello'\")\n    fmt.Println(\"큰따옴표: \\\"World\\\"\")\n    fmt.Println(\"백슬래시: \\\\\\\\\")\n}\n```\n\n## Sprintf - 문자열 포맷팅\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Alice\"\n    age := 25\n    \n    // 포맷된 문자열 생성\n    message := fmt.Sprintf(\"이름: %s, 나이: %d\", name, age)\n    fmt.Println(message)\n    \n    // 계산 결과 포맷팅\n    result := fmt.Sprintf(\"1 + 2 = %d\", 1+2)\n    fmt.Println(result)\n}\n```\n\n## 연습 문제\n\n1. 자신의 이름과 나이를 출력하는 프로그램을 작성하세요\n2. Printf를 사용해 소수점 둘째 자리까지 실수를 출력하세요\n3. 주석을 사용해 코드에 설명을 추가하세요\n\n## 핵심 요약\n\n- `fmt.Println()`: 줄바꿈 포함 출력\n- `fmt.Print()`: 줄바꿈 없이 출력\n- `fmt.Printf()`: 형식 지정 출력\n- `//`: 한 줄 주석\n- `/* */`: 여러 줄 주석\n- `%d`, `%f`, `%s`, `%v`: Printf 형식 지정자\n- `\\n`, `\\t`: 이스케이프 문자\n- `fmt.Sprintf()`: 문자열 포맷팅"
    },
    {
      "chapterId": 2,
      "title": "2단원: 변수와 자료형",
      "content": "# 2단원: 변수와 자료형\n\n## 변수 선언\n\nGo에서 변수를 선언하는 방법은 여러 가지가 있습니다.\n\n### var 키워드\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 타입 명시\n    var name string = \"Alice\"\n    var age int = 25\n    var height float64 = 170.5\n    \n    // 타입 추론\n    var city = \"Seoul\"\n    \n    // 여러 변수 동시 선언\n    var x, y int = 10, 20\n    \n    fmt.Println(name, age, height, city, x, y)\n}\n```\n\n### 짧은 선언 (:=)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // := 사용 (함수 내부에서만 가능)\n    name := \"Bob\"\n    age := 30\n    isStudent := true\n    \n    fmt.Println(name, age, isStudent)\n    \n    // 여러 변수 동시 선언\n    x, y := 10, 20\n    fmt.Println(x, y)\n}\n```\n\n## 기본 자료형\n\n### 정수형 (Integer)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a int = 42        // 플랫폼에 따라 32비트 또는 64비트\n    var b int8 = 127      // -128 ~ 127\n    var c int16 = 32767   // -32768 ~ 32767\n    var d int32 = 2147483647\n    var e int64 = 9223372036854775807\n    \n    // 부호 없는 정수\n    var f uint = 42\n    var g uint8 = 255     // 0 ~ 255\n    var h uint16 = 65535\n    \n    fmt.Println(a, b, c, d, e, f, g, h)\n}\n```\n\n### 실수형 (Float)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var pi float32 = 3.14159\n    var e float64 = 2.718281828\n    \n    fmt.Printf(\"pi: %.2f\\n\", pi)\n    fmt.Printf(\"e: %.5f\\n\", e)\n}\n```\n\n### 문자열 (String)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var greeting string = \"Hello\"\n    name := \"Alice\"\n    \n    // 문자열 연결\n    message := greeting + \", \" + name + \"!\"\n    fmt.Println(message)\n    \n    // 여러 줄 문자열\n    multiline := `첫 번째 줄\n두 번째 줄\n세 번째 줄`\n    fmt.Println(multiline)\n}\n```\n\n### 불리언 (Boolean)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var isTrue bool = true\n    isFalse := false\n    \n    result := 5 > 3  // true\n    check := 10 == 5 // false\n    \n    fmt.Println(isTrue, isFalse, result, check)\n}\n```\n\n## 제로 값 (Zero Value)\n\nGo는 변수 선언 시 자동으로 제로 값으로 초기화됩니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int        // 0\n    var f float64    // 0.0\n    var s string     // \"\" (빈 문자열)\n    var b bool       // false\n    \n    fmt.Printf(\"%d %f %q %t\\n\", i, f, s, b)\n}\n```\n\n## 상수 (Constants)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    const PI = 3.14159\n    const MAX_SIZE = 100\n    \n    // 여러 상수 동시 선언\n    const (\n        SUNDAY = 0\n        MONDAY = 1\n        TUESDAY = 2\n    )\n    \n    fmt.Println(PI, MAX_SIZE, MONDAY)\n}\n```\n\n## 타입 변환\n\nGo는 명시적 타입 변환이 필요합니다.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // 숫자 타입 변환\n    var i int = 42\n    var f float64 = float64(i)\n    var u uint = uint(f)\n    \n    fmt.Println(i, f, u)\n    \n    // 문자열 변환\n    str := \"123\"\n    num, _ := strconv.Atoi(str) // string to int\n    fmt.Println(num)\n    \n    // int to string\n    numStr := strconv.Itoa(42)\n    fmt.Println(numStr)\n    \n    // float to string\n    floatStr := strconv.FormatFloat(3.14, 'f', 2, 64)\n    fmt.Println(floatStr)\n}\n```\n\n## 타입 추론과 타입 확인\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    x := 42        // int로 추론\n    y := 3.14      // float64로 추론\n    z := \"Hello\"   // string으로 추론\n    \n    // 타입 확인\n    fmt.Printf(\"%T\\n\", x)  // int\n    fmt.Println(reflect.TypeOf(y))  // float64\n    fmt.Printf(\"Type: %T\\n\", z)     // string\n}\n```\n\n## 포인터 기본\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var x int = 42\n    var p *int = &x  // x의 주소\n    \n    fmt.Println(\"값:\", x)      // 42\n    fmt.Println(\"주소:\", p)    // 메모리 주소\n    fmt.Println(\"포인터 값:\", *p)  // 42\n    \n    // 포인터로 값 변경\n    *p = 100\n    fmt.Println(\"변경된 값:\", x)  // 100\n}\n```\n\n## 연습 문제\n\n1. 여러 자료형의 변수를 선언하고 출력하세요\n2. 문자열을 정수로 변환하고 계산해보세요\n3. 포인터를 사용해 변수의 값을 변경해보세요\n\n## 핵심 요약\n\n- `var`: 변수 선언\n- `:=`: 짧은 선언 (함수 내부)\n- `int`, `int8`, `int16`, `int32`, `int64`: 정수형\n- `uint`: 부호 없는 정수\n- `float32`, `float64`: 실수형\n- `string`: 문자열\n- `bool`: 불리언\n- `const`: 상수\n- 제로 값: 자동 초기화\n- 타입 변환: 명시적 변환 필요\n- `*`: 포인터"
    },
    {
      "chapterId": 3,
      "title": "3단원: 연산자",
      "content": "# 3단원: 연산자\n\n## 산술 연산자 (Arithmetic Operators)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    a := 10\n    b := 3\n    \n    fmt.Println(a + b)  // 13 (덧셈)\n    fmt.Println(a - b)  // 7  (뺄셈)\n    fmt.Println(a * b)  // 30 (곱셈)\n    fmt.Println(a / b)  // 3  (나눗셈, 정수)\n    fmt.Println(a % b)  // 1  (나머지)\n    \n    // 실수 나눗셈\n    fmt.Println(float64(a) / float64(b))  // 3.333...\n}\n```\n\n## 증감 연산자\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    count := 5\n    \n    count++  // count = count + 1\n    fmt.Println(count)  // 6\n    \n    count--  // count = count - 1\n    fmt.Println(count)  // 5\n    \n    // Go에는 전위 증감 연산자가 없음\n    // ++count (불가능)\n    // --count (불가능)\n}\n```\n\n## 비교 연산자 (Comparison Operators)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    a := 10\n    b := 20\n    \n    fmt.Println(a == b)  // false (같음)\n    fmt.Println(a != b)  // true  (다름)\n    fmt.Println(a > b)   // false (크다)\n    fmt.Println(a < b)   // true  (작다)\n    fmt.Println(a >= b)  // false (크거나 같다)\n    fmt.Println(a <= b)  // true  (작거나 같다)\n}\n```\n\n## 논리 연산자 (Logical Operators)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    isStudent := true\n    hasTicket := false\n    \n    // AND (&&)\n    fmt.Println(isStudent && hasTicket)  // false\n    \n    // OR (||)\n    fmt.Println(isStudent || hasTicket)  // true\n    \n    // NOT (!)\n    fmt.Println(!isStudent)  // false\n    fmt.Println(!hasTicket)  // true\n    \n    // 복합 조건\n    age := 20\n    canDrive := age >= 18 && hasTicket\n    fmt.Println(canDrive)  // false\n}\n```\n\n## 대입 연산자 (Assignment Operators)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    \n    x += 5   // x = x + 5  -> 15\n    fmt.Println(x)\n    \n    x -= 3   // x = x - 3  -> 12\n    fmt.Println(x)\n    \n    x *= 2   // x = x * 2  -> 24\n    fmt.Println(x)\n    \n    x /= 4   // x = x / 4  -> 6\n    fmt.Println(x)\n    \n    x %= 4   // x = x % 4  -> 2\n    fmt.Println(x)\n}\n```\n\n## 비트 연산자 (Bitwise Operators)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    a := 60  // 0011 1100\n    b := 13  // 0000 1101\n    \n    // AND\n    fmt.Println(a & b)   // 12 (0000 1100)\n    \n    // OR\n    fmt.Println(a | b)   // 61 (0011 1101)\n    \n    // XOR\n    fmt.Println(a ^ b)   // 49 (0011 0001)\n    \n    // 왼쪽 시프트\n    fmt.Println(a << 2)  // 240 (1111 0000)\n    \n    // 오른쪽 시프트\n    fmt.Println(a >> 2)  // 15 (0000 1111)\n}\n```\n\n## 포인터 연산자\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 42\n    \n    // & (주소 연산자)\n    p := &x\n    fmt.Printf(\"주소: %p\\n\", p)\n    \n    // * (역참조 연산자)\n    fmt.Println(\"값:\", *p)  // 42\n    \n    // 포인터로 값 변경\n    *p = 100\n    fmt.Println(\"변경된 값:\", x)  // 100\n}\n```\n\n## 연산자 우선순위\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 곱셈이 덧셈보다 우선\n    result1 := 5 + 3 * 2\n    fmt.Println(result1)  // 11\n    \n    // 괄호로 우선순위 변경\n    result2 := (5 + 3) * 2\n    fmt.Println(result2)  // 16\n    \n    // 복잡한 연산\n    result3 := 10 + 5*2 - 3\n    fmt.Println(result3)  // 17\n}\n```\n\n## 타입 변환과 연산\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a int = 10\n    var b float64 = 3.5\n    \n    // 타입 변환 필요\n    result := float64(a) + b\n    fmt.Println(result)  // 13.5\n    \n    // 정수 변환\n    result2 := a + int(b)\n    fmt.Println(result2)  // 13\n}\n```\n\n## 실전 예제\n\n### 온도 변환 (섭씨 ↔ 화씨)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    celsius := 25.0\n    \n    // 섭씨를 화씨로\n    fahrenheit := celsius*9/5 + 32\n    fmt.Printf(\"%.1f°C = %.1f°F\\n\", celsius, fahrenheit)\n    \n    // 화씨를 섭씨로\n    fahr := 77.0\n    cels := (fahr - 32) * 5 / 9\n    fmt.Printf(\"%.1f°F = %.1f°C\\n\", fahr, cels)\n}\n```\n\n### 짝수/홀수 판별\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    number := 17\n    \n    if number%2 == 0 {\n        fmt.Printf(\"%d는 짝수입니다\\n\", number)\n    } else {\n        fmt.Printf(\"%d는 홀수입니다\\n\", number)\n    }\n}\n```\n\n### 비트 플래그 활용\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n        READ  = 1 << 0  // 1 (0001)\n        WRITE = 1 << 1  // 2 (0010)\n        EXEC  = 1 << 2  // 4 (0100)\n    )\n    \n    // 권한 설정\n    permission := READ | WRITE  // 3 (0011)\n    \n    // 권한 확인\n    hasRead := (permission & READ) != 0\n    hasWrite := (permission & WRITE) != 0\n    hasExec := (permission & EXEC) != 0\n    \n    fmt.Printf(\"읽기: %t, 쓰기: %t, 실행: %t\\n\", hasRead, hasWrite, hasExec)\n}\n```\n\n## 연습 문제\n\n1. 두 숫자를 받아 사칙연산 결과를 모두 출력하세요\n2. 나이를 입력받아 성인/미성년자를 판별하세요\n3. 비트 연산을 사용해 두 수를 교환하세요\n\n## 핵심 요약\n\n- `+, -, *, /, %`: 산술 연산자\n- `++, --`: 증감 연산자 (후위만 가능)\n- `==, !=, >, <, >=, <=`: 비교 연산자\n- `&&, ||, !`: 논리 연산자\n- `+=, -=, *=, /=, %=`: 복합 대입 연산자\n- `&, |, ^, <<, >>`: 비트 연산자\n- `&, *`: 포인터 연산자\n- 타입이 다른 연산은 명시적 변환 필요"
    },
    {
      "chapterId": 4,
      "title": "4단원: 조건문",
      "content": "# 4단원: 조건문\n\n## if 문\n\n조건이 참일 때 코드 블록을 실행합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    age := 20\n    \n    if age >= 18 {\n        fmt.Println(\"성인입니다\")\n    }\n    \n    // 괄호 없이 사용 (Go 스타일)\n    score := 85\n    if score >= 60 {\n        fmt.Println(\"합격입니다\")\n    }\n}\n```\n\n## if-else 문\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    score := 75\n    \n    if score >= 80 {\n        fmt.Println(\"합격입니다\")\n    } else {\n        fmt.Println(\"불합격입니다\")\n    }\n}\n```\n\n## if-else if-else 문\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    score := 85\n    \n    if score >= 90 {\n        fmt.Println(\"A학점\")\n    } else if score >= 80 {\n        fmt.Println(\"B학점\")\n    } else if score >= 70 {\n        fmt.Println(\"C학점\")\n    } else if score >= 60 {\n        fmt.Println(\"D학점\")\n    } else {\n        fmt.Println(\"F학점\")\n    }\n}\n```\n\n## 짧은 문장을 포함한 if\n\nGo의 특징적인 문법입니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 변수 선언과 조건 검사를 한 번에\n    if age := 20; age >= 18 {\n        fmt.Println(\"성인입니다\")\n        fmt.Println(\"나이:\", age)\n    } // age는 여기서 범위를 벗어남\n    \n    // 함수 반환값 확인\n    if num := getNumber(); num > 0 {\n        fmt.Println(\"양수:\", num)\n    } else {\n        fmt.Println(\"음수 또는 0:\", num)\n    }\n}\n\nfunc getNumber() int {\n    return 42\n}\n```\n\n## switch 문\n\n값에 따라 다른 코드를 실행합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    grade := \"B\"\n    \n    switch grade {\n    case \"A\":\n        fmt.Println(\"우수\")\n    case \"B\":\n        fmt.Println(\"양호\")\n    case \"C\":\n        fmt.Println(\"보통\")\n    default:\n        fmt.Println(\"재평가 필요\")\n    }\n}\n```\n\n## 여러 값을 가진 case\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    day := 3\n    \n    switch day {\n    case 1, 2, 3, 4, 5:\n        fmt.Println(\"평일\")\n    case 6, 7:\n        fmt.Println(\"주말\")\n    default:\n        fmt.Println(\"잘못된 요일\")\n    }\n}\n```\n\n## 조건식이 있는 switch\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    score := 85\n    \n    // switch 뒤에 변수 없이 사용\n    switch {\n    case score >= 90:\n        fmt.Println(\"A학점\")\n    case score >= 80:\n        fmt.Println(\"B학점\")\n    case score >= 70:\n        fmt.Println(\"C학점\")\n    default:\n        fmt.Println(\"F학점\")\n    }\n}\n```\n\n## 짧은 문장을 포함한 switch\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 변수 선언과 switch 동시에\n    switch num := 42; {\n    case num < 0:\n        fmt.Println(\"음수\")\n    case num == 0:\n        fmt.Println(\"0\")\n    case num > 0:\n        fmt.Println(\"양수\")\n    }\n}\n```\n\n## fallthrough\n\nGo의 switch는 자동으로 break되지만, fallthrough로 다음 case 실행 가능합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    num := 1\n    \n    switch num {\n    case 1:\n        fmt.Println(\"1입니다\")\n        fallthrough\n    case 2:\n        fmt.Println(\"1 또는 2입니다\")\n        fallthrough\n    case 3:\n        fmt.Println(\"1, 2, 또는 3입니다\")\n    }\n    \n    // 출력:\n    // 1입니다\n    // 1 또는 2입니다\n    // 1, 2, 또는 3입니다\n}\n```\n\n## 타입 switch\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var x interface{} = \"hello\"\n    \n    switch v := x.(type) {\n    case int:\n        fmt.Printf(\"정수: %d\\n\", v)\n    case string:\n        fmt.Printf(\"문자열: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"불리언: %t\\n\", v)\n    default:\n        fmt.Printf(\"알 수 없는 타입: %T\\n\", v)\n    }\n}\n```\n\n## 실전 예제\n\n### BMI 계산기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    height := 1.75 // m\n    weight := 70.0 // kg\n    \n    bmi := weight / (height * height)\n    \n    var category string\n    switch {\n    case bmi < 18.5:\n        category = \"저체중\"\n    case bmi < 23:\n        category = \"정상\"\n    case bmi < 25:\n        category = \"과체중\"\n    default:\n        category = \"비만\"\n    }\n    \n    fmt.Printf(\"BMI: %.1f\\n\", bmi)\n    fmt.Printf(\"분류: %s\\n\", category)\n}\n```\n\n### 계절 판별\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    month := 7\n    var season string\n    \n    switch month {\n    case 12, 1, 2:\n        season = \"겨울\"\n    case 3, 4, 5:\n        season = \"봄\"\n    case 6, 7, 8:\n        season = \"여름\"\n    case 9, 10, 11:\n        season = \"가을\"\n    default:\n        season = \"잘못된 월\"\n    }\n    \n    fmt.Printf(\"%d월은 %s입니다\\n\", month, season)\n}\n```\n\n### 간단한 계산기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    a, b := 10, 5\n    operator := \"+\"\n    \n    switch operator {\n    case \"+\":\n        fmt.Printf(\"%d + %d = %d\\n\", a, b, a+b)\n    case \"-\":\n        fmt.Printf(\"%d - %d = %d\\n\", a, b, a-b)\n    case \"*\":\n        fmt.Printf(\"%d * %d = %d\\n\", a, b, a*b)\n    case \"/\":\n        if b != 0 {\n            fmt.Printf(\"%d / %d = %d\\n\", a, b, a/b)\n        } else {\n            fmt.Println(\"0으로 나눌 수 없습니다\")\n        }\n    default:\n        fmt.Println(\"잘못된 연산자\")\n    }\n}\n```\n\n## 연습 문제\n\n1. 점수를 입력받아 학점을 출력하는 프로그램을 작성하세요\n2. switch 문을 사용해 요일을 판별하는 프로그램을 작성하세요\n3. 온도에 따라 날씨 상태를 출력하는 프로그램을 작성하세요\n\n## 핵심 요약\n\n- `if`: 조건이 참일 때 실행\n- `else`: 조건이 거짓일 때 실행\n- `else if`: 여러 조건 검사\n- `if 짧은문장; 조건`: Go 특유의 문법\n- `switch-case`: 값에 따른 분기\n- switch는 자동으로 break (fallthrough 필요시 명시)\n- 조건식 switch: switch 뒤에 변수 생략 가능\n- 타입 switch: 타입에 따른 분기"
    },
    {
      "chapterId": 5,
      "title": "5단원: 반복문",
      "content": "# 5단원: 반복문\n\n## for 문 (기본)\n\nGo는 반복문으로 for만 제공합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 기본 for 문\n    for i := 0; i < 5; i++ {\n        fmt.Printf(\"반복 %d\\n\", i)\n    }\n    \n    // 거꾸로 반복\n    for i := 5; i > 0; i-- {\n        fmt.Printf(\"카운트다운: %d\\n\", i)\n    }\n    \n    // 2씩 증가\n    for i := 0; i < 10; i += 2 {\n        fmt.Printf(\"짝수: %d\\n\", i)\n    }\n}\n```\n\n## while 스타일 for\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 초기식과 후처리 생략\n    count := 0\n    for count < 5 {\n        fmt.Printf(\"count: %d\\n\", count)\n        count++\n    }\n}\n```\n\n## 무한 루프\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    count := 0\n    \n    // 조건 없는 for (무한 루프)\n    for {\n        fmt.Printf(\"count: %d\\n\", count)\n        count++\n        \n        if count >= 3 {\n            break\n        }\n    }\n}\n```\n\n## range를 사용한 반복\n\n### 배열/슬라이스 순회\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fruits := []string{\"사과\", \"바나나\", \"오렌지\"}\n    \n    // 인덱스와 값 모두 사용\n    for i, fruit := range fruits {\n        fmt.Printf(\"%d: %s\\n\", i, fruit)\n    }\n    \n    // 인덱스만 사용\n    for i := range fruits {\n        fmt.Printf(\"%d번째\\n\", i)\n    }\n    \n    // 값만 사용 (인덱스 무시)\n    for _, fruit := range fruits {\n        fmt.Println(fruit)\n    }\n}\n```\n\n### 맵 순회\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\":   90,\n        \"Bob\":     85,\n        \"Charlie\": 95,\n    }\n    \n    // 키와 값 순회\n    for name, score := range scores {\n        fmt.Printf(\"%s: %d점\\n\", name, score)\n    }\n    \n    // 키만 순회\n    for name := range scores {\n        fmt.Println(name)\n    }\n}\n```\n\n### 문자열 순회\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    text := \"Hello\"\n    \n    // rune (유니코드 코드 포인트) 순회\n    for i, char := range text {\n        fmt.Printf(\"%d: %c (코드: %d)\\n\", i, char, char)\n    }\n}\n```\n\n## break 문\n\n반복문을 즉시 종료합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 특정 값 찾으면 종료\n    for i := 0; i < 10; i++ {\n        if i == 5 {\n            fmt.Println(\"5를 찾았습니다!\")\n            break\n        }\n        fmt.Println(i)\n    }\n    \n    fmt.Println(\"반복문 종료\")\n}\n```\n\n## continue 문\n\n현재 반복을 건너뛰고 다음 반복으로 넘어갑니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 홀수만 출력\n    for i := 0; i < 10; i++ {\n        if i%2 == 0 {\n            continue\n        }\n        fmt.Printf(\"홀수: %d\\n\", i)\n    }\n    \n    // 3의 배수 건너뛰기\n    for i := 1; i <= 10; i++ {\n        if i%3 == 0 {\n            continue\n        }\n        fmt.Println(i)\n    }\n}\n```\n\n## 중첩 반복문\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 구구단\n    for i := 2; i <= 9; i++ {\n        fmt.Printf(\"\\n%d단:\\n\", i)\n        for j := 1; j <= 9; j++ {\n            fmt.Printf(\"%d × %d = %d\\n\", i, j, i*j)\n        }\n    }\n}\n```\n\n## 레이블을 사용한 break/continue\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\nOuter:\n    for i := 0; i < 3; i++ {\n        for j := 0; j < 3; j++ {\n            if i == 1 && j == 1 {\n                break Outer // 외부 루프까지 종료\n            }\n            fmt.Printf(\"i: %d, j: %d\\n\", i, j)\n        }\n    }\n    \n    fmt.Println(\"\\n---\\n\")\n    \n    // continue with label\nLoop:\n    for i := 0; i < 3; i++ {\n        for j := 0; j < 3; j++ {\n            if j == 1 {\n                continue Loop // 외부 루프의 다음 반복으로\n            }\n            fmt.Printf(\"i: %d, j: %d\\n\", i, j)\n        }\n    }\n}\n```\n\n## 실전 예제\n\n### 팩토리얼 계산\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    n := 5\n    factorial := 1\n    \n    for i := 1; i <= n; i++ {\n        factorial *= i\n    }\n    \n    fmt.Printf(\"%d! = %d\\n\", n, factorial)  // 5! = 120\n}\n```\n\n### 피보나치 수열\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    n := 10\n    fib := []int{0, 1}\n    \n    for i := 2; i < n; i++ {\n        next := fib[i-1] + fib[i-2]\n        fib = append(fib, next)\n    }\n    \n    fmt.Println(\"피보나치 수열:\", fib)\n}\n```\n\n### 소수 판별\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    number := 17\n    isPrime := true\n    \n    if number < 2 {\n        isPrime = false\n    } else {\n        for i := 2; i <= number/2; i++ {\n            if number%i == 0 {\n                isPrime = false\n                break\n            }\n        }\n    }\n    \n    if isPrime {\n        fmt.Printf(\"%d은(는) 소수입니다\\n\", number)\n    } else {\n        fmt.Printf(\"%d은(는) 소수가 아닙니다\\n\", number)\n    }\n}\n```\n\n### 배열 합계와 평균\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{10, 20, 30, 40, 50}\n    sum := 0\n    \n    for _, num := range numbers {\n        sum += num\n    }\n    \n    average := float64(sum) / float64(len(numbers))\n    \n    fmt.Printf(\"합계: %d\\n\", sum)\n    fmt.Printf(\"평균: %.2f\\n\", average)\n}\n```\n\n### 문자열 역순 출력\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    text := \"Hello\"\n    \n    // 역순 출력\n    for i := len(text) - 1; i >= 0; i-- {\n        fmt.Printf(\"%c\", text[i])\n    }\n    fmt.Println()\n    \n    // rune 슬라이스로 변환 후 역순\n    runes := []rune(text)\n    for i := len(runes) - 1; i >= 0; i-- {\n        fmt.Printf(\"%c\", runes[i])\n    }\n    fmt.Println()\n}\n```\n\n### 구구단 출력\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for dan := 2; dan <= 9; dan++ {\n        fmt.Printf(\"\\n=== %d단 ===\\n\", dan)\n        for num := 1; num <= 9; num++ {\n            fmt.Printf(\"%d × %d = %d\\n\", dan, num, dan*num)\n        }\n    }\n}\n```\n\n## 연습 문제\n\n1. 1부터 100까지의 합을 구하는 프로그램을 작성하세요\n2. 배열에서 최댓값과 최솟값을 찾으세요\n3. 중첩 반복문으로 별 피라미드를 출력하세요\n\n## 핵심 요약\n\n- `for`: Go의 유일한 반복문\n- `for 초기식; 조건; 후처리`: C 스타일\n- `for 조건`: while 스타일\n- `for`: 무한 루프\n- `range`: 컬렉션 순회\n- `break`: 반복문 종료\n- `continue`: 현재 반복 건너뛰기\n- 레이블: 중첩 반복문 제어\n- `_`: 사용하지 않는 값 무시"
    },
    {
      "chapterId": 6,
      "title": "6단원: 함수",
      "content": "# 6단원: 함수\n\n## 함수 정의\n\n함수는 재사용 가능한 코드 블록입니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    greet()\n    greet()\n}\n\n// 반환값이 없는 함수\nfunc greet() {\n    fmt.Println(\"안녕하세요!\")\n}\n```\n\n## 매개변수와 반환값\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    message := createGreeting(\"Alice\")\n    fmt.Println(message)\n    \n    result := add(5, 3)\n    fmt.Printf(\"5 + 3 = %d\\n\", result)\n}\n\n// 매개변수를 받는 함수\nfunc createGreeting(name string) string {\n    return \"안녕하세요, \" + name + \"님!\"\n}\n\n// 여러 매개변수\nfunc add(a int, b int) int {\n    return a + b\n}\n\n// 같은 타입 매개변수는 타입 한 번만 작성\nfunc multiply(a, b int) int {\n    return a * b\n}\n```\n\n## 여러 반환값\n\nGo는 여러 값을 반환할 수 있습니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    quotient, remainder := divide(10, 3)\n    fmt.Printf(\"몫: %d, 나머지: %d\\n\", quotient, remainder)\n    \n    // 하나의 반환값만 사용\n    q, _ := divide(10, 3)\n    fmt.Printf(\"몫: %d\\n\", q)\n}\n\nfunc divide(a, b int) (int, int) {\n    quotient := a / b\n    remainder := a % b\n    return quotient, remainder\n}\n```\n\n## 이름 있는 반환값\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    q, r := divideWithNames(10, 3)\n    fmt.Printf(\"몫: %d, 나머지: %d\\n\", q, r)\n}\n\nfunc divideWithNames(a, b int) (quotient int, remainder int) {\n    quotient = a / b\n    remainder = a % b\n    return // naked return\n}\n```\n\n## 가변 매개변수 (Variadic Parameters)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(sum(1, 2, 3))           // 6\n    fmt.Println(sum(1, 2, 3, 4, 5))     // 15\n    \n    numbers := []int{10, 20, 30}\n    fmt.Println(sum(numbers...))         // 60 (슬라이스 확장)\n}\n\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n```\n\n## 함수를 값으로 사용\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 함수를 변수에 할당\n    add := func(a, b int) int {\n        return a + b\n    }\n    \n    result := add(5, 3)\n    fmt.Println(result)  // 8\n    \n    // 함수를 매개변수로 전달\n    operate(10, 5, add)\n    operate(10, 5, func(a, b int) int {\n        return a * b\n    })\n}\n\nfunc operate(a, b int, op func(int, int) int) {\n    result := op(a, b)\n    fmt.Printf(\"결과: %d\\n\", result)\n}\n```\n\n## 클로저 (Closure)\n\n함수가 외부 변수를 캡처합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    counter := makeCounter()\n    \n    fmt.Println(counter())  // 1\n    fmt.Println(counter())  // 2\n    fmt.Println(counter())  // 3\n}\n\nfunc makeCounter() func() int {\n    count := 0\n    return func() int {\n        count++\n        return count\n    }\n}\n```\n\n## 재귀 함수 (Recursive Function)\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"5! = %d\\n\", factorial(5))        // 120\n    fmt.Printf(\"fib(10) = %d\\n\", fibonacci(10))  // 55\n}\n\n// 팩토리얼\nfunc factorial(n int) int {\n    if n <= 1 {\n        return 1\n    }\n    return n * factorial(n-1)\n}\n\n// 피보나치 수열\nfunc fibonacci(n int) int {\n    if n <= 1 {\n        return n\n    }\n    return fibonacci(n-1) + fibonacci(n-2)\n}\n```\n\n## defer 문\n\n함수가 종료되기 직전에 실행됩니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"시작\")\n    defer fmt.Println(\"마지막 (defer)\")\n    fmt.Println(\"중간\")\n    // 출력 순서:\n    // 시작\n    // 중간\n    // 마지막 (defer)\n}\n```\n\n### defer 스택\n\n여러 defer는 LIFO(후입선출) 순서로 실행됩니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    defer fmt.Println(\"1\")\n    defer fmt.Println(\"2\")\n    defer fmt.Println(\"3\")\n    fmt.Println(\"시작\")\n    \n    // 출력 순서:\n    // 시작\n    // 3\n    // 2\n    // 1\n}\n```\n\n## 에러 처리\n\nGo는 error 타입으로 에러를 반환합니다.\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    result, err := divide(10, 0)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    } else {\n        fmt.Printf(\"결과: %d\\n\", result)\n    }\n}\n\nfunc divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"0으로 나눌 수 없습니다\")\n    }\n    return a / b, nil\n}\n```\n\n## 실전 예제\n\n### 계산기 함수\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    result, _ := calculate(10, 5, \"+\")\n    fmt.Println(result)\n    \n    result, err := calculate(10, 0, \"/\")\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    }\n}\n\nfunc calculate(a, b int, op string) (int, error) {\n    switch op {\n    case \"+\":\n        return a + b, nil\n    case \"-\":\n        return a - b, nil\n    case \"*\":\n        return a * b, nil\n    case \"/\":\n        if b == 0 {\n            return 0, errors.New(\"0으로 나눌 수 없습니다\")\n        }\n        return a / b, nil\n    default:\n        return 0, errors.New(\"잘못된 연산자\")\n    }\n}\n```\n\n### 슬라이스 처리 함수\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    \n    fmt.Printf(\"합계: %d\\n\", sum(numbers))\n    fmt.Printf(\"평균: %.2f\\n\", average(numbers))\n    fmt.Printf(\"최댓값: %d\\n\", max(numbers))\n    fmt.Printf(\"최솟값: %d\\n\", min(numbers))\n}\n\nfunc sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n\nfunc average(numbers []int) float64 {\n    return float64(sum(numbers)) / float64(len(numbers))\n}\n\nfunc max(numbers []int) int {\n    maxVal := numbers[0]\n    for _, num := range numbers {\n        if num > maxVal {\n            maxVal = num\n        }\n    }\n    return maxVal\n}\n\nfunc min(numbers []int) int {\n    minVal := numbers[0]\n    for _, num := range numbers {\n        if num < minVal {\n            minVal = num\n        }\n    }\n    return minVal\n}\n```\n\n### 고차 함수 활용\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    \n    // 각 요소에 함수 적용\n    doubled := mapInt(numbers, func(n int) int {\n        return n * 2\n    })\n    fmt.Println(\"2배:\", doubled)\n    \n    // 필터링\n    evens := filterInt(numbers, func(n int) bool {\n        return n%2 == 0\n    })\n    fmt.Println(\"짝수:\", evens)\n}\n\nfunc mapInt(numbers []int, f func(int) int) []int {\n    result := make([]int, len(numbers))\n    for i, num := range numbers {\n        result[i] = f(num)\n    }\n    return result\n}\n\nfunc filterInt(numbers []int, f func(int) bool) []int {\n    result := []int{}\n    for _, num := range numbers {\n        if f(num) {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n```\n\n## 연습 문제\n\n1. 두 숫자 중 큰 값을 반환하는 함수를 작성하세요\n2. 문자열을 역순으로 뒤집는 함수를 작성하세요\n3. 재귀 함수로 1부터 n까지의 합을 구하세요\n\n## 핵심 요약\n\n- `func 이름(매개변수) 반환타입`: 함수 정의\n- 여러 반환값 가능\n- 이름 있는 반환값과 naked return\n- `...`: 가변 매개변수\n- 함수는 일급 객체 (변수 할당, 매개변수 전달)\n- 클로저: 외부 변수 캡처\n- 재귀: 함수가 자기 자신 호출\n- `defer`: 함수 종료 직전 실행\n- `error`: 에러 처리"
    },
    {
      "chapterId": 7,
      "title": "7단원: 리스트·배열·컬렉션",
      "content": "# 7단원: 리스트·배열·컬렉션\n\n## 배열 (Array)\n\n배열은 고정된 크기의 같은 타입 요소들의 집합입니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 배열 선언\n    var arr [5]int\n    fmt.Println(arr)  // [0 0 0 0 0]\n    \n    // 초기값과 함께 선언\n    numbers := [5]int{1, 2, 3, 4, 5}\n    fmt.Println(numbers)\n    \n    // 크기 자동 추론\n    fruits := [...]string{\"사과\", \"바나나\", \"오렌지\"}\n    fmt.Println(fruits)\n    \n    // 특정 인덱스 초기화\n    arr2 := [5]int{0: 10, 2: 20, 4: 30}\n    fmt.Println(arr2)  // [10 0 20 0 30]\n}\n```\n\n## 배열 접근과 수정\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := [5]int{10, 20, 30, 40, 50}\n    \n    // 인덱스로 접근\n    fmt.Println(numbers[0])  // 10\n    fmt.Println(numbers[2])  // 30\n    \n    // 값 수정\n    numbers[0] = 100\n    fmt.Println(numbers)  // [100 20 30 40 50]\n    \n    // 배열 길이\n    fmt.Println(len(numbers))  // 5\n}\n```\n\n## 슬라이스 (Slice)\n\n슬라이스는 동적 크기의 배열입니다. Go에서 더 많이 사용됩니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 슬라이스 선언\n    var s []int\n    fmt.Println(s, len(s), cap(s))  // [] 0 0\n    \n    // 리터럴로 생성\n    fruits := []string{\"사과\", \"바나나\", \"오렌지\"}\n    fmt.Println(fruits)\n    \n    // make로 생성\n    numbers := make([]int, 5)      // 길이 5\n    fmt.Println(numbers)            // [0 0 0 0 0]\n    \n    numbers2 := make([]int, 3, 5)  // 길이 3, 용량 5\n    fmt.Println(numbers2, len(numbers2), cap(numbers2))\n}\n```\n\n## 슬라이스 추가와 삭제\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fruits := []string{\"사과\", \"바나나\"}\n    \n    // 요소 추가\n    fruits = append(fruits, \"오렌지\")\n    fmt.Println(fruits)  // [사과 바나나 오렌지]\n    \n    // 여러 요소 추가\n    fruits = append(fruits, \"포도\", \"딸기\")\n    fmt.Println(fruits)\n    \n    // 다른 슬라이스 추가\n    moreFruits := []string{\"수박\", \"참외\"}\n    fruits = append(fruits, moreFruits...)\n    fmt.Println(fruits)\n}\n```\n\n## 슬라이싱\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    \n    // [시작:끝] - 끝은 포함 안 됨\n    fmt.Println(numbers[2:5])   // [2 3 4]\n    fmt.Println(numbers[:3])    // [0 1 2]\n    fmt.Println(numbers[5:])    // [5 6 7 8 9]\n    fmt.Println(numbers[:])     // [0 1 2 3 4 5 6 7 8 9]\n    \n    // [시작:끝:용량]\n    slice := numbers[2:5:7]\n    fmt.Println(slice, len(slice), cap(slice))  // [2 3 4] 3 5\n}\n```\n\n## 슬라이스 복사\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    src := []int{1, 2, 3, 4, 5}\n    \n    // copy 함수 사용\n    dst := make([]int, len(src))\n    copy(dst, src)\n    \n    dst[0] = 100\n    fmt.Println(\"원본:\", src)  // [1 2 3 4 5]\n    fmt.Println(\"복사:\", dst)  // [100 2 3 4 5]\n}\n```\n\n## 2차원 슬라이스\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 2차원 슬라이스 생성\n    matrix := [][]int{\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9},\n    }\n    \n    // 접근\n    fmt.Println(matrix[0][0])  // 1\n    fmt.Println(matrix[1][2])  // 6\n    \n    // 순회\n    for i, row := range matrix {\n        for j, val := range row {\n            fmt.Printf(\"[%d][%d] = %d\\n\", i, j, val)\n        }\n    }\n}\n```\n\n## 슬라이스 반복\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fruits := []string{\"사과\", \"바나나\", \"오렌지\"}\n    \n    // 인덱스와 값\n    for i, fruit := range fruits {\n        fmt.Printf(\"%d: %s\\n\", i, fruit)\n    }\n    \n    // 인덱스만\n    for i := range fruits {\n        fmt.Printf(\"%d번째\\n\", i)\n    }\n    \n    // 값만\n    for _, fruit := range fruits {\n        fmt.Println(fruit)\n    }\n}\n```\n\n## 슬라이스 필터링과 변환\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    \n    // 짝수만 필터링\n    evens := []int{}\n    for _, num := range numbers {\n        if num%2 == 0 {\n            evens = append(evens, num)\n        }\n    }\n    fmt.Println(\"짝수:\", evens)\n    \n    // 각 요소 2배\n    doubled := []int{}\n    for _, num := range numbers {\n        doubled = append(doubled, num*2)\n    }\n    fmt.Println(\"2배:\", doubled)\n}\n```\n\n## 실전 예제\n\n### 최댓값, 최솟값 찾기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{5, 2, 8, 1, 9, 3}\n    \n    max := numbers[0]\n    min := numbers[0]\n    \n    for _, num := range numbers {\n        if num > max {\n            max = num\n        }\n        if num < min {\n            min = num\n        }\n    }\n    \n    fmt.Printf(\"최댓값: %d\\n\", max)\n    fmt.Printf(\"최솟값: %d\\n\", min)\n}\n```\n\n### 중복 제거\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 2, 3, 3, 3, 4, 5, 5}\n    \n    // map을 사용한 중복 제거\n    seen := make(map[int]bool)\n    unique := []int{}\n    \n    for _, num := range numbers {\n        if !seen[num] {\n            seen[num] = true\n            unique = append(unique, num)\n        }\n    }\n    \n    fmt.Println(unique)  // [1 2 3 4 5]\n}\n```\n\n### 슬라이스 뒤집기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    \n    // 새 슬라이스 생성\n    reversed := make([]int, len(numbers))\n    for i, num := range numbers {\n        reversed[len(numbers)-1-i] = num\n    }\n    \n    fmt.Println(\"원본:\", numbers)\n    fmt.Println(\"뒤집기:\", reversed)\n    \n    // 제자리 뒤집기\n    for i, j := 0, len(numbers)-1; i < j; i, j = i+1, j-1 {\n        numbers[i], numbers[j] = numbers[j], numbers[i]\n    }\n    fmt.Println(\"제자리 뒤집기:\", numbers)\n}\n```\n\n### 슬라이스 정렬\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    numbers := []int{5, 2, 8, 1, 9, 3}\n    \n    // 오름차순 정렬\n    sort.Ints(numbers)\n    fmt.Println(\"오름차순:\", numbers)\n    \n    // 내림차순 정렬\n    sort.Sort(sort.Reverse(sort.IntSlice(numbers)))\n    fmt.Println(\"내림차순:\", numbers)\n    \n    // 문자열 정렬\n    fruits := []string{\"banana\", \"apple\", \"orange\"}\n    sort.Strings(fruits)\n    fmt.Println(\"정렬된 과일:\", fruits)\n}\n```\n\n### 슬라이스 합치기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    slice1 := []int{1, 2, 3}\n    slice2 := []int{4, 5, 6}\n    \n    // append 사용\n    combined := append(slice1, slice2...)\n    fmt.Println(combined)  // [1 2 3 4 5 6]\n    \n    // copy 사용\n    combined2 := make([]int, len(slice1)+len(slice2))\n    copy(combined2, slice1)\n    copy(combined2[len(slice1):], slice2)\n    fmt.Println(combined2)  // [1 2 3 4 5 6]\n}\n```\n\n## 연습 문제\n\n1. 슬라이스의 평균을 구하는 함수를 작성하세요\n2. 슬라이스에서 특정 값을 찾아 인덱스를 반환하세요\n3. 두 슬라이스를 합쳐서 중복을 제거한 새 슬라이스를 만드세요\n\n## 핵심 요약\n\n- `[n]T`: 배열 (고정 크기)\n- `[]T`: 슬라이스 (동적 크기)\n- `make([]T, len, cap)`: 슬라이스 생성\n- `append()`: 요소 추가\n- `copy()`: 슬라이스 복사\n- `[시작:끝]`: 슬라이싱\n- `len()`: 길이\n- `cap()`: 용량\n- `range`: 반복 순회\n- 배열은 값 타입, 슬라이스는 참조 타입"
    },
    {
      "chapterId": 8,
      "title": "8단원: 딕셔너리·맵·세트",
      "content": "# 8단원: 딕셔너리·맵·세트\n\n## 맵 (Map) 기본\n\n맵은 키-값 쌍으로 데이터를 저장합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 맵 선언 (nil)\n    var m map[string]int\n    fmt.Println(m)  // map[]\n    \n    // make로 생성\n    ages := make(map[string]int)\n    ages[\"Alice\"] = 25\n    ages[\"Bob\"] = 30\n    fmt.Println(ages)\n    \n    // 리터럴로 생성\n    scores := map[string]int{\n        \"math\":    90,\n        \"english\": 85,\n        \"science\": 95,\n    }\n    fmt.Println(scores)\n}\n```\n\n## 맵 접근과 수정\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\":   90,\n        \"Bob\":     85,\n        \"Charlie\": 95,\n    }\n    \n    // 값 가져오기\n    fmt.Println(scores[\"Alice\"])    // 90\n    fmt.Println(scores[\"Unknown\"])  // 0 (제로 값)\n    \n    // 값 존재 확인\n    value, exists := scores[\"Alice\"]\n    if exists {\n        fmt.Printf(\"Alice의 점수: %d\\n\", value)\n    }\n    \n    // 값 추가/수정\n    scores[\"David\"] = 88\n    scores[\"Alice\"] = 92\n    \n    // 삭제\n    delete(scores, \"Bob\")\n    \n    fmt.Println(scores)\n}\n```\n\n## 맵 순회\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\":   90,\n        \"Bob\":     85,\n        \"Charlie\": 95,\n    }\n    \n    // 키와 값 순회\n    for name, score := range scores {\n        fmt.Printf(\"%s: %d점\\n\", name, score)\n    }\n    \n    // 키만 순회\n    for name := range scores {\n        fmt.Println(name)\n    }\n    \n    // 값만 순회 (키 무시)\n    for _, score := range scores {\n        fmt.Println(score)\n    }\n}\n```\n\n## 맵 길이\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\": 90,\n        \"Bob\":   85,\n    }\n    \n    fmt.Printf(\"맵 크기: %d\\n\", len(scores))\n    \n    // 빈 맵 확인\n    if len(scores) == 0 {\n        fmt.Println(\"비어있음\")\n    } else {\n        fmt.Println(\"요소 있음\")\n    }\n}\n```\n\n## 중첩 맵\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 중첩 맵\n    studentScores := map[string]map[string]int{\n        \"Alice\": {\n            \"math\":    90,\n            \"english\": 85,\n        },\n        \"Bob\": {\n            \"math\":    85,\n            \"english\": 90,\n        },\n    }\n    \n    // 접근\n    fmt.Println(studentScores[\"Alice\"][\"math\"])  // 90\n    \n    // 새 학생 추가\n    studentScores[\"Charlie\"] = map[string]int{\n        \"math\":    95,\n        \"english\": 88,\n    }\n    \n    // 순회\n    for name, scores := range studentScores {\n        fmt.Printf(\"%s:\\n\", name)\n        for subject, score := range scores {\n            fmt.Printf(\"  %s: %d\\n\", subject, score)\n        }\n    }\n}\n```\n\n## 맵을 사용한 집합 (Set)\n\nGo에는 내장 Set이 없지만 맵으로 구현할 수 있습니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Set 만들기 (map[T]bool)\n    set := make(map[int]bool)\n    \n    // 요소 추가\n    set[1] = true\n    set[2] = true\n    set[3] = true\n    set[2] = true  // 중복은 무시됨\n    \n    fmt.Println(\"Set:\", set)\n    \n    // 포함 확인\n    if set[2] {\n        fmt.Println(\"2가 있습니다\")\n    }\n    \n    // 삭제\n    delete(set, 2)\n    \n    // 요소 순회\n    for num := range set {\n        fmt.Println(num)\n    }\n}\n```\n\n## 집합 연산\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    setA := map[int]bool{1: true, 2: true, 3: true, 4: true}\n    setB := map[int]bool{3: true, 4: true, 5: true, 6: true}\n    \n    // 합집합\n    union := make(map[int]bool)\n    for k := range setA {\n        union[k] = true\n    }\n    for k := range setB {\n        union[k] = true\n    }\n    fmt.Println(\"합집합:\", union)\n    \n    // 교집합\n    intersection := make(map[int]bool)\n    for k := range setA {\n        if setB[k] {\n            intersection[k] = true\n        }\n    }\n    fmt.Println(\"교집합:\", intersection)\n    \n    // 차집합\n    difference := make(map[int]bool)\n    for k := range setA {\n        if !setB[k] {\n            difference[k] = true\n        }\n    }\n    fmt.Println(\"차집합:\", difference)\n}\n```\n\n## 실전 예제\n\n### 단어 빈도수 세기\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    text := \"apple banana apple cherry banana apple\"\n    words := strings.Split(text, \" \")\n    \n    wordCount := make(map[string]int)\n    \n    for _, word := range words {\n        wordCount[word]++\n    }\n    \n    fmt.Println(\"단어 빈도:\")\n    for word, count := range wordCount {\n        fmt.Printf(\"%s: %d\\n\", word, count)\n    }\n}\n```\n\n### 전화번호부\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    phonebook := map[string]string{\n        \"Alice\":   \"010-1234-5678\",\n        \"Bob\":     \"010-2345-6789\",\n        \"Charlie\": \"010-3456-7890\",\n    }\n    \n    // 검색\n    name := \"Alice\"\n    if phone, exists := phonebook[name]; exists {\n        fmt.Printf(\"%s: %s\\n\", name, phone)\n    } else {\n        fmt.Printf(\"%s를 찾을 수 없습니다\\n\", name)\n    }\n    \n    // 추가\n    phonebook[\"David\"] = \"010-4567-8901\"\n    \n    // 전체 출력\n    fmt.Println(\"\\n전화번호부:\")\n    for name, phone := range phonebook {\n        fmt.Printf(\"%s: %s\\n\", name, phone)\n    }\n}\n```\n\n### 학생 성적 관리\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    students := map[string]map[string]int{\n        \"Alice\": {\n            \"math\":    90,\n            \"english\": 85,\n            \"science\": 95,\n        },\n        \"Bob\": {\n            \"math\":    85,\n            \"english\": 90,\n            \"science\": 80,\n        },\n    }\n    \n    // 각 학생의 평균 계산\n    for name, scores := range students {\n        total := 0\n        for _, score := range scores {\n            total += score\n        }\n        average := float64(total) / float64(len(scores))\n        fmt.Printf(\"%s 평균: %.1f점\\n\", name, average)\n    }\n}\n```\n\n### 중복 문자 찾기\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    text := \"programming\"\n    charCount := make(map[rune]int)\n    \n    // 문자 빈도 세기\n    for _, char := range text {\n        charCount[char]++\n    }\n    \n    // 중복 문자 출력\n    fmt.Println(\"중복 문자:\")\n    for char, count := range charCount {\n        if count > 1 {\n            fmt.Printf(\"%c: %d번\\n\", char, count)\n        }\n    }\n}\n```\n\n### 그룹핑\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    \n    // 짝수/홀수로 그룹핑\n    grouped := make(map[string][]int)\n    \n    for _, num := range numbers {\n        if num%2 == 0 {\n            grouped[\"even\"] = append(grouped[\"even\"], num)\n        } else {\n            grouped[\"odd\"] = append(grouped[\"odd\"], num)\n        }\n    }\n    \n    fmt.Println(\"짝수:\", grouped[\"even\"])\n    fmt.Println(\"홀수:\", grouped[\"odd\"])\n}\n```\n\n## 맵 주의사항\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 1. nil 맵에 값 할당 불가\n    var m1 map[string]int\n    // m1[\"key\"] = 1  // 패닉 발생!\n    \n    // make로 초기화 필요\n    m1 = make(map[string]int)\n    m1[\"key\"] = 1\n    \n    // 2. 맵은 순서 보장 안 됨\n    m2 := map[string]int{\n        \"a\": 1,\n        \"b\": 2,\n        \"c\": 3,\n    }\n    // 순회할 때마다 순서가 다를 수 있음\n    for k, v := range m2 {\n        fmt.Println(k, v)\n    }\n    \n    // 3. 맵은 참조 타입\n    m3 := map[string]int{\"a\": 1}\n    m4 := m3\n    m4[\"a\"] = 2\n    fmt.Println(m3[\"a\"])  // 2 (같이 변경됨)\n}\n```\n\n## 연습 문제\n\n1. 맵을 사용해 학생 정보(이름, 나이, 학년)를 저장하고 출력하세요\n2. 두 개의 슬라이스에서 공통 요소를 찾아 맵으로 반환하세요\n3. 문자열에서 각 문자의 등장 횟수를 맵으로 만드세요\n\n## 핵심 요약\n\n- `map[K]V`: 키-값 쌍\n- `make(map[K]V)`: 맵 생성\n- `m[key]`: 값 접근\n- `m[key] = value`: 값 설정\n- `delete(m, key)`: 값 삭제\n- `value, ok := m[key]`: 존재 확인\n- `len(m)`: 맵 크기\n- `range`: 순회\n- 맵은 참조 타입\n- 순서 보장 안 됨\n- Set은 `map[T]bool`로 구현"
    },
    {
      "chapterId": 9,
      "title": "9단원: 입출력",
      "content": "# 9단원: 입출력\n\n## 콘솔 출력\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 기본 출력\n    fmt.Println(\"Hello, Go!\")\n    \n    // 여러 값 출력\n    name := \"Alice\"\n    age := 25\n    fmt.Println(\"이름:\", name, \"나이:\", age)\n    \n    // 형식 지정 출력\n    fmt.Printf(\"이름: %s, 나이: %d\\n\", name, age)\n    \n    // 문자열 생성\n    message := fmt.Sprintf(\"안녕하세요, %s님!\", name)\n    fmt.Println(message)\n}\n```\n\n## 콘솔 입력\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string\n    var age int\n    \n    // 입력 받기\n    fmt.Print(\"이름을 입력하세요: \")\n    fmt.Scan(&name)\n    \n    fmt.Print(\"나이를 입력하세요: \")\n    fmt.Scan(&age)\n    \n    fmt.Printf(\"안녕하세요, %s님! %d세이시군요.\\n\", name, age)\n}\n```\n\n## Scanln과 Scanf\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var name string\n    var age int\n    \n    // Scanln: 한 줄 입력\n    fmt.Print(\"이름을 입력하세요: \")\n    fmt.Scanln(&name)\n    \n    // Scanf: 형식 지정 입력\n    fmt.Print(\"나이를 입력하세요: \")\n    fmt.Scanf(\"%d\", &age)\n    \n    fmt.Printf(\"%s, %d세\\n\", name, age)\n}\n```\n\n## 버퍼를 사용한 입력\n\n```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    reader := bufio.NewReader(os.Stdin)\n    \n    fmt.Print(\"문장을 입력하세요: \")\n    text, _ := reader.ReadString('\\n')\n    \n    fmt.Println(\"입력한 내용:\", text)\n}\n```\n\n## 파일 읽기\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 전체 파일 읽기\n    data, err := os.ReadFile(\"data.txt\")\n    if err != nil {\n        fmt.Println(\"파일 읽기 오류:\", err)\n        return\n    }\n    \n    fmt.Println(\"파일 내용:\")\n    fmt.Println(string(data))\n}\n```\n\n## 파일 쓰기\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    content := []byte(\"Hello, Go!\\n새로운 줄\")\n    \n    // 파일에 쓰기 (덮어쓰기)\n    err := os.WriteFile(\"output.txt\", content, 0644)\n    if err != nil {\n        fmt.Println(\"파일 쓰기 오류:\", err)\n        return\n    }\n    \n    fmt.Println(\"파일 쓰기 완료\")\n}\n```\n\n## 파일 한 줄씩 읽기\n\n```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.Open(\"data.txt\")\n    if err != nil {\n        fmt.Println(\"파일 열기 오류:\", err)\n        return\n    }\n    defer file.Close()\n    \n    scanner := bufio.NewScanner(file)\n    lineNum := 1\n    \n    for scanner.Scan() {\n        line := scanner.Text()\n        fmt.Printf(\"%d: %s\\n\", lineNum, line)\n        lineNum++\n    }\n    \n    if err := scanner.Err(); err != nil {\n        fmt.Println(\"읽기 오류:\", err)\n    }\n}\n```\n\n## 파일에 추가하기\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.OpenFile(\n        \"output.txt\",\n        os.O_APPEND|os.O_CREATE|os.O_WRONLY,\n        0644,\n    )\n    if err != nil {\n        fmt.Println(\"파일 열기 오류:\", err)\n        return\n    }\n    defer file.Close()\n    \n    _, err = file.WriteString(\"추가된 내용\\n\")\n    if err != nil {\n        fmt.Println(\"쓰기 오류:\", err)\n        return\n    }\n    \n    fmt.Println(\"파일에 내용 추가 완료\")\n}\n```\n\n## 파일 존재 확인\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    filename := \"test.txt\"\n    \n    // 파일 존재 확인\n    if _, err := os.Stat(filename); os.IsNotExist(err) {\n        fmt.Println(\"파일이 존재하지 않습니다\")\n    } else {\n        fmt.Println(\"파일이 존재합니다\")\n    }\n}\n```\n\n## 파일 삭제\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    err := os.Remove(\"test.txt\")\n    if err != nil {\n        fmt.Println(\"파일 삭제 오류:\", err)\n        return\n    }\n    \n    fmt.Println(\"파일 삭제 완료\")\n}\n```\n\n## JSON 파일 읽기/쓰기\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Person struct {\n    Name   string   `json:\"name\"`\n    Age    int      `json:\"age\"`\n    Skills []string `json:\"skills\"`\n}\n\nfunc main() {\n    // JSON 쓰기\n    person := Person{\n        Name:   \"Alice\",\n        Age:    25,\n        Skills: []string{\"Go\", \"Python\", \"JavaScript\"},\n    }\n    \n    data, _ := json.MarshalIndent(person, \"\", \"  \")\n    os.WriteFile(\"person.json\", data, 0644)\n    \n    // JSON 읽기\n    fileData, _ := os.ReadFile(\"person.json\")\n    \n    var loadedPerson Person\n    json.Unmarshal(fileData, &loadedPerson)\n    \n    fmt.Printf(\"이름: %s\\n\", loadedPerson.Name)\n    fmt.Printf(\"나이: %d\\n\", loadedPerson.Age)\n    fmt.Printf(\"스킬: %v\\n\", loadedPerson.Skills)\n}\n```\n\n## CSV 파일 처리\n\n```go\npackage main\n\nimport (\n    \"encoding/csv\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // CSV 쓰기\n    file, _ := os.Create(\"data.csv\")\n    defer file.Close()\n    \n    writer := csv.NewWriter(file)\n    defer writer.Flush()\n    \n    records := [][]string{\n        {\"이름\", \"나이\", \"직업\"},\n        {\"Alice\", \"25\", \"개발자\"},\n        {\"Bob\", \"30\", \"디자이너\"},\n    }\n    \n    writer.WriteAll(records)\n    \n    // CSV 읽기\n    file2, _ := os.Open(\"data.csv\")\n    defer file2.Close()\n    \n    reader := csv.NewReader(file2)\n    rows, _ := reader.ReadAll()\n    \n    for _, row := range rows {\n        fmt.Println(row)\n    }\n}\n```\n\n## 실전 예제\n\n### 메모장 프로그램\n\n```go\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    reader := bufio.NewReader(os.Stdin)\n    filename := \"memo.txt\"\n    \n    for {\n        fmt.Println(\"\\n=== 메모장 ===\")\n        fmt.Println(\"1. 메모 읽기\")\n        fmt.Println(\"2. 메모 쓰기\")\n        fmt.Println(\"3. 종료\")\n        fmt.Print(\"선택: \")\n        \n        choice, _ := reader.ReadString('\\n')\n        \n        switch choice[:len(choice)-1] {\n        case \"1\":\n            data, err := os.ReadFile(filename)\n            if err != nil {\n                fmt.Println(\"저장된 메모가 없습니다\")\n            } else {\n                fmt.Println(\"\\n--- 저장된 메모 ---\")\n                fmt.Println(string(data))\n            }\n        case \"2\":\n            fmt.Print(\"메모 내용: \")\n            content, _ := reader.ReadString('\\n')\n            \n            file, _ := os.OpenFile(\n                filename,\n                os.O_APPEND|os.O_CREATE|os.O_WRONLY,\n                0644,\n            )\n            file.WriteString(content)\n            file.Close()\n            \n            fmt.Println(\"메모가 저장되었습니다\")\n        case \"3\":\n            fmt.Println(\"프로그램을 종료합니다\")\n            return\n        }\n    }\n}\n```\n\n### 로그 파일 작성\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\nfunc writeLog(message string) {\n    file, err := os.OpenFile(\n        \"app.log\",\n        os.O_APPEND|os.O_CREATE|os.O_WRONLY,\n        0644,\n    )\n    if err != nil {\n        fmt.Println(\"로그 파일 열기 오류:\", err)\n        return\n    }\n    defer file.Close()\n    \n    timestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n    logEntry := fmt.Sprintf(\"[%s] %s\\n\", timestamp, message)\n    \n    file.WriteString(logEntry)\n}\n\nfunc main() {\n    writeLog(\"프로그램 시작\")\n    writeLog(\"작업 수행 중...\")\n    writeLog(\"프로그램 종료\")\n    \n    fmt.Println(\"로그가 기록되었습니다\")\n}\n```\n\n## 연습 문제\n\n1. 사용자로부터 여러 줄의 텍스트를 입력받아 파일로 저장하세요\n2. 파일에서 특정 단어를 검색하는 프로그램을 작성하세요\n3. CSV 파일에서 데이터를 읽어 평균을 계산하세요\n\n## 핵심 요약\n\n- `fmt.Print`, `fmt.Println`, `fmt.Printf`: 콘솔 출력\n- `fmt.Scan`, `fmt.Scanln`, `fmt.Scanf`: 콘솔 입력\n- `os.ReadFile`: 파일 전체 읽기\n- `os.WriteFile`: 파일 쓰기\n- `os.Open`, `os.Create`: 파일 열기/생성\n- `defer file.Close()`: 파일 닫기\n- `bufio.Scanner`: 줄 단위 읽기\n- `json.Marshal`, `json.Unmarshal`: JSON 변환\n- `encoding/csv`: CSV 처리"
    },
    {
      "chapterId": 10,
      "title": "10단원: 예외처리·오류 관리",
      "content": "# 10단원: 예외처리·오류 관리\n\n## Go의 에러 처리\n\nGo는 예외(exception) 대신 error 값을 반환하는 방식을 사용합니다.\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    result, err := divide(10, 2)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    } else {\n        fmt.Printf(\"결과: %d\\n\", result)\n    }\n    \n    result, err = divide(10, 0)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    }\n}\n\nfunc divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"0으로 나눌 수 없습니다\")\n    }\n    return a / b, nil\n}\n```\n\n## 에러 생성\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    // errors.New로 생성\n    err1 := errors.New(\"간단한 에러\")\n    fmt.Println(err1)\n    \n    // fmt.Errorf로 포맷팅된 에러 생성\n    name := \"Alice\"\n    err2 := fmt.Errorf(\"%s를 찾을 수 없습니다\", name)\n    fmt.Println(err2)\n}\n```\n\n## 사용자 정의 에러\n\n```go\npackage main\n\nimport \"fmt\"\n\n// 사용자 정의 에러 타입\ntype MyError struct {\n    Code    int\n    Message string\n}\n\nfunc (e *MyError) Error() string {\n    return fmt.Sprintf(\"[에러 %d] %s\", e.Code, e.Message)\n}\n\nfunc main() {\n    err := &MyError{\n        Code:    404,\n        Message: \"리소스를 찾을 수 없습니다\",\n    }\n    \n    fmt.Println(err)\n}\n```\n\n## 에러 체크 패턴\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 표준 패턴\n    file, err := os.Open(\"data.txt\")\n    if err != nil {\n        fmt.Println(\"파일 열기 오류:\", err)\n        return\n    }\n    defer file.Close()\n    \n    // 파일 작업...\n}\n```\n\n## 에러 래핑 (Wrapping)\n\nGo 1.13부터 에러 래핑을 지원합니다.\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    err := processData()\n    if err != nil {\n        fmt.Println(\"오류 발생:\", err)\n    }\n}\n\nfunc processData() error {\n    err := readFile()\n    if err != nil {\n        return fmt.Errorf(\"데이터 처리 실패: %w\", err)\n    }\n    return nil\n}\n\nfunc readFile() error {\n    return errors.New(\"파일을 읽을 수 없습니다\")\n}\n```\n\n## 에러 언래핑 (Unwrapping)\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nvar ErrNotFound = errors.New(\"찾을 수 없음\")\n\nfunc main() {\n    err := fmt.Errorf(\"처리 실패: %w\", ErrNotFound)\n    \n    // errors.Is로 에러 확인\n    if errors.Is(err, ErrNotFound) {\n        fmt.Println(\"ErrNotFound 에러입니다\")\n    }\n    \n    // errors.Unwrap으로 원본 에러 추출\n    unwrapped := errors.Unwrap(err)\n    fmt.Println(\"원본 에러:\", unwrapped)\n}\n```\n\n## panic과 recover\n\npanic은 프로그램을 중단시키고, recover는 이를 복구합니다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"시작\")\n    \n    // panic 발생\n    // panic(\"심각한 오류!\")\n    \n    // recover로 복구\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"복구됨:\", r)\n        }\n    }()\n    \n    causePanic()\n    \n    fmt.Println(\"이 줄은 실행되지 않음\")\n}\n\nfunc causePanic() {\n    panic(\"패닉 발생!\")\n}\n```\n\n## panic 사용 예시\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"패닉 복구:\", r)\n        }\n    }()\n    \n    arr := []int{1, 2, 3}\n    fmt.Println(arr[10])  // panic: index out of range\n}\n```\n\n## 입력 검증\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    age, err := validateAge(-5)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n        return\n    }\n    \n    fmt.Printf(\"유효한 나이: %d\\n\", age)\n}\n\nfunc validateAge(age int) (int, error) {\n    if age < 0 {\n        return 0, errors.New(\"나이는 0 이상이어야 합니다\")\n    }\n    if age > 150 {\n        return 0, errors.New(\"나이가 너무 큽니다\")\n    }\n    return age, nil\n}\n```\n\n## 실전 예제\n\n### 안전한 나눗셈\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc main() {\n    result, err := safeDivide(10, 2)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    } else {\n        fmt.Printf(\"결과: %.2f\\n\", result)\n    }\n    \n    result, err = safeDivide(10, 0)\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n    }\n}\n\nfunc safeDivide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"0으로 나눌 수 없습니다\")\n    }\n    return a / b, nil\n}\n```\n\n### 파일 처리 에러\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    content, err := readFileWithError(\"data.txt\")\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n        return\n    }\n    \n    fmt.Println(\"파일 내용:\")\n    fmt.Println(string(content))\n}\n\nfunc readFileWithError(filename string) ([]byte, error) {\n    // 파일 존재 확인\n    if _, err := os.Stat(filename); os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"파일이 존재하지 않습니다: %s\", filename)\n    }\n    \n    // 파일 읽기\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, fmt.Errorf(\"파일 읽기 실패: %w\", err)\n    }\n    \n    return data, nil\n}\n```\n\n### 계좌 이체 시스템\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\ntype Account struct {\n    Owner   string\n    Balance int\n}\n\nfunc (a *Account) Withdraw(amount int) error {\n    if amount <= 0 {\n        return errors.New(\"출금액은 양수여야 합니다\")\n    }\n    \n    if amount > a.Balance {\n        return fmt.Errorf(\n            \"잔액 부족 (잔액: %d원, 출금 시도: %d원)\",\n            a.Balance,\n            amount,\n        )\n    }\n    \n    a.Balance -= amount\n    return nil\n}\n\nfunc (a *Account) Deposit(amount int) error {\n    if amount <= 0 {\n        return errors.New(\"입금액은 양수여야 합니다\")\n    }\n    \n    a.Balance += amount\n    return nil\n}\n\nfunc main() {\n    account := &Account{\n        Owner:   \"홍길동\",\n        Balance: 10000,\n    }\n    \n    // 출금\n    if err := account.Withdraw(5000); err != nil {\n        fmt.Println(\"출금 실패:\", err)\n    } else {\n        fmt.Printf(\"출금 성공. 잔액: %d원\\n\", account.Balance)\n    }\n    \n    // 초과 출금 시도\n    if err := account.Withdraw(10000); err != nil {\n        fmt.Println(\"출금 실패:\", err)\n    }\n}\n```\n\n### 재시도 로직\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    result, err := retryOperation(3, time.Second)\n    if err != nil {\n        fmt.Println(\"최종 실패:\", err)\n    } else {\n        fmt.Println(\"성공:\", result)\n    }\n}\n\nfunc retryOperation(maxRetries int, delay time.Duration) (string, error) {\n    var lastErr error\n    \n    for i := 0; i < maxRetries; i++ {\n        result, err := riskyOperation()\n        if err == nil {\n            return result, nil\n        }\n        \n        lastErr = err\n        fmt.Printf(\"시도 %d/%d 실패: %v\\n\", i+1, maxRetries, err)\n        \n        if i < maxRetries-1 {\n            time.Sleep(delay)\n        }\n    }\n    \n    return \"\", fmt.Errorf(\"%d번 재시도 후 실패: %w\", maxRetries, lastErr)\n}\n\nfunc riskyOperation() (string, error) {\n    // 실패하는 작업 시뮬레이션\n    return \"\", errors.New(\"작업 실패\")\n}\n```\n\n## 에러 처리 모범 사례\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 1. 에러를 무시하지 말 것\n    file, err := os.Open(\"data.txt\")\n    if err != nil {\n        fmt.Println(\"오류:\", err)\n        return\n    }\n    defer file.Close()\n    \n    // 2. 에러에 문맥 추가\n    if err := processFile(file); err != nil {\n        fmt.Printf(\"파일 처리 실패: %v\\n\", err)\n        return\n    }\n    \n    // 3. 복구 가능한 에러는 처리, 불가능한 에러는 반환\n}\n\nfunc processFile(file *os.File) error {\n    // 처리 로직\n    return nil\n}\n```\n\n## 연습 문제\n\n1. 두 숫자를 나누는 함수를 작성하고 에러 처리를 추가하세요\n2. 사용자 정의 에러를 만들어 특정 조건에서 반환하세요\n3. panic과 recover를 사용해 안전한 배열 접근을 구현하세요\n\n## 핵심 요약\n\n- Go는 error 값으로 에러 처리\n- `errors.New()`: 에러 생성\n- `fmt.Errorf()`: 포맷팅된 에러\n- 함수는 마지막 반환값으로 error 반환\n- `if err != nil`: 에러 체크 패턴\n- `%w`: 에러 래핑\n- `errors.Is()`, `errors.Unwrap()`: 에러 확인\n- `panic`: 프로그램 중단\n- `recover`: 패닉 복구\n- 에러는 무시하지 말고 항상 처리할 것"
    }
  ]
}
