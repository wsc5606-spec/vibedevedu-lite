{
  "language": "csharp",
  "chapters": [
    {
      "chapterId": 1,
      "title": "1단원: 출력과 주석",
      "content": "# 1단원: 출력과 주석\n\n## C# 프로그램의 기본 구조\n\nC#은 마이크로소프트에서 개발한 현대적인 객체지향 프로그래밍 언어입니다. .NET 플랫폼에서 실행되며, Windows 애플리케이션, 웹, 게임(Unity) 등 다양한 분야에서 사용됩니다.\n\n### 프로그램 구조\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Hello, C#!\");\n    }\n}\n```\n\n- `using System;`: System 네임스페이스를 사용 (Console 클래스 포함)\n- `class Program`: Program 클래스 정의\n- `static void Main()`: 프로그램 진입점\n- `Console.WriteLine()`: 콘솔 출력 후 줄바꿈\n\n### C# 9.0 이상의 간소화된 구조\n\nC# 9.0부터는 Top-level statements를 지원하여 Main 메서드와 클래스 선언 없이 간단하게 작성 가능합니다.\n\n## 콘솔 출력\n\n### Console.WriteLine()과 Console.Write()\n\n- `Console.WriteLine()`: 출력 후 줄바꿈\n- `Console.Write()`: 줄바꿈 없이 출력\n- `Console.WriteLine()`: 빈 줄 출력\n\n### 문자열 보간 (String Interpolation)\n\n`$` 기호를 사용하여 문자열 내에 변수를 삽입할 수 있습니다.\n\n```csharp\nstring name = \"홍길동\";\nint age = 25;\nConsole.WriteLine($\"이름: {name}, 나이: {age}세\");\n```\n\n### 형식 지정자\n\n- `:F2`: 소수점 2자리\n- `:C`: 통화 형식\n- `:P`: 퍼센트\n- `:D8`: 8자리 정수 (0으로 채움)\n- `:N`: 천 단위 구분\n- `:E`: 지수 표기법\n\n## 주석 (Comments)\n\n### 한 줄 주석\n\n```csharp\n// 이것은 한 줄 주석입니다\n```\n\n### 여러 줄 주석\n\n```csharp\n/*\n여러 줄에 걸친\n주석입니다\n*/\n```\n\n### XML 문서 주석\n\n함수나 클래스를 설명할 때 사용하며, IntelliSense에 표시됩니다.\n\n```csharp\n/// <summary>\n/// 함수 설명\n/// </summary>\n/// <param name=\"a\">매개변수 설명</param>\n/// <returns>반환값 설명</returns>\n```\n\n## 이스케이프 시퀀스\n\n- `\\n`: 줄바꿈\n- `\\t`: 탭\n- `\\\"`: 큰따옴표\n- `\\'`: 작은따옴표\n- `\\\\`: 백슬래시\n\n### Verbatim 문자열 (@)\n\n`@` 기호를 사용하면 이스케이프 시퀀스를 무시하고 문자 그대로 출력합니다.\n\n```csharp\nstring path = @\"C:\\Users\\Documents\\file.txt\";\n```\n\n## 핵심 요약\n\n- **출력**: `Console.WriteLine()` (줄바꿈 포함), `Console.Write()` (줄바꿈 없음)\n- **문자열 보간**: `$\"text {variable}\"` 형태로 변수 삽입\n- **형식 지정**: `{value:형식}` 형태로 출력 형식 지정\n- **주석**: `//` (한 줄), `/* */` (여러 줄), `///` (XML 문서)\n- **이스케이프**: `\\n`, `\\t`, `\\\"` 등 특수 문자 표현\n- **Verbatim**: `@\"\"` 형태로 이스케이프 무시"
    },
    {
      "chapterId": 2,
      "title": "2단원: 변수와 자료형",
      "content": "# 2단원: 변수와 자료형\n\n## 변수란?\n\n변수는 데이터를 저장하는 메모리 공간으로, 이름(식별자)을 가지고 있으며 값을 저장하고 변경할 수 있습니다.\n\n### 변수 선언과 초기화\n\n```csharp\nint age;              // 선언만\nint score = 100;      // 선언과 동시에 초기화 (권장)\nint x = 1, y = 2;     // 여러 변수 동시 선언\n```\n\n### 변수 명명 규칙\n\n**필수 규칙:**\n- 첫 글자는 문자나 밑줄(_)로 시작\n- 숫자로 시작 불가\n- 공백 사용 불가\n- 예약어 사용 불가\n- 대소문자 구분\n\n**권장 규칙 (관례):**\n- camelCase: 지역 변수, 매개변수 (studentName)\n- PascalCase: 클래스, 메서드, 속성 (StudentInfo)\n- UPPER_CASE: 상수 (MAX_VALUE)\n\n## 기본 자료형 (Value Types)\n\n### 정수형\n\n- `sbyte`: -128 ~ 127 (1바이트)\n- `byte`: 0 ~ 255 (1바이트)\n- `short`: -32,768 ~ 32,767 (2바이트)\n- `ushort`: 0 ~ 65,535 (2바이트)\n- `int`: -2,147,483,648 ~ 2,147,483,647 (4바이트) ★ 기본\n- `uint`: 0 ~ 4,294,967,295 (4바이트)\n- `long`: 약 -9.2경 ~ 9.2경 (8바이트)\n- `ulong`: 0 ~ 약 18.4경 (8바이트)\n\n### 실수형\n\n- `float`: 약 7자리 정밀도 (4바이트, f 접미사 필수)\n- `double`: 약 15자리 정밀도 (8바이트) ★ 기본\n- `decimal`: 약 28자리 정밀도 (16바이트, m 접미사 필수, 금융용)\n\n### 문자형과 불린형\n\n- `char`: 16비트 유니코드 문자 (작은따옴표 사용)\n- `bool`: true 또는 false\n\n## 참조 자료형 (Reference Types)\n\n### string (문자열)\n\nstring은 참조 타입이지만 불변(immutable) 특성을 가집니다.\n\n**주요 속성과 메서드:**\n- `.Length`: 문자열 길이\n- `.ToUpper()`: 대문자 변환\n- `.ToLower()`: 소문자 변환\n- `.Contains()`: 포함 여부 확인\n- `.StartsWith()`: 시작 문자열 확인\n- `.EndsWith()`: 끝 문자열 확인\n- `.Substring()`: 부분 문자열 추출\n- `.Split()`: 문자열 분리\n- `.Replace()`: 문자열 치환\n- `.Trim()`: 공백 제거\n\n## var 키워드 (암시적 타입)\n\n컴파일러가 초기화 값을 보고 자동으로 타입을 추론합니다.\n\n```csharp\nvar num = 10;        // int로 추론\nvar name = \"홍길동\";  // string으로 추론\nvar height = 175.5;  // double로 추론\n```\n\n**특징:**\n- 반드시 초기화와 함께 선언\n- 한 번 정해진 타입은 변경 불가\n- 복잡한 제네릭 타입에서 유용\n\n## 상수 (const와 readonly)\n\n### const (컴파일 타임 상수)\n\n- 컴파일 시점에 값이 결정\n- 선언과 동시에 초기화 필수\n- 절대 변경 불가\n\n```csharp\nconst double PI = 3.14159265;\n```\n\n### readonly (런타임 상수)\n\n- 실행 시점에 값이 결정\n- 생성자에서 초기화 가능\n- 초기화 후 변경 불가\n\n## 형변환 (Type Conversion)\n\n### 암시적 형변환 (자동)\n\n작은 타입에서 큰 타입으로 자동 변환됩니다.\n\n```csharp\nint i = 100;\nlong l = i;      // int → long (자동)\ndouble d = i;    // int → double (자동)\n```\n\n### 명시적 형변환 (캐스팅)\n\n큰 타입에서 작은 타입으로 변환 시 명시적 변환이 필요하며, 데이터 손실 가능성이 있습니다.\n\n```csharp\ndouble d = 3.7;\nint i = (int)d;  // 소수점 버림, i = 3\n```\n\n### Convert 클래스\n\n다양한 타입 간 변환을 제공합니다.\n\n```csharp\nint num = Convert.ToInt32(\"123\");\ndouble d = Convert.ToDouble(\"3.14\");\nstring s = Convert.ToString(100);\n```\n\n### Parse와 TryParse\n\n- `Parse`: 변환 실패 시 예외 발생\n- `TryParse`: 변환 실패 시 false 반환 (안전)\n\n```csharp\nint num = int.Parse(\"123\");\n\nif (int.TryParse(\"123\", out int result))\n{\n    // 변환 성공\n}\n```\n\n## 핵심 요약\n\n**정수형:** byte, short, int ★, long (각각 부호 없는 버전 존재)\n\n**실수형:** float (f), double ★, decimal (m, 금융용)\n\n**기타:** char (문자), bool (true/false), string (문자열)\n\n**변수:** `타입 이름 = 값;` 형태로 선언 및 초기화\n\n**var:** 타입 추론 키워드, 초기화 필수\n\n**상수:** const (컴파일), readonly (런타임)\n\n**형변환:**\n- 암시적: 작은 타입 → 큰 타입 (자동)\n- 명시적: 큰 타입 → 작은 타입 (수동 캐스팅)\n- Parse/TryParse: 문자열 → 숫자\n- Convert: 다양한 타입 간 변환"
    },
    {
      "chapterId": 3,
      "title": "3단원: 연산자와 입력",
      "content": "# 3단원: 연산자와 입력\n\n## 산술 연산자\n\n기본적인 수학 연산을 수행합니다.\n\n- `+`: 덧셈\n- `-`: 뺄셈\n- `*`: 곱셈\n- `/`: 나눗셈 (정수끼리 나누면 정수 결과)\n- `%`: 나머지 (모듈로)\n\n**정수 나눗셈 주의사항:**\n- 정수 / 정수 = 정수 (소수점 버림)\n- 실수 결과를 원하면 최소 하나를 실수로 캐스팅\n\n## 복합 대입 연산자\n\n연산과 대입을 동시에 수행합니다.\n\n- `+=`: 더한 후 대입\n- `-=`: 뺀 후 대입\n- `*=`: 곱한 후 대입\n- `/=`: 나눈 후 대입\n- `%=`: 나머지를 구한 후 대입\n\n```csharp\nint x = 10;\nx += 5;  // x = x + 5; 와 동일, x는 15\n```\n\n## 증감 연산자\n\n변수의 값을 1 증가 또는 감소시킵니다.\n\n- `++`: 1 증가\n- `--`: 1 감소\n\n**전위와 후위:**\n- 전위 (`++x`): 증가 후 값 사용\n- 후위 (`x++`): 값 사용 후 증가\n\n## 비교 연산자\n\n두 값을 비교하여 bool 결과를 반환합니다.\n\n- `==`: 같음\n- `!=`: 같지 않음\n- `>`: 크다\n- `<`: 작다\n- `>=`: 크거나 같다\n- `<=`: 작거나 같다\n\n## 논리 연산자\n\nbool 값을 결합하거나 반전시킵니다.\n\n- `&&`: 논리 AND (둘 다 true일 때 true)\n- `||`: 논리 OR (하나라도 true면 true)\n- `!`: 논리 NOT (true ↔ false 반전)\n\n**단락 평가 (Short-circuit):**\n- `&&`: 왼쪽이 false면 오른쪽 평가 안 함\n- `||`: 왼쪽이 true면 오른쪽 평가 안 함\n\n## 비트 연산자\n\n비트 단위로 연산을 수행합니다.\n\n- `&`: 비트 AND\n- `|`: 비트 OR\n- `^`: 비트 XOR\n- `~`: 비트 NOT (보수)\n- `<<`: 왼쪽 시프트\n- `>>`: 오른쪽 시프트\n\n## 삼항 연산자 (조건 연산자)\n\n조건에 따라 값을 선택합니다.\n\n```csharp\n조건 ? 참일때값 : 거짓일때값\n```\n\n## 연산자 우선순위\n\n1. 괄호 `()`\n2. 단항 연산자 `++`, `--`, `!`\n3. 산술 연산자 `*`, `/`, `%` → `+`, `-`\n4. 비교 연산자 `<`, `>`, `<=`, `>=` → `==`, `!=`\n5. 논리 연산자 `&&` → `||`\n6. 삼항 연산자 `?:`\n7. 대입 연산자 `=`, `+=`, `-=` 등\n\n## 콘솔 입력\n\n### Console.ReadLine()\n\n사용자로부터 한 줄의 문자열을 입력받습니다.\n\n```csharp\nstring input = Console.ReadLine();\n```\n\n**특징:**\n- 항상 string 타입 반환\n- Enter 키를 누를 때까지 대기\n- null을 반환할 수 있음 (C# 8.0 이상에서 null 가능 참조 형식)\n\n### Console.Read()\n\n한 문자의 ASCII 코드를 정수로 반환합니다.\n\n### Console.ReadKey()\n\n키 입력을 받고 ConsoleKeyInfo 객체를 반환합니다.\n\n## 입력값 변환\n\n문자열 입력을 다른 타입으로 변환해야 합니다.\n\n```csharp\nstring input = Console.ReadLine();\nint number = int.Parse(input);          // 예외 발생 가능\nint.TryParse(input, out int result);    // 안전\n```\n\n**권장 방법:**\n- 안전한 입력: `TryParse` 사용\n- 예외 처리: try-catch 블록 사용\n\n## 핵심 요약\n\n**산술:** `+`, `-`, `*`, `/`, `%`\n\n**복합 대입:** `+=`, `-=`, `*=`, `/=`, `%=`\n\n**증감:** `++`, `--` (전위/후위)\n\n**비교:** `==`, `!=`, `>`, `<`, `>=`, `<=`\n\n**논리:** `&&` (AND), `||` (OR), `!` (NOT)\n\n**비트:** `&`, `|`, `^`, `~`, `<<`, `>>`\n\n**삼항:** `조건 ? 참 : 거짓`\n\n**입력:**\n- `Console.ReadLine()`: 문자열 한 줄 입력\n- `Parse`: 문자열 → 숫자 변환\n- `TryParse`: 안전한 변환 (권장)"
    },
    {
      "chapterId": 4,
      "title": "4단원: 조건문",
      "content": "# 4단원: 조건문\n\n## if 문\n\n조건이 참일 때 코드 블록을 실행합니다.\n\n### 기본 형태\n\n```csharp\nif (조건)\n{\n    // 조건이 참일 때 실행\n}\n```\n\n### if-else 문\n\n```csharp\nif (조건)\n{\n    // 조건이 참일 때\n}\nelse\n{\n    // 조건이 거짓일 때\n}\n```\n\n### if-else if-else 문\n\n여러 조건을 순차적으로 검사합니다.\n\n```csharp\nif (조건1)\n{\n    // 조건1이 참\n}\nelse if (조건2)\n{\n    // 조건1은 거짓, 조건2가 참\n}\nelse if (조건3)\n{\n    // 조건1, 2는 거짓, 조건3이 참\n}\nelse\n{\n    // 모든 조건이 거짓\n}\n```\n\n### 중첩 if 문\n\nif 문 안에 또 다른 if 문을 포함할 수 있습니다.\n\n```csharp\nif (조건1)\n{\n    if (조건2)\n    {\n        // 조건1과 조건2 모두 참\n    }\n}\n```\n\n## switch 문\n\n하나의 변수나 식의 값에 따라 여러 경우 중 하나를 선택합니다.\n\n### 기본 형태\n\n```csharp\nswitch (변수)\n{\n    case 값1:\n        // 값1일 때 실행\n        break;\n    case 값2:\n        // 값2일 때 실행\n        break;\n    case 값3:\n        // 값3일 때 실행\n        break;\n    default:\n        // 어떤 case에도 해당하지 않을 때\n        break;\n}\n```\n\n**특징:**\n- 각 case는 `break`로 종료 (필수)\n- `default`는 선택적 (생략 가능)\n- 여러 case를 하나로 묶을 수 있음\n\n### 여러 case 묶기\n\n```csharp\nswitch (day)\n{\n    case \"월요일\":\n    case \"화요일\":\n    case \"수요일\":\n    case \"목요일\":\n    case \"금요일\":\n        Console.WriteLine(\"평일\");\n        break;\n    case \"토요일\":\n    case \"일요일\":\n        Console.WriteLine(\"주말\");\n        break;\n}\n```\n\n## switch 식 (C# 8.0 이상)\n\n더 간결한 switch 표현 방식입니다.\n\n```csharp\nstring result = day switch\n{\n    \"월요일\" => \"평일\",\n    \"화요일\" => \"평일\",\n    \"토요일\" => \"주말\",\n    \"일요일\" => \"주말\",\n    _ => \"알 수 없음\"  // default\n};\n```\n\n**특징:**\n- `=>` 사용\n- `break` 불필요\n- 값을 직접 반환\n- `_`는 default와 동일\n\n## 패턴 매칭 (C# 7.0 이상)\n\nswitch 문에서 타입이나 패턴을 검사할 수 있습니다.\n\n### 타입 패턴\n\n```csharp\nobject obj = \"Hello\";\n\nswitch (obj)\n{\n    case int i:\n        Console.WriteLine($\"정수: {i}\");\n        break;\n    case string s:\n        Console.WriteLine($\"문자열: {s}\");\n        break;\n    case null:\n        Console.WriteLine(\"null\");\n        break;\n}\n```\n\n### when 절\n\n추가 조건을 지정할 수 있습니다.\n\n```csharp\nswitch (score)\n{\n    case int n when n >= 90:\n        Console.WriteLine(\"A\");\n        break;\n    case int n when n >= 80:\n        Console.WriteLine(\"B\");\n        break;\n    case int n when n >= 70:\n        Console.WriteLine(\"C\");\n        break;\n    default:\n        Console.WriteLine(\"F\");\n        break;\n}\n```\n\n## 조건 연산자 (삼항 연산자)\n\n간단한 조건문을 한 줄로 표현합니다.\n\n```csharp\n변수 = 조건 ? 참일때값 : 거짓일때값;\n```\n\n**사용 시기:**\n- 간단한 조건 판단\n- 값 할당이 목적\n- 가독성이 떨어지지 않는 경우\n\n## null 조건부 연산자 (C# 6.0 이상)\n\n### ?. (null 조건 연산자)\n\n객체가 null이 아닐 때만 멤버에 접근합니다.\n\n```csharp\nstring text = null;\nint? length = text?.Length;  // null 반환 (예외 발생 안 함)\n```\n\n### ?? (null 병합 연산자)\n\nnull일 때 기본값을 제공합니다.\n\n```csharp\nstring name = null;\nstring displayName = name ?? \"이름 없음\";  // \"이름 없음\"\n```\n\n### ??= (null 병합 할당 연산자, C# 8.0)\n\nnull일 때만 값을 할당합니다.\n\n```csharp\nstring name = null;\nname ??= \"기본값\";  // name이 null이므로 \"기본값\" 할당\n```\n\n## 핵심 요약\n\n**if 문:**\n- `if (조건)`: 단일 조건\n- `if-else`: 양자택일\n- `if-else if-else`: 다중 조건\n- 중첩 가능\n\n**switch 문:**\n- 하나의 값에 대한 다중 분기\n- 각 case는 break 필요\n- default는 선택적\n- 여러 case 묶기 가능\n\n**switch 식 (C# 8.0+):**\n- `변수 switch { ... }` 형태\n- `=>` 사용\n- 더 간결\n\n**패턴 매칭:**\n- 타입 패턴\n- when 절로 추가 조건\n\n**조건 연산자:**\n- 삼항: `조건 ? 참 : 거짓`\n- null 조건: `?.`\n- null 병합: `??`\n- null 병합 할당: `??=`"
    },
    {
      "chapterId": 5,
      "title": "5단원: 반복문",
      "content": "# 5단원: 반복문\n\n## for 문\n\n정해진 횟수만큼 반복할 때 사용합니다.\n\n### 기본 구조\n\n```csharp\nfor (초기화; 조건; 증감)\n{\n    // 반복할 코드\n}\n```\n\n**실행 순서:**\n1. 초기화 (한 번만 실행)\n2. 조건 검사 (false면 종료)\n3. 코드 블록 실행\n4. 증감 실행\n5. 2번으로 돌아감\n\n### 특징\n\n- 반복 횟수가 명확할 때 사용\n- 배열이나 컬렉션의 인덱스 접근에 유용\n- 초기화, 조건, 증감 모두 생략 가능 (무한 루프)\n\n## while 문\n\n조건이 참인 동안 반복합니다.\n\n### 기본 구조\n\n```csharp\nwhile (조건)\n{\n    // 반복할 코드\n}\n```\n\n**특징:**\n- 조건을 먼저 검사 (0번 실행 가능)\n- 반복 횟수를 모를 때 사용\n- 조건이 항상 true면 무한 루프\n\n## do-while 문\n\n최소 한 번은 실행하고, 조건이 참인 동안 반복합니다.\n\n### 기본 구조\n\n```csharp\ndo\n{\n    // 반복할 코드\n} while (조건);\n```\n\n**특징:**\n- 코드를 먼저 실행, 조건은 나중에 검사\n- 최소 1번은 반드시 실행\n- 세미콜론(;) 필수\n\n## foreach 문\n\n배열이나 컬렉션의 각 요소를 순회합니다.\n\n### 기본 구조\n\n```csharp\nforeach (타입 변수 in 컬렉션)\n{\n    // 각 요소에 대해 실행\n}\n```\n\n**특징:**\n- 읽기 전용 순회 (요소 수정 불가)\n- 인덱스 없이 모든 요소 접근\n- IEnumerable 인터페이스를 구현한 모든 컬렉션에 사용 가능\n- 가장 간결하고 안전한 순회 방법\n\n## break 문\n\n반복문을 즉시 종료하고 빠져나갑니다.\n\n**사용 예:**\n- 특정 조건 만족 시 반복 중단\n- 원하는 값을 찾았을 때\n- 에러 상황에서 탈출\n\n## continue 문\n\n현재 반복을 건너뛰고 다음 반복으로 이동합니다.\n\n**특징:**\n- 현재 반복의 나머지 코드를 건너뜀\n- 반복문 자체는 종료되지 않음\n- 특정 조건의 요소만 처리할 때 유용\n\n## 중첩 반복문\n\n반복문 안에 또 다른 반복문을 포함할 수 있습니다.\n\n**사용 예:**\n- 2차원 배열 처리\n- 구구단\n- 별 찍기 패턴\n- 조합/순열 계산\n\n**주의사항:**\n- 중첩이 깊어질수록 성능 저하\n- break/continue는 가장 가까운 반복문에만 적용\n\n## 무한 루프\n\n조건이 항상 참이어서 끝나지 않는 반복문입니다.\n\n### 생성 방법\n\n```csharp\nwhile (true) { }\nfor (;;) { }\ndo { } while (true);\n```\n\n**사용 예:**\n- 서버 프로그램 (계속 실행)\n- 게임 루프\n- 이벤트 처리 루프\n\n**주의:** break나 return으로 탈출 방법 필요\n\n## 반복문 선택 가이드\n\n### for 문을 사용할 때\n- 반복 횟수가 정해져 있을 때\n- 인덱스가 필요할 때\n- 배열을 역순으로 순회할 때\n\n### while 문을 사용할 때\n- 반복 횟수를 모를 때\n- 조건이 복잡할 때\n- 무한 루프가 필요할 때\n\n### do-while 문을 사용할 때\n- 최소 1번은 반드시 실행해야 할 때\n- 메뉴 선택 프로그램\n- 입력 검증 (재입력 요구)\n\n### foreach 문을 사용할 때\n- 모든 요소를 순회할 때\n- 인덱스가 필요 없을 때\n- 읽기만 할 때 (수정 불필요)\n- 가장 안전하고 간결한 코드를 원할 때\n\n## 핵심 요약\n\n**for 문:**\n- `for (초기화; 조건; 증감)`\n- 횟수가 정해진 반복\n- 인덱스 필요 시\n\n**while 문:**\n- `while (조건)`\n- 조건 먼저 검사\n- 횟수를 모를 때\n\n**do-while 문:**\n- `do { } while (조건);`\n- 코드 먼저 실행\n- 최소 1번 실행 보장\n\n**foreach 문:**\n- `foreach (타입 변수 in 컬렉션)`\n- 컬렉션 순회\n- 읽기 전용\n- 가장 안전\n\n**제어:**\n- `break`: 반복문 즉시 종료\n- `continue`: 현재 반복 건너뛰기\n\n**무한 루프:**\n- `while (true)`, `for (;;)`\n- 탈출 방법 필요 (break/return)"
    },
    {
      "chapterId": 6,
      "title": "6단원: 메서드",
      "content": "# 6단원: 메서드\n\n## 메서드란?\n\n메서드는 특정 작업을 수행하는 코드 블록입니다. 함수(Function)라고도 하며, 코드의 재사용성과 모듈화를 높입니다.\n\n## 메서드 정의\n\n### 기본 구조\n\n```csharp\n접근제한자 반환타입 메서드이름(매개변수목록)\n{\n    // 메서드 본문\n    return 반환값;\n}\n```\n\n### 구성 요소\n\n- **접근 제한자**: public, private, protected, internal 등\n- **반환 타입**: 메서드가 반환하는 값의 타입 (void는 반환값 없음)\n- **메서드 이름**: PascalCase 사용 (권장)\n- **매개변수**: 입력값 (선택적)\n- **return**: 값을 반환하고 메서드 종료\n\n## 반환값이 없는 메서드 (void)\n\n```csharp\nvoid PrintMessage()\n{\n    Console.WriteLine(\"안녕하세요\");\n}\n```\n\n- `void` 키워드 사용\n- return 문 생략 가능 (또는 `return;`만 사용)\n\n## 반환값이 있는 메서드\n\n```csharp\nint Add(int a, int b)\n{\n    return a + b;\n}\n```\n\n- 반환 타입 명시\n- `return` 키워드로 값 반환 필수\n- 반환 타입과 return 값의 타입 일치해야 함\n\n## 매개변수\n\n### 값 매개변수 (기본)\n\n값을 복사하여 전달합니다. 원본 변수는 변경되지 않습니다.\n\n```csharp\nvoid Increase(int x)\n{\n    x++;  // 복사본만 변경\n}\n```\n\n### ref 매개변수\n\n참조를 전달하여 원본 변수를 수정할 수 있습니다.\n\n```csharp\nvoid Increase(ref int x)\n{\n    x++;  // 원본 변경\n}\n\n// 호출\nint num = 10;\nIncrease(ref num);  // ref 키워드 필요\n```\n\n**특징:**\n- 호출 전에 변수 초기화 필수\n- 호출 시에도 `ref` 키워드 사용\n\n### out 매개변수\n\n메서드에서 여러 값을 반환할 때 사용합니다.\n\n```csharp\nvoid GetMinMax(int[] arr, out int min, out int max)\n{\n    min = arr.Min();\n    max = arr.Max();\n}\n\n// 호출\nint minimum, maximum;\nGetMinMax(numbers, out minimum, out maximum);\n```\n\n**특징:**\n- 호출 전 초기화 불필요\n- 메서드 내에서 반드시 값 할당 필요\n- 호출 시 `out` 키워드 사용\n\n### in 매개변수 (C# 7.2)\n\n읽기 전용 참조를 전달합니다.\n\n```csharp\nvoid Display(in int value)\n{\n    // value는 읽기만 가능, 수정 불가\n    Console.WriteLine(value);\n}\n```\n\n**특징:**\n- 큰 구조체 전달 시 성능 향상\n- 메서드 내에서 수정 불가\n\n### 선택적 매개변수\n\n기본값을 지정하여 생략 가능한 매개변수를 만듭니다.\n\n```csharp\nvoid PrintMessage(string msg = \"기본 메시지\")\n{\n    Console.WriteLine(msg);\n}\n\n// 호출\nPrintMessage();           // \"기본 메시지\"\nPrintMessage(\"안녕\");      // \"안녕\"\n```\n\n**규칙:**\n- 필수 매개변수 뒤에 위치\n- 컴파일 타임 상수만 기본값으로 사용 가능\n\n### 명명된 매개변수\n\n매개변수 이름을 명시하여 호출합니다.\n\n```csharp\nvoid CreateUser(string name, int age, string city)\n{\n    // ...\n}\n\n// 순서와 무관하게 호출\nCreateUser(age: 25, name: \"홍길동\", city: \"서울\");\n```\n\n### params 매개변수\n\n가변 개수의 인수를 받을 수 있습니다.\n\n```csharp\nint Sum(params int[] numbers)\n{\n    return numbers.Sum();\n}\n\n// 호출\nSum(1, 2, 3);           // 6\nSum(1, 2, 3, 4, 5);     // 15\n```\n\n**특징:**\n- 매개변수 목록의 마지막에만 위치\n- 하나만 선언 가능\n\n## 메서드 오버로딩\n\n같은 이름의 메서드를 여러 개 정의하되, 매개변수가 달라야 합니다.\n\n```csharp\nint Add(int a, int b) { return a + b; }\ndouble Add(double a, double b) { return a + b; }\nint Add(int a, int b, int c) { return a + b + c; }\n```\n\n**오버로딩 조건:**\n- 매개변수 개수가 다름\n- 매개변수 타입이 다름\n- 매개변수 순서가 다름\n\n**주의:** 반환 타입만 다른 것은 오버로딩 불가\n\n## 재귀 메서드\n\n메서드가 자기 자신을 호출하는 것입니다.\n\n```csharp\nint Factorial(int n)\n{\n    if (n <= 1) return 1;        // 기저 조건\n    return n * Factorial(n - 1);  // 재귀 호출\n}\n```\n\n**구성 요소:**\n- **기저 조건**: 재귀를 멈추는 조건 (필수)\n- **재귀 호출**: 자기 자신을 호출\n\n**주의사항:**\n- 기저 조건이 없으면 무한 재귀\n- 깊은 재귀는 스택 오버플로우 위험\n\n## 로컬 함수 (C# 7.0)\n\n메서드 내부에 정의된 함수입니다.\n\n```csharp\nvoid OuterMethod()\n{\n    int LocalFunction(int x)\n    {\n        return x * 2;\n    }\n    \n    int result = LocalFunction(5);\n}\n```\n\n**특징:**\n- 외부 메서드의 변수에 접근 가능\n- 해당 메서드 내에서만 사용 가능\n- 코드 구조화에 유용\n\n## 표현식 본문 멤버 (C# 6.0)\n\n간단한 메서드를 람다 식처럼 간결하게 작성합니다.\n\n```csharp\n// 일반 방식\nint Add(int a, int b)\n{\n    return a + b;\n}\n\n// 표현식 본문\nint Add(int a, int b) => a + b;\n```\n\n**특징:**\n- `=>` 사용\n- return 키워드 생략\n- 중괄호 생략\n- 한 줄짜리 메서드에 적합\n\n## Main 메서드\n\n프로그램의 진입점입니다.\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 프로그램 시작\n}\n```\n\n**특징:**\n- 반드시 static\n- 반환 타입: void 또는 int\n- 매개변수: string[] args (선택적)\n- 클래스 당 하나만 가능\n\n## 핵심 요약\n\n**메서드 정의:**\n```csharp\n접근제한자 반환타입 메서드이름(매개변수)\n{\n    return 값;\n}\n```\n\n**매개변수 종류:**\n- 기본: 값 복사\n- `ref`: 참조 전달, 초기화 필수\n- `out`: 출력용, 초기화 불필요\n- `in`: 읽기 전용 참조\n- 선택적: 기본값 지정\n- 명명된: 이름으로 전달\n- `params`: 가변 개수\n\n**오버로딩:**\n- 같은 이름, 다른 매개변수\n- 개수, 타입, 순서 다름\n\n**재귀:**\n- 자기 자신 호출\n- 기저 조건 필수\n\n**로컬 함수:**\n- 메서드 내부 함수\n- 외부 변수 접근 가능\n\n**표현식 본문:**\n- `=>` 사용\n- 간결한 한 줄 메서드"
    },
    {
      "chapterId": 7,
      "title": "7단원: 배열과 컬렉션",
      "content": "# 7단원: 배열과 컬렉션\n\n## 배열 (Array)\n\n같은 타입의 데이터를 연속된 메모리 공간에 저장하는 자료구조입니다.\n\n### 1차원 배열\n\n```csharp\n// 선언\nint[] numbers;\n\n// 선언과 동시에 크기 지정\nint[] arr = new int[5];\n\n// 선언과 동시에 초기화\nint[] nums = { 1, 2, 3, 4, 5 };\nint[] values = new int[] { 10, 20, 30 };\n```\n\n**특징:**\n- 인덱스는 0부터 시작\n- 크기 고정 (생성 후 변경 불가)\n- `.Length` 속성으로 길이 확인\n\n### 배열 요소 접근\n\n```csharp\nint[] arr = { 10, 20, 30, 40, 50 };\nint first = arr[0];    // 10\nint last = arr[4];     // 50\narr[2] = 100;          // 30 → 100으로 변경\n```\n\n### 다차원 배열\n\n```csharp\n// 2차원 배열 선언 및 초기화\nint[,] matrix = new int[3, 4];  // 3행 4열\n\n// 초기화\nint[,] table = {\n    { 1, 2, 3 },\n    { 4, 5, 6 },\n    { 7, 8, 9 }\n};\n\n// 접근\nint value = table[1, 2];  // 6\n```\n\n### 가변 배열 (Jagged Array)\n\n배열의 배열로, 각 행의 길이가 다를 수 있습니다.\n\n```csharp\nint[][] jagged = new int[3][];\njagged[0] = new int[] { 1, 2 };\njagged[1] = new int[] { 3, 4, 5, 6 };\njagged[2] = new int[] { 7 };\n\n// 접근\nint value = jagged[1][2];  // 5\n```\n\n### 배열 메서드\n\n- `Array.Sort()`: 정렬\n- `Array.Reverse()`: 역순\n- `Array.IndexOf()`: 요소 찾기\n- `Array.Copy()`: 복사\n- `Array.Clear()`: 초기화\n\n## List<T>\n\n동적 크기의 배열입니다. 가장 많이 사용되는 컬렉션입니다.\n\n### 선언과 초기화\n\n```csharp\nList<int> numbers = new List<int>();\nList<string> names = new List<string> { \"홍길동\", \"김철수\" };\n```\n\n### 주요 메서드\n\n- `.Add()`: 요소 추가\n- `.Remove()`: 요소 제거\n- `.RemoveAt()`: 인덱스로 제거\n- `.Insert()`: 특정 위치에 삽입\n- `.Clear()`: 모든 요소 제거\n- `.Contains()`: 포함 여부\n- `.IndexOf()`: 인덱스 찾기\n- `.Sort()`: 정렬\n- `.Reverse()`: 역순\n\n### 주요 속성\n\n- `.Count`: 요소 개수\n- `.Capacity`: 내부 배열 크기\n\n## Dictionary<TKey, TValue>\n\n키-값 쌍으로 데이터를 저장합니다.\n\n### 선언과 초기화\n\n```csharp\nDictionary<string, int> ages = new Dictionary<string, int>();\n\nDictionary<string, string> capitals = new Dictionary<string, string>\n{\n    { \"한국\", \"서울\" },\n    { \"일본\", \"도쿄\" },\n    { \"미국\", \"워싱턴 D.C.\" }\n};\n```\n\n### 주요 메서드\n\n- `.Add(key, value)`: 추가\n- `.Remove(key)`: 제거\n- `.ContainsKey(key)`: 키 존재 여부\n- `.ContainsValue(value)`: 값 존재 여부\n- `.TryGetValue(key, out value)`: 안전한 값 가져오기\n- `.Clear()`: 모든 요소 제거\n\n### 요소 접근\n\n```csharp\nages[\"홍길동\"] = 25;           // 추가 또는 수정\nint age = ages[\"홍길동\"];      // 25\n\nif (ages.TryGetValue(\"김철수\", out int result))\n{\n    // 존재하면 result에 값 저장\n}\n```\n\n### 순회\n\n```csharp\nforeach (KeyValuePair<string, int> pair in ages)\n{\n    Console.WriteLine($\"{pair.Key}: {pair.Value}\");\n}\n\n// 또는\nforeach (var pair in ages)\n{\n    Console.WriteLine($\"{pair.Key}: {pair.Value}\");\n}\n```\n\n## HashSet<T>\n\n중복을 허용하지 않는 집합입니다.\n\n### 선언과 초기화\n\n```csharp\nHashSet<int> uniqueNumbers = new HashSet<int>();\nHashSet<string> names = new HashSet<string> { \"홍길동\", \"김철수\" };\n```\n\n### 주요 메서드\n\n- `.Add()`: 추가 (중복 시 false 반환)\n- `.Remove()`: 제거\n- `.Contains()`: 포함 여부\n- `.UnionWith()`: 합집합\n- `.IntersectWith()`: 교집합\n- `.ExceptWith()`: 차집합\n\n## Queue<T>\n\nFIFO (First In First Out) 구조입니다.\n\n### 주요 메서드\n\n- `.Enqueue()`: 요소 추가 (뒤에)\n- `.Dequeue()`: 요소 제거 및 반환 (앞에서)\n- `.Peek()`: 앞 요소 확인 (제거 안 함)\n- `.Clear()`: 모든 요소 제거\n\n```csharp\nQueue<string> queue = new Queue<string>();\nqueue.Enqueue(\"첫번째\");\nqueue.Enqueue(\"두번째\");\nstring first = queue.Dequeue();  // \"첫번째\"\n```\n\n## Stack<T>\n\nLIFO (Last In First Out) 구조입니다.\n\n### 주요 메서드\n\n- `.Push()`: 요소 추가 (위에)\n- `.Pop()`: 요소 제거 및 반환 (위에서)\n- `.Peek()`: 맨 위 요소 확인 (제거 안 함)\n- `.Clear()`: 모든 요소 제거\n\n```csharp\nStack<int> stack = new Stack<int>();\nstack.Push(10);\nstack.Push(20);\nint top = stack.Pop();  // 20\n```\n\n## LINQ (Language Integrated Query)\n\n컬렉션을 쿼리하고 변환하는 강력한 기능입니다.\n\n### 주요 LINQ 메서드\n\n- `.Where()`: 조건 필터링\n- `.Select()`: 변환 (projection)\n- `.OrderBy()`: 오름차순 정렬\n- `.OrderByDescending()`: 내림차순 정렬\n- `.First()`: 첫 번째 요소\n- `.Last()`: 마지막 요소\n- `.Any()`: 하나라도 만족하는지\n- `.All()`: 모두 만족하는지\n- `.Count()`: 개수\n- `.Sum()`: 합계\n- `.Average()`: 평균\n- `.Min()`: 최솟값\n- `.Max()`: 최댓값\n- `.Take()`: 앞에서 n개\n- `.Skip()`: 앞에서 n개 건너뛰기\n\n### LINQ 쿼리 구문\n\n```csharp\nvar result = from item in collection\n             where 조건\n             orderby item\n             select item;\n```\n\n## 컬렉션 선택 가이드\n\n### Array (배열)\n- 크기가 고정적일 때\n- 인덱스 접근이 빈번할 때\n- 메모리 효율이 중요할 때\n\n### List<T>\n- 크기가 동적일 때\n- 순서가 중요할 때\n- 가장 범용적인 선택\n\n### Dictionary<TKey, TValue>\n- 키-값 쌍으로 저장할 때\n- 빠른 검색이 필요할 때\n\n### HashSet<T>\n- 중복을 제거하고 싶을 때\n- 집합 연산이 필요할 때\n- 존재 여부만 확인할 때\n\n### Queue<T>\n- FIFO 구조가 필요할 때\n- 대기열, 작업 큐\n\n### Stack<T>\n- LIFO 구조가 필요할 때\n- 되돌리기 기능, 재귀 대체\n\n## 핵심 요약\n\n**배열:**\n- 고정 크기, 같은 타입\n- `int[] arr = new int[5];`\n- 인덱스 0부터 시작\n\n**List<T>:**\n- 동적 크기\n- Add, Remove, Insert 등\n- 가장 많이 사용\n\n**Dictionary<TKey, TValue>:**\n- 키-값 쌍\n- 빠른 검색 (O(1))\n- 키는 중복 불가\n\n**HashSet<T>:**\n- 중복 불가\n- 집합 연산\n\n**Queue<T>:**\n- FIFO (선입선출)\n- Enqueue, Dequeue\n\n**Stack<T>:**\n- LIFO (후입선출)\n- Push, Pop\n\n**LINQ:**\n- Where, Select, OrderBy 등\n- 컬렉션 쿼리 및 변환"
    },
    {
      "chapterId": 8,
      "title": "8단원: 클래스와 객체지향",
      "content": "# 8단원: 클래스와 객체지향\n\n## 클래스와 객체\n\n### 클래스 (Class)\n\n객체를 만들기 위한 설계도입니다. 데이터(필드)와 기능(메서드)을 포함합니다.\n\n### 객체 (Object)\n\n클래스를 기반으로 생성된 실체(인스턴스)입니다.\n\n### 클래스 정의\n\n```csharp\nclass Person\n{\n    // 필드 (데이터)\n    public string Name;\n    public int Age;\n    \n    // 메서드 (기능)\n    public void Introduce()\n    {\n        Console.WriteLine($\"이름: {Name}, 나이: {Age}\");\n    }\n}\n```\n\n### 객체 생성 및 사용\n\n```csharp\nPerson person = new Person();\nperson.Name = \"홍길동\";\nperson.Age = 25;\nperson.Introduce();\n```\n\n## 생성자 (Constructor)\n\n객체 생성 시 자동으로 호출되는 특별한 메서드입니다.\n\n### 기본 생성자\n\n```csharp\nclass Person\n{\n    public string Name;\n    public int Age;\n    \n    // 생성자\n    public Person()\n    {\n        Name = \"이름 없음\";\n        Age = 0;\n    }\n}\n```\n\n### 매개변수가 있는 생성자\n\n```csharp\nclass Person\n{\n    public string Name;\n    public int Age;\n    \n    public Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n}\n\n// 사용\nPerson person = new Person(\"홍길동\", 25);\n```\n\n### 생성자 오버로딩\n\n```csharp\nclass Person\n{\n    public string Name;\n    public int Age;\n    \n    public Person() { }\n    public Person(string name) { Name = name; }\n    public Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n}\n```\n\n## 속성 (Property)\n\n필드에 대한 접근을 제어하는 메서드입니다.\n\n### 기본 속성\n\n```csharp\nclass Person\n{\n    private string name;  // 백킹 필드\n    \n    public string Name\n    {\n        get { return name; }\n        set { name = value; }\n    }\n}\n```\n\n### 자동 구현 속성\n\n```csharp\nclass Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n```\n\n### 읽기 전용 속성\n\n```csharp\npublic string Name { get; private set; }  // 외부에서 읽기만 가능\npublic int Age { get; }  // 완전 읽기 전용 (생성자에서만 설정)\n```\n\n### 계산된 속성\n\n```csharp\nclass Person\n{\n    public int BirthYear { get; set; }\n    \n    public int Age\n    {\n        get { return DateTime.Now.Year - BirthYear; }\n    }\n}\n```\n\n## 접근 제한자\n\n- `public`: 모든 곳에서 접근 가능\n- `private`: 같은 클래스 내에서만 접근 가능 (기본값)\n- `protected`: 같은 클래스와 상속받은 클래스에서 접근 가능\n- `internal`: 같은 어셈블리 내에서만 접근 가능\n- `protected internal`: protected 또는 internal\n\n## 캡슐화 (Encapsulation)\n\n데이터와 메서드를 하나로 묶고, 외부로부터 내부 구현을 숨기는 것입니다.\n\n**원칙:**\n- 필드는 private으로\n- 외부 접근은 public 속성이나 메서드를 통해\n\n## 상속 (Inheritance)\n\n기존 클래스의 기능을 물려받아 새로운 클래스를 만드는 것입니다.\n\n```csharp\nclass Animal\n{\n    public string Name { get; set; }\n    \n    public void Eat()\n    {\n        Console.WriteLine($\"{Name}이(가) 먹습니다.\");\n    }\n}\n\nclass Dog : Animal  // Animal을 상속\n{\n    public void Bark()\n    {\n        Console.WriteLine(\"멍멍!\");\n    }\n}\n\n// 사용\nDog dog = new Dog();\ndog.Name = \"바둑이\";\ndog.Eat();   // 상속받은 메서드\ndog.Bark();  // 자신의 메서드\n```\n\n**특징:**\n- C#은 단일 상속만 지원 (한 클래스만 상속)\n- 모든 클래스는 기본적으로 `object` 상속\n\n## 메서드 재정의 (Override)\n\n### virtual과 override\n\n```csharp\nclass Animal\n{\n    public virtual void MakeSound()  // virtual: 재정의 가능\n    {\n        Console.WriteLine(\"소리를 냅니다.\");\n    }\n}\n\nclass Dog : Animal\n{\n    public override void MakeSound()  // override: 재정의\n    {\n        Console.WriteLine(\"멍멍!\");\n    }\n}\n```\n\n### base 키워드\n\n부모 클래스의 멤버에 접근합니다.\n\n```csharp\nclass Dog : Animal\n{\n    public override void MakeSound()\n    {\n        base.MakeSound();  // 부모 메서드 호출\n        Console.WriteLine(\"멍멍!\");\n    }\n}\n```\n\n## 다형성 (Polymorphism)\n\n같은 인터페이스로 다른 동작을 수행하는 것입니다.\n\n```csharp\nAnimal animal1 = new Dog();\nAnimal animal2 = new Cat();\n\nanimal1.MakeSound();  // \"멍멍!\"\nanimal2.MakeSound();  // \"야옹!\"\n```\n\n## 추상 클래스 (Abstract Class)\n\n인스턴스를 만들 수 없는 불완전한 클래스입니다.\n\n```csharp\nabstract class Shape\n{\n    public abstract double GetArea();  // 추상 메서드 (구현 없음)\n    \n    public void Display()  // 일반 메서드 가능\n    {\n        Console.WriteLine($\"넓이: {GetArea()}\");\n    }\n}\n\nclass Circle : Shape\n{\n    public double Radius { get; set; }\n    \n    public override double GetArea()  // 반드시 구현\n    {\n        return Math.PI * Radius * Radius;\n    }\n}\n```\n\n**특징:**\n- `abstract` 키워드 사용\n- 인스턴스 생성 불가\n- 추상 메서드는 자식 클래스에서 반드시 구현\n\n## 인터페이스 (Interface)\n\n구현이 없는 메서드와 속성의 집합입니다.\n\n```csharp\ninterface IMovable\n{\n    void Move();\n    int Speed { get; set; }\n}\n\nclass Car : IMovable\n{\n    public int Speed { get; set; }\n    \n    public void Move()\n    {\n        Console.WriteLine($\"{Speed}km/h로 이동합니다.\");\n    }\n}\n```\n\n**특징:**\n- 모든 멤버는 public\n- 구현이 없음 (C# 8.0부터 기본 구현 가능)\n- 다중 인터페이스 구현 가능\n- 명명 규칙: I로 시작 (IComparable, IEnumerable)\n\n**추상 클래스 vs 인터페이스:**\n- 추상 클래스: \"is-a\" 관계, 단일 상속\n- 인터페이스: \"can-do\" 관계, 다중 구현\n\n## 정적 멤버 (Static)\n\n클래스 레벨에서 공유되는 멤버입니다.\n\n```csharp\nclass MathHelper\n{\n    public static double PI = 3.14159;\n    \n    public static int Add(int a, int b)\n    {\n        return a + b;\n    }\n}\n\n// 사용 (인스턴스 생성 없이)\nConsole.WriteLine(MathHelper.PI);\nint sum = MathHelper.Add(10, 20);\n```\n\n**특징:**\n- 클래스 이름으로 접근\n- 모든 인스턴스가 공유\n- 인스턴스 멤버 접근 불가\n\n## 봉인 클래스 (sealed)\n\n상속을 막는 클래스입니다.\n\n```csharp\nsealed class FinalClass\n{\n    // 더 이상 상속 불가\n}\n```\n\n## this 키워드\n\n현재 인스턴스를 참조합니다.\n\n```csharp\nclass Person\n{\n    private string name;\n    \n    public Person(string name)\n    {\n        this.name = name;  // 매개변수와 필드 구분\n    }\n}\n```\n\n## 핵심 요약\n\n**클래스와 객체:**\n- 클래스: 설계도\n- 객체: 실체(인스턴스)\n- `new` 키워드로 생성\n\n**생성자:**\n- 객체 초기화\n- 클래스명과 동일\n- 오버로딩 가능\n\n**속성:**\n- get/set 접근자\n- 자동 구현 속성\n- 캡슐화 지원\n\n**접근 제한자:**\n- public, private, protected, internal\n\n**상속:**\n- `: 부모클래스`\n- 단일 상속\n- virtual/override\n- base 키워드\n\n**추상 클래스:**\n- `abstract` 키워드\n- 인스턴스 생성 불가\n- 추상 메서드 포함 가능\n\n**인터페이스:**\n- `interface` 키워드\n- 구현 강제\n- 다중 구현 가능\n\n**정적 멤버:**\n- `static` 키워드\n- 클래스 레벨 공유\n- 인스턴스 없이 접근"
    },
    {
      "chapterId": 9,
      "title": "9단원: 파일 입출력",
      "content": "# 9단원: 파일 입출력\n\n## System.IO 네임스페이스\n\n파일 및 디렉토리 작업을 위한 클래스들이 포함되어 있습니다.\n\n```csharp\nusing System.IO;\n```\n\n## File 클래스\n\n파일 전체를 한 번에 읽거나 쓰는 정적 메서드를 제공합니다.\n\n### 파일 읽기\n\n```csharp\n// 모든 텍스트 읽기\nstring content = File.ReadAllText(\"file.txt\");\n\n// 모든 줄을 배열로 읽기\nstring[] lines = File.ReadAllLines(\"file.txt\");\n\n// 모든 바이트 읽기\nbyte[] bytes = File.ReadAllBytes(\"file.bin\");\n```\n\n### 파일 쓰기\n\n```csharp\n// 텍스트 쓰기 (덮어쓰기)\nFile.WriteAllText(\"file.txt\", \"Hello, World!\");\n\n// 여러 줄 쓰기\nstring[] lines = { \"첫 번째 줄\", \"두 번째 줄\" };\nFile.WriteAllLines(\"file.txt\", lines);\n\n// 바이트 쓰기\nFile.WriteAllBytes(\"file.bin\", bytes);\n```\n\n### 파일 추가\n\n```csharp\n// 기존 파일에 텍스트 추가\nFile.AppendAllText(\"file.txt\", \"추가 내용\\n\");\n\n// 여러 줄 추가\nFile.AppendAllLines(\"file.txt\", lines);\n```\n\n### 파일 존재 확인 및 삭제\n\n```csharp\n// 존재 확인\nif (File.Exists(\"file.txt\"))\n{\n    // 파일 삭제\n    File.Delete(\"file.txt\");\n}\n\n// 파일 복사\nFile.Copy(\"source.txt\", \"dest.txt\");\n\n// 파일 이동\nFile.Move(\"old.txt\", \"new.txt\");\n```\n\n## StreamReader 클래스\n\n파일을 한 줄씩 또는 부분적으로 읽을 때 사용합니다.\n\n```csharp\nusing (StreamReader reader = new StreamReader(\"file.txt\"))\n{\n    // 한 줄씩 읽기\n    string line;\n    while ((line = reader.ReadLine()) != null)\n    {\n        Console.WriteLine(line);\n    }\n}\n\n// 또는 전체 읽기\nusing (StreamReader reader = new StreamReader(\"file.txt\"))\n{\n    string content = reader.ReadToEnd();\n}\n```\n\n**특징:**\n- using 문으로 자동 리소스 해제\n- 큰 파일도 효율적으로 처리\n- 인코딩 지정 가능\n\n## StreamWriter 클래스\n\n파일에 텍스트를 쓸 때 사용합니다.\n\n```csharp\nusing (StreamWriter writer = new StreamWriter(\"file.txt\"))\n{\n    writer.WriteLine(\"첫 번째 줄\");\n    writer.WriteLine(\"두 번째 줄\");\n    writer.Write(\"줄바꿈 없이\");\n}\n\n// 추가 모드\nusing (StreamWriter writer = new StreamWriter(\"file.txt\", append: true))\n{\n    writer.WriteLine(\"추가 내용\");\n}\n```\n\n## FileStream 클래스\n\n바이너리 파일을 읽거나 쓸 때 사용합니다.\n\n```csharp\n// 바이트 쓰기\nusing (FileStream fs = new FileStream(\"data.bin\", FileMode.Create))\n{\n    byte[] data = { 1, 2, 3, 4, 5 };\n    fs.Write(data, 0, data.Length);\n}\n\n// 바이트 읽기\nusing (FileStream fs = new FileStream(\"data.bin\", FileMode.Open))\n{\n    byte[] data = new byte[fs.Length];\n    fs.Read(data, 0, data.Length);\n}\n```\n\n### FileMode 옵션\n\n- `Create`: 새 파일 생성 (기존 파일 덮어쓰기)\n- `Open`: 기존 파일 열기\n- `OpenOrCreate`: 파일이 있으면 열고, 없으면 생성\n- `Append`: 파일 끝에 추가\n- `Truncate`: 파일 내용 삭제 후 열기\n\n## BinaryReader와 BinaryWriter\n\n기본 데이터 타입을 바이너리로 읽고 씁니다.\n\n```csharp\n// 쓰기\nusing (BinaryWriter writer = new BinaryWriter(File.Open(\"data.bin\", FileMode.Create)))\n{\n    writer.Write(100);           // int\n    writer.Write(3.14);          // double\n    writer.Write(\"Hello\");       // string\n    writer.Write(true);          // bool\n}\n\n// 읽기\nusing (BinaryReader reader = new BinaryReader(File.Open(\"data.bin\", FileMode.Open)))\n{\n    int num = reader.ReadInt32();\n    double d = reader.ReadDouble();\n    string s = reader.ReadString();\n    bool b = reader.ReadBoolean();\n}\n```\n\n## Directory 클래스\n\n디렉토리(폴더) 작업을 위한 정적 메서드를 제공합니다.\n\n```csharp\n// 디렉토리 생성\nDirectory.CreateDirectory(\"NewFolder\");\n\n// 존재 확인\nif (Directory.Exists(\"NewFolder\"))\n{\n    // 디렉토리 삭제\n    Directory.Delete(\"NewFolder\");          // 빈 폴더만\n    Directory.Delete(\"NewFolder\", true);    // 하위 항목 포함\n}\n\n// 디렉토리 이동\nDirectory.Move(\"OldFolder\", \"NewFolder\");\n\n// 파일 목록 가져오기\nstring[] files = Directory.GetFiles(\"C:\\\\MyFolder\");\nstring[] txtFiles = Directory.GetFiles(\"C:\\\\MyFolder\", \"*.txt\");\n\n// 하위 디렉토리 목록\nstring[] dirs = Directory.GetDirectories(\"C:\\\\MyFolder\");\n```\n\n## Path 클래스\n\n파일 경로를 다루는 유틸리티 메서드를 제공합니다.\n\n```csharp\n// 경로 결합\nstring path = Path.Combine(\"C:\\\\Folder\", \"file.txt\");\n\n// 파일명 추출\nstring fileName = Path.GetFileName(\"C:\\\\Folder\\\\file.txt\");  // \"file.txt\"\n\n// 확장자 추출\nstring ext = Path.GetExtension(\"file.txt\");  // \".txt\"\n\n// 디렉토리 경로\nstring dir = Path.GetDirectoryName(\"C:\\\\Folder\\\\file.txt\");  // \"C:\\\\Folder\"\n\n// 확장자 제외 파일명\nstring nameWithoutExt = Path.GetFileNameWithoutExtension(\"file.txt\");  // \"file\"\n\n// 임시 파일 경로\nstring tempPath = Path.GetTempFileName();\n```\n\n## FileInfo와 DirectoryInfo\n\n파일과 디렉토리 정보를 객체로 다룹니다.\n\n### FileInfo\n\n```csharp\nFileInfo fileInfo = new FileInfo(\"file.txt\");\n\nif (fileInfo.Exists)\n{\n    Console.WriteLine($\"크기: {fileInfo.Length} bytes\");\n    Console.WriteLine($\"생성 시간: {fileInfo.CreationTime}\");\n    Console.WriteLine($\"수정 시간: {fileInfo.LastWriteTime}\");\n    Console.WriteLine($\"읽기 전용: {fileInfo.IsReadOnly}\");\n}\n\n// 파일 작업\nfileInfo.CopyTo(\"backup.txt\");\nfileInfo.MoveTo(\"newname.txt\");\nfileInfo.Delete();\n```\n\n### DirectoryInfo\n\n```csharp\nDirectoryInfo dirInfo = new DirectoryInfo(\"C:\\\\MyFolder\");\n\nif (dirInfo.Exists)\n{\n    // 파일 목록\n    FileInfo[] files = dirInfo.GetFiles();\n    \n    // 하위 디렉토리\n    DirectoryInfo[] subDirs = dirInfo.GetDirectories();\n}\n```\n\n## using 문\n\n파일 작업 후 자동으로 리소스를 해제합니다.\n\n```csharp\n// 전통적인 방식\nusing (StreamReader reader = new StreamReader(\"file.txt\"))\n{\n    // 파일 작업\n}  // 자동으로 reader.Dispose() 호출\n\n// C# 8.0 이상\nusing StreamReader reader = new StreamReader(\"file.txt\");\n// 파일 작업\n// 메서드 끝에서 자동 해제\n```\n\n## 인코딩\n\n텍스트 파일의 인코딩을 지정할 수 있습니다.\n\n```csharp\n// UTF-8로 읽기\nstring content = File.ReadAllText(\"file.txt\", Encoding.UTF8);\n\n// UTF-8로 쓰기\nFile.WriteAllText(\"file.txt\", content, Encoding.UTF8);\n\n// StreamReader에서 인코딩 지정\nusing (StreamReader reader = new StreamReader(\"file.txt\", Encoding.UTF8))\n{\n    // ...\n}\n```\n\n## 핵심 요약\n\n**File 클래스 (정적 메서드):**\n- `ReadAllText()`: 전체 읽기\n- `WriteAllText()`: 전체 쓰기\n- `AppendAllText()`: 추가\n- `Exists()`, `Delete()`, `Copy()`, `Move()`\n\n**Stream 클래스:**\n- `StreamReader`: 텍스트 읽기 (한 줄씩)\n- `StreamWriter`: 텍스트 쓰기\n- `FileStream`: 바이너리 읽기/쓰기\n- `BinaryReader/Writer`: 기본 타입 바이너리 처리\n\n**Directory 클래스:**\n- `CreateDirectory()`: 생성\n- `Delete()`: 삭제\n- `Exists()`: 존재 확인\n- `GetFiles()`, `GetDirectories()`: 목록\n\n**Path 클래스:**\n- `Combine()`: 경로 결합\n- `GetFileName()`: 파일명\n- `GetExtension()`: 확장자\n- `GetDirectoryName()`: 디렉토리 경로\n\n**Info 클래스:**\n- `FileInfo`: 파일 정보 및 작업\n- `DirectoryInfo`: 디렉토리 정보 및 작업\n\n**using 문:**\n- 자동 리소스 해제\n- IDisposable 인터페이스 구현 객체에 사용"
    },
    {
      "chapterId": 10,
      "title": "10단원: 예외처리와 고급 기능",
      "content": "# 10단원: 예외처리와 고급 기능\n\n## 예외처리 (Exception Handling)\n\n프로그램 실행 중 발생하는 오류를 처리하는 메커니즘입니다.\n\n### try-catch 문\n\n```csharp\ntry\n{\n    // 예외가 발생할 수 있는 코드\n    int result = 10 / 0;  // DivideByZeroException\n}\ncatch (Exception ex)\n{\n    // 예외 처리\n    Console.WriteLine($\"오류: {ex.Message}\");\n}\n```\n\n### 여러 catch 블록\n\n```csharp\ntry\n{\n    // 코드\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"0으로 나눌 수 없습니다.\");\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"형식이 올바르지 않습니다.\");\n}\ncatch (Exception ex)  // 가장 마지막에\n{\n    Console.WriteLine($\"알 수 없는 오류: {ex.Message}\");\n}\n```\n\n**순서:** 구체적인 예외부터 일반적인 예외 순서로\n\n### finally 블록\n\n예외 발생 여부와 관계없이 항상 실행됩니다.\n\n```csharp\ntry\n{\n    // 코드\n}\ncatch (Exception ex)\n{\n    // 예외 처리\n}\nfinally\n{\n    // 항상 실행 (리소스 정리 등)\n    Console.WriteLine(\"정리 작업\");\n}\n```\n\n### throw 키워드\n\n예외를 의도적으로 발생시킵니다.\n\n```csharp\nvoid Divide(int a, int b)\n{\n    if (b == 0)\n    {\n        throw new DivideByZeroException(\"나누는 수는 0이 될 수 없습니다.\");\n    }\n    return a / b;\n}\n\n// 예외 다시 던지기\ncatch (Exception ex)\n{\n    Console.WriteLine(\"로그 기록\");\n    throw;  // 원래 예외를 그대로 던짐\n}\n```\n\n### 주요 예외 클래스\n\n- `Exception`: 모든 예외의 기본 클래스\n- `ArgumentException`: 잘못된 인수\n- `ArgumentNullException`: null 인수\n- `InvalidOperationException`: 잘못된 작업\n- `FormatException`: 형식 오류\n- `IndexOutOfRangeException`: 인덱스 범위 초과\n- `NullReferenceException`: null 참조\n- `DivideByZeroException`: 0으로 나누기\n- `FileNotFoundException`: 파일 없음\n- `IOException`: 입출력 오류\n\n### 사용자 정의 예외\n\n```csharp\nclass MyException : Exception\n{\n    public MyException() { }\n    public MyException(string message) : base(message) { }\n}\n\n// 사용\nthrow new MyException(\"사용자 정의 예외 발생\");\n```\n\n## 제네릭 (Generics)\n\n타입을 매개변수화하여 재사용 가능한 코드를 작성합니다.\n\n### 제네릭 클래스\n\n```csharp\nclass Box<T>\n{\n    private T item;\n    \n    public void Set(T value)\n    {\n        item = value;\n    }\n    \n    public T Get()\n    {\n        return item;\n    }\n}\n\n// 사용\nBox<int> intBox = new Box<int>();\nintBox.Set(100);\n\nBox<string> strBox = new Box<string>();\nstrBox.Set(\"Hello\");\n```\n\n### 제네릭 메서드\n\n```csharp\nT GetFirst<T>(T[] array)\n{\n    return array[0];\n}\n\n// 사용\nint first = GetFirst<int>(new int[] { 1, 2, 3 });\nstring firstStr = GetFirst<string>(new string[] { \"a\", \"b\" });\n```\n\n### 제네릭 제약 조건\n\n```csharp\n// where T : class (참조 타입만)\nclass Container<T> where T : class\n{\n    // ...\n}\n\n// where T : struct (값 타입만)\nclass Container<T> where T : struct\n{\n    // ...\n}\n\n// where T : new() (기본 생성자 있는 타입)\nclass Container<T> where T : new()\n{\n    public T CreateInstance()\n    {\n        return new T();\n    }\n}\n\n// where T : 특정클래스 (특정 클래스 상속)\nclass Container<T> where T : Animal\n{\n    // ...\n}\n```\n\n## 델리게이트 (Delegate)\n\n메서드를 참조하는 타입입니다.\n\n### 델리게이트 선언 및 사용\n\n```csharp\n// 델리게이트 선언\ndelegate int Calculate(int a, int b);\n\nclass Program\n{\n    static int Add(int a, int b) { return a + b; }\n    static int Multiply(int a, int b) { return a * b; }\n    \n    static void Main()\n    {\n        Calculate calc = Add;\n        int result = calc(10, 20);  // 30\n        \n        calc = Multiply;\n        result = calc(10, 20);  // 200\n    }\n}\n```\n\n### Func와 Action (내장 델리게이트)\n\n```csharp\n// Func: 반환값이 있는 메서드\nFunc<int, int, int> add = (a, b) => a + b;\nint sum = add(10, 20);\n\n// Action: 반환값이 없는 메서드\nAction<string> print = (msg) => Console.WriteLine(msg);\nprint(\"Hello\");\n```\n\n**Func:** 마지막 타입 매개변수가 반환 타입  \n**Action:** 반환값 없음 (void)\n\n## 이벤트 (Event)\n\n특정 상황이 발생했을 때 알림을 보내는 메커니즘입니다.\n\n```csharp\nclass Button\n{\n    // 이벤트 선언\n    public event EventHandler Clicked;\n    \n    public void Click()\n    {\n        // 이벤트 발생\n        Clicked?.Invoke(this, EventArgs.Empty);\n    }\n}\n\n// 사용\nButton btn = new Button();\nbtn.Clicked += (sender, e) => Console.WriteLine(\"버튼 클릭됨\");\nbtn.Click();  // \"버튼 클릭됨\" 출력\n```\n\n## 람다 식 (Lambda Expression)\n\n익명 함수를 간결하게 표현합니다.\n\n```csharp\n// 기본 형태\n(매개변수) => 식\n\n// 예제\nFunc<int, int> square = x => x * x;\nFunc<int, int, int> add = (a, b) => a + b;\n\n// 본문이 여러 줄\nFunc<int, int> factorial = n =>\n{\n    int result = 1;\n    for (int i = 1; i <= n; i++)\n        result *= i;\n    return result;\n};\n```\n\n**LINQ와 함께 자주 사용:**\n```csharp\nvar evenNumbers = numbers.Where(n => n % 2 == 0);\n```\n\n## async와 await (비동기 프로그래밍)\n\n비동기 작업을 동기 코드처럼 작성할 수 있게 합니다.\n\n```csharp\nasync Task<string> DownloadAsync(string url)\n{\n    using (HttpClient client = new HttpClient())\n    {\n        string content = await client.GetStringAsync(url);\n        return content;\n    }\n}\n\n// 사용\nstring result = await DownloadAsync(\"https://example.com\");\n```\n\n**규칙:**\n- 비동기 메서드는 `async` 키워드 사용\n- 반환 타입: `Task`, `Task<T>`, `void` (이벤트 핸들러)\n- 메서드 이름: 관례상 `Async` 접미사\n- `await`는 `async` 메서드 내에서만 사용\n\n## nullable 타입\n\n값 타입에 null을 허용합니다.\n\n```csharp\n// Nullable<int> 또는 int?\nint? nullableInt = null;\n\nif (nullableInt.HasValue)\n{\n    int value = nullableInt.Value;\n}\n\n// ?? 연산자로 기본값 제공\nint result = nullableInt ?? 0;\n```\n\n## Nullable 참조 타입 (C# 8.0)\n\n참조 타입의 null 가능성을 명시적으로 표현합니다.\n\n```csharp\n// 프로젝트 설정에서 활성화 필요\n#nullable enable\n\nstring notNull = \"Hello\";     // null 불가\nstring? canBeNull = null;     // null 가능\n\n// 경고 발생\nint length = canBeNull.Length;  // 경고: null일 수 있음\n\n// null 검사 후 사용\nif (canBeNull != null)\n{\n    int length = canBeNull.Length;  // 안전\n}\n```\n\n## 튜플 (Tuple)\n\n여러 값을 하나로 묶어 반환합니다.\n\n```csharp\n// 튜플 반환\n(int, string) GetPerson()\n{\n    return (25, \"홍길동\");\n}\n\n// 사용\nvar person = GetPerson();\nConsole.WriteLine($\"{person.Item1}, {person.Item2}\");\n\n// 명명된 튜플\n(int age, string name) GetNamedPerson()\n{\n    return (25, \"홍길동\");\n}\n\nvar p = GetNamedPerson();\nConsole.WriteLine($\"{p.age}, {p.name}\");\n\n// 분해 (Deconstruction)\nvar (age, name) = GetNamedPerson();\nConsole.WriteLine($\"{age}, {name}\");\n```\n\n## 확장 메서드 (Extension Method)\n\n기존 타입에 새로운 메서드를 추가합니다.\n\n```csharp\nstatic class StringExtensions\n{\n    public static int WordCount(this string str)\n    {\n        return str.Split(' ').Length;\n    }\n}\n\n// 사용\nstring text = \"Hello World\";\nint count = text.WordCount();  // 2\n```\n\n**규칙:**\n- static 클래스의 static 메서드\n- 첫 번째 매개변수에 `this` 키워드\n\n## 핵심 요약\n\n**예외처리:**\n- `try-catch-finally`\n- 여러 catch 블록 (구체적 → 일반적)\n- `throw`: 예외 발생\n- finally: 항상 실행\n\n**제네릭:**\n- `<T>`: 타입 매개변수\n- 재사용 가능한 코드\n- 제약 조건: class, struct, new() 등\n\n**델리게이트:**\n- 메서드 참조 타입\n- Func<>: 반환값 있음\n- Action<>: 반환값 없음\n\n**이벤트:**\n- `event` 키워드\n- 알림 메커니즘\n\n**람다식:**\n- `(매개변수) => 식`\n- 익명 함수\n\n**비동기:**\n- `async`/`await`\n- Task, Task<T>\n\n**nullable:**\n- 값 타입: `int?`\n- 참조 타입: `string?` (C# 8.0)\n\n**튜플:**\n- 여러 값 반환\n- `(타입1, 타입2)`\n\n**확장 메서드:**\n- `this` 키워드\n- 기존 타입에 메서드 추가"
    }
  ]
}
